<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺1</title>
    <url>/2023/11/19/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-1-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li>使用Photoshop制作了网页的主界面视图UI效果示意图和LOGO</li>
<li>按照设计计划制作了网站HTML页面</li>
<li>展示GitHub当日代码&#x2F;文档签入记录：</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/1.png"
                      alt="1"
                ></li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>继续美化前端，思考更多前端功能，配合后端</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>添加更多便捷功能，提升用户体验</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>前端各种插件按钮的位置大小调整，排列方式和外观，页面缩放引起的组件排列等等的调试问题</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用，加强了web前端的知识</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>了解学会使用fork，学习了解如何搭建web项目和配置，完成了部分前端任务。</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/2.png"
                      alt="2"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>与后端结合，实现前端的图像显示和页面优化。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>将前端与后端结合，对页面进一步美化。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>对项目的规划还不够了解，遇到一些技术问题需要加强合作。</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用，学会用js设计网页。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学习了fork的使用，学习并尝试实现了CNN自动编码器的基本框架，训练模型中。</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/3.png"
                      alt="3"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>继续修改错误，继续调试CNN编码器训练。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>将CNN编码器训练完成，争取得到输出结果。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>错误很多，不熟悉用java编写CNN，训练过程中的错误还没有得到修改，正在学习和修改中。</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会使用fork，了解了nd4j库的使用及CNN基本结构。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学会fork的使用，学习了解如何搭建web项目的系统框架，制定初步的计划</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/4.png"
                      alt="4"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>搭建好整体系统框架</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>搭建后台接受前端传来的图片，调用训练好的神经网络模型，返回处理好的图片给前端</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>对项目的规划还不够清晰，对大部分运用到的知识不够熟练</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用以及多人协同完成一个项目</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学习了fork的使用，在git上创建了仓库</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/5.png"
                      alt="5"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>系统架构搭建，搭建好整体的Web项目的系统框架，使用Django框架来实现开发。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>搭建后台，接受前端传来的图片url，同时以python脚本的形式调用训练好的神经网络模型，再将处理好的图片返回给前端。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>没有学习过python，不太了解后端的工作，不了解Django如何调用训练好的模型</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学习了基本的git和python知识，对于后续调用训练好的模型还比较困惑</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li><p>Logo<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/6.png"
                      alt="6"
                ></p>
</li>
<li><p>主界面UI初版示意图<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/7.png"
                      alt="7"
                ></p>
</li>
<li><p>网站主页面<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/8.png"
                      alt="8"
                ></p>
</li>
<li><p>点击图片放大显示功能<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/9.png"
                      alt="9"
                ></p>
</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/10.png"
                      alt="10"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.11.19 14:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室303</p>
</li>
<li><p><strong>内容</strong>：</p>
<ul>
<li><h4 id="团队进展"><a href="#团队进展" class="headerlink" title="团队进展"></a>团队进展</h4><ul>
<li><strong>前端开发</strong>：<ul>
<li>完成了网页主界面视图UI和LOGO的制作，以及网站HTML页面的初步设计。</li>
<li>已实现部分前端功能，并对前端进行初步美化。</li>
</ul>
</li>
<li><strong>后端开发</strong>：<ul>
<li>着手搭建Web项目的系统框架。</li>
<li>初步学习并尝试实现CNN自动编码器的基础框架，模型训练正在进行中。</li>
</ul>
</li>
<li><strong>项目管理和协调</strong>：<ul>
<li>团队成员均已学习使用fork进行协作。</li>
<li>项目的GitHub代码和文档签入记录展示了目前的进展。</li>
</ul>
</li>
</ul>
<h4 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h4><ul>
<li><strong>前端开发</strong>：<ul>
<li>继续改善前端设计和用户体验，增加更多便捷功能。</li>
<li>将前端与后端结合，优化图像显示和页面设计。</li>
</ul>
</li>
<li><strong>后端开发</strong>：<ul>
<li>继续完善CNN编码器的训练，解决遇到的技术难题。</li>
<li>完成系统框架的搭建，特别是后台处理模块，以实现前端图像的接收和处理。</li>
</ul>
</li>
<li><strong>团队协作</strong>：<ul>
<li>加强团队成员间的沟通和协作，尤其是在项目规划和技术问题解决方面。</li>
<li>持续学习和掌握新知识和工具。</li>
</ul>
</li>
</ul>
<h4 id="当前挑战"><a href="#当前挑战" class="headerlink" title="当前挑战"></a>当前挑战</h4><ul>
<li>团队成员对项目规划和所用技术不够熟悉，需要加强学习和协作。</li>
<li>在CNN编码器的训练和后端开发中遇到了一些技术难题，正在寻求解决方案。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺2</title>
    <url>/2023/11/26/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-2-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>优化了前端显示，修复了不同屏幕分辨率下的显示错误bug</li>
<li>将Java项目转为Python的flask项目</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/1.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>配合后端接口，加入类似锁的机制防止卡死</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>添加更多便捷功能，提升用户体验，继续美化前端，思考更多前端功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>页面缩放引起的组件遮挡消失，滑动条显示问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对前端的理解更深入，学会了pycharm转换更改项目所用的Python版本，对前后端对接还不太清楚</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>学习了python，安装了pycharm，并配置了python。更新了前端网页，学习前后端交互相关知识。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/2.png"
                      alt="2"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化页面设计，配合后端交互。</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>提升用户体验，继续美化页面，实现图片的流转。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>pycharm打开不了网页，python安装失败。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了python，前后端等知识。疑问是现在的训练模型需要的是一个数据集，如何将单个图片放到文件夹中。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>决定使用pycharm完成项目，配置pycharm环境，完成加噪并去噪的CNN自动编码器。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/3.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>尝试去掉加噪部分，对一张本身带噪声的图片进行去噪。</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>完成模型训练并接入后端</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>python版本过新，导致TensorFlow模块不能安装，只能重新安装3.9版本。数据集下载失败，只能通过本地下载，再用路径读取。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对CNN模型有了更多认识，学会了pycharm的使用。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>配置pycharm环境，了解接口文档的写法，学习前后端交互知识</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/4.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>将模型接入后端，写接口文档，完成前后端交互</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>前后端交互，与模型的数据对接</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>在pycharm中因为版本问题下载框架失败，已解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>大概了解了接口文档的写法,简单学习前后端交互 ，对图片的传输和对接过程还是不太清楚</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>尝试用pycharm将模型接入后端，并用apifox写接口文档</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/5.png"
                      alt="5"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>将模型接入后端并继续完成接口文档</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>与前端对接</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>python版本问题，将模型接入后端时遇到了一些问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了简单的后端知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>正常网页分辨率显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
<li>窄分辨率显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/7.png"
                      alt="7"
                >编辑</li>
<li>数据集的模型训练</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/8.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/9.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.11.26 16:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室304</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目进展概况"><a href="#1-项目进展概况" class="headerlink" title="1. 项目进展概况"></a>1. 项目进展概况</h4><ul>
<li>讨论了团队成员在项目中的整体进展情况，包括前端显示优化、项目从Java转换到Python Flask的进展，以及前后端交互的学习和实现。</li>
<li>着重强调了对不同屏幕分辨率的适配问题，确保网页在不同设备上均能正常显示。</li>
</ul>
<h4 id="2-技术难点和解决方案"><a href="#2-技术难点和解决方案" class="headerlink" title="2. 技术难点和解决方案"></a>2. 技术难点和解决方案</h4><ul>
<li>分析了在项目开发中遇到的技术难题，如页面缩放导致的组件遮挡和滑动条显示问题，以及Python版本兼容性问题。</li>
<li>讨论了可能的解决方案，包括技术选型调整、版本兼容性检查，以及增强团队成员之间的技术交流。</li>
</ul>
<h4 id="3-后续计划和任务分配"><a href="#3-后续计划和任务分配" class="headerlink" title="3. 后续计划和任务分配"></a>3. 后续计划和任务分配</h4><ul>
<li>计划了接下来的工作，包括继续优化前端页面设计，加强前后端的数据交互，以及将机器学习模型更好地集成到后端。</li>
<li>对剩余任务进行了详细的分配，确保每位团队成员都清楚自己的责任和接下来的工作重点。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺3</title>
    <url>/2023/12/03/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-3-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>成功连接前后端，前端上传按钮点击后可以选择图片上传，上传后在前端有显示，并且通过后端将上传图片存储在了images里</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步优化前端功能与界面，实现新增的转换按钮的功能（与后端对接）</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前后端连接错误，改正script中的方法后解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对JavaScript与HTML理解更深入，对前端布局理解</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>增加了一个开始去噪的按钮，配置了ui图像，调整页面，修改按钮的颜色。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端的对接工作，将模型接入传送过程，实装相应的按钮和进度条的功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习前端，学习python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>使用训练的模型对本地图片进行去噪，对模型多次修改以达到期望效果。</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续修改模型，实现输出图片颜色与输入图片相同。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>刚开始的模型，输入输出图片颜色与原图像不一致，改过之后输入图片正确，但是输出图像不仅模糊，而且没有色彩，这个问题现在依旧没有解决。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习CNN自动编码器，学习了python语法。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>尝试获取前端图片并将其传给模型进行训练，但只完成从前端获取图片存到本地文件夹</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端对接工作，将模型接入传送过程</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>图片保存路径与预期不符，还无法连接到模型</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了一些后端相关知识，学习了python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>进行了前后端的部分对接，目前实现了从前端获取要修复的图片到本地</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/5.png"
                      alt="5"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完成前后端对接工作，实现将训练好的图片传回给前端</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前后端对接时出现问题，前端上传的图片无法保存到本地制定文件夹</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了相关的Python知识，了解前后端对接的基本工作</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>添加了转换按钮</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/10.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.3 16:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室303</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目进展概况"><a href="#1-项目进展概况" class="headerlink" title="1. 项目进展概况"></a>1. 项目进展概况</h4><ul>
<li><strong>前后端连接</strong>：成功实现了前后端的基本连接，使前端可以上传图片，后端可以接收并存储这些图片。</li>
<li><strong>界面优化</strong>：团队成员对用户界面进行了改进，增加了去噪按钮，并优化了界面的整体布局和视觉效果。</li>
<li><strong>模型训练与应用</strong>：对去噪模型进行了训练和调整，以便更好地处理上传的图片。</li>
</ul>
<h4 id="2-技术难点和解决方案"><a href="#2-技术难点和解决方案" class="headerlink" title="2. 技术难点和解决方案"></a>2. 技术难点和解决方案</h4><ul>
<li><strong>前后端对接问题</strong>：解决了前后端连接时出现的错误，主要通过调整代码和脚本实现。</li>
<li><strong>模型集成问题</strong>：正在努力将去噪模型完全集成到前后端流程中，以便实现自动处理上传的图片。</li>
<li><strong>图像处理问题</strong>：在图像去噪的模型训练中遇到了输出图像颜色和清晰度的问题，团队正在通过调整模型参数和算法来解决这些问题。</li>
</ul>
<h4 id="3-后续计划和任务分配"><a href="#3-后续计划和任务分配" class="headerlink" title="3. 后续计划和任务分配"></a>3. 后续计划和任务分配</h4><ul>
<li><strong>前端功能优化</strong>：继续提升用户界面，包括增加新的功能按钮和改进现有布局。</li>
<li><strong>模型优化与集成</strong>：继续调整和改进去噪模型，确保模型能够有效集成到整个系统中。</li>
<li><strong>前后端进一步对接</strong>：加强前后端的协同工作，确保系统的流畅运行，特别是在图像上传和处理方面。</li>
</ul>
<p>团队将继续密切协作，确保按时完成项目目标，同时解决任何新出现的技术挑战。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺1</title>
    <url>/2023/12/10/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-1-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>优化前端格式和排列表现</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步优化前端功能与界面，设计UI，实现新增的转换按钮的功能（与后端对接）</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>组件扩展使整体屏幕分辨率改变出现bug，调整组件位置已经禁用横向滚动条之后解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对JavaScript与HTML理解更好，对前端布局理解加深</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>更改了顶部导航栏，重新安排了按钮的位置，修改了按钮的颜色。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端的对接工作，将模型接入传送过程，实装相应的按钮和进度条的功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入，模型训练困难</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习前端，学习python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>修改模型，实现输入图片与输出图片颜色一致；增加训练轮数和卷积层数，以减请轻去噪后的模糊情况。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续修改模型，同时学习CNN编码器相关知识，寻求更好的模型用于图像去噪。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>电脑没有独显，模型训练很慢，而且图像模糊还没有得到解决。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对CNN编码器的了解更多，认识了很多去噪算法。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>协助模型训练的同学进行模型训练,修改部分细节使图片更适应模型</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/4.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成模型训练及后端传输图片</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>之前的模型训练效果不好，重新开始训练，模型和前端的交接遇到点问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解了模型训练的一些知识</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>协助模型训练的同学进行模型训练</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成模型训练及后端传输图片</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>之前的模型训练效果不好，重新开始训练</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解了模型训练的一些知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>增加及修改加了顶部菜单栏的组件</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/10.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.10 20:00</p>
</li>
<li><p><strong>地点</strong>：腾讯会议</p>
</li>
<li><p><strong>内容</strong>：</p>
<h3 id="进展回顾"><a href="#进展回顾" class="headerlink" title="进展回顾"></a>进展回顾</h3><ol>
<li><strong>前端开发</strong>:<ul>
<li>在前端方面取得了重要进展。包括对前端格式的优化、排列表现的改善、顶部导航栏的重新设计，以及按钮颜色的调整。</li>
<li>计划进一步增强前端功能和界面设计，特别是实现新的转换按钮功能，并与后端紧密对接。</li>
</ul>
</li>
<li><strong>模型训练与后端开发</strong>:<ul>
<li>模型训练上，实现了输入输出图片颜色一致性的改进，并通过增加训练轮数和卷积层数减轻了去噪后的模糊情况。</li>
<li>后续计划着重于模型的进一步改进，特别是针对CNN编码器的深入学习和应用，以及模型和前端的有效整合。</li>
</ul>
</li>
</ol>
<h3 id="遇到的挑战"><a href="#遇到的挑战" class="headerlink" title="遇到的挑战"></a>遇到的挑战</h3><ul>
<li>团队面临的主要挑战包括前端组件扩展导致的bug、模型训练的效率问题以及前后端的有效整合。</li>
</ul>
<h3 id="收获与展望"><a href="#收获与展望" class="headerlink" title="收获与展望"></a>收获与展望</h3><ul>
<li>成员们在JavaScript、HTML、Python语言及前后端交互方面有了更深入的理解和应用。</li>
<li>对CNN编码器和去噪算法的认识更加深入，为未来的开发提供了坚实的基础。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来看，每位成员都在其专长领域作出了积极贡献。虽然面临一些技术挑战，但团队成员通过有效合作，已经取得了显著的进展，并对未来的工作有了清晰的规划和方向。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺2</title>
    <url>/2023/12/18/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-2-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>前端微调，使导航栏固定在屏幕，删除冗余按钮，使下拉菜单正常实现，进行了UI和背景调整的美化工作</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化滚动式前端，添加轮转图片，设计网页介绍UI和按钮UI等等</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>动画效果还未实现</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端动效以及美化，阅读了相关案例代码</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>更改页面结构为滑动式长页面，增添了模态框，增添了轮播图片动效</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>修改UI里的一些新的bug，完成前后端的对接工作，丰富美化页面</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入，模型训练困难，轮播图总是自己放大，动画效果加载失败</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端动效美化知识，阅读了相关代码</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>参考老师的代码，实现了CBDnet模型进行去噪，模型训练完成。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>协助负责后端的同学进行模型的调用。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>采用CNN模型，总是会出现图片部位丢失的错误，所以改用CBDnet模型。由于模型是用GPU运行的，我只能在同学的电脑上运行</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了CBDnet的有关知识。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>辅助训练备选模型，挑选出效果最好的模型，解决图片上传报错的问题</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步实现图片的传输，完成前后端对接工作</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型训练的效果图存在各种各样的问题，图片的传输依旧有点混乱</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解到不同的路径写法，学习到不同路径对图片传输的影响</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>辅助训练模型，编写后端接口</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/5.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成后端任务，实现图片的传输与保存</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>训练的模型去噪效果不是很好，图片太过模糊，并且对图片格式要求很严格</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了python的一些基础知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>网站前端改为滚动式，美化了界面，结构重新设计</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/6.png"
                      alt="6"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/7.png"
                      alt="7"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/8.png"
                      alt="8"
                ></li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/10.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.17 19:00</p>
</li>
<li><p><strong>地点</strong>：腾讯会议</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-前端开发进展"><a href="#1-前端开发进展" class="headerlink" title="1. 前端开发进展"></a>1. 前端开发进展</h4><ul>
<li><strong>界面重设计</strong>：网站前端已改为滚动式，为用户提供了更流畅的浏览体验。</li>
<li><strong>UI&#x2F;UX改善</strong>：对用户界面和体验进行了显著的美化和优化，使网站更加吸引用户。</li>
<li><strong>动效和微调</strong>：实现了一些基本的动画效果，对导航栏、下拉菜单等元素进行了微调，以提高页面的整体美观性和用户体验。</li>
</ul>
<h4 id="2-后端开发与模型训练"><a href="#2-后端开发与模型训练" class="headerlink" title="2. 后端开发与模型训练"></a>2. 后端开发与模型训练</h4><ul>
<li><strong>模型选择与训练</strong>：经过对比，选择了CBDnet模型进行去噪处理，模型训练有初步成果。</li>
<li><strong>后端接口与集成</strong>：开发了后端接口，正在努力实现前后端的顺畅对接，以及图片的有效传输与保存。</li>
</ul>
<h4 id="3-遇到的挑战"><a href="#3-遇到的挑战" class="headerlink" title="3. 遇到的挑战"></a>3. 遇到的挑战</h4><ul>
<li><strong>模型效果与优化</strong>：目前模型去噪效果存在一些问题，如图片模糊、格式要求严格等，团队正在积极寻找解决方案。</li>
<li><strong>动画效果实现</strong>：一些复杂的动画效果实现上存在困难，团队成员正在学习相关技术以改善这一点。</li>
</ul>
<h4 id="4-收获与展望"><a href="#4-收获与展望" class="headerlink" title="4. 收获与展望"></a>4. 收获与展望</h4><ul>
<li><strong>技术提升</strong>：通过本项目，团队成员在前端设计、后端开发和模型训练方面都有了显著的成长。</li>
<li><strong>团队协作</strong>：加强了团队间的沟通和协作，通过共同解决问题增强了团队凝聚力。</li>
</ul>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul>
<li>本次Beta冲刺阶段，团队成员共同努力，取得了显著的进步。尽管面临诸多挑战，但团队通过有效的沟通和协作，不断优化项目，朝着最终目标稳步前进。未来，团队将继续致力于解决剩余的技术难题，并期待在项目最终阶段呈现出更加完善的成果。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺3</title>
    <url>/2023/12/24/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-3-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>删除了所有冗余文件，完成了下载功能，优化了所有UI，加入了介提示等等。调整了按钮布局，添加了开发者信息，对网站流程进行了优化，可以作为正式版</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化网页介绍UI和功能等等</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>图片模型去噪完之后没有显示到前段，路径丢失与函数调用关系的调试。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端美化，以及前后端接口使用，学习了pycharm，以及前端CSS，HTML，JavaScript的知识</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>完成了前端，实现了上传显示下载等功能，增加了进度条和去噪时锁定页面的功能。 接下来的计划：继续优化模型。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>在实现按钮的过程中，出现了找不到位置的问题，之后模型运行成功，但是一直没有自动更新显示去噪后的图片。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了pycharm，学习了HTML等前端知识，探索了滚动式长页面网页的实现。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>完成CBDnet模型训练，实现图片去噪，协助负责后端的同学进行模型的调用。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化模型。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>一开始模型在只有CPU的电脑上运行会失败，后来在学长的帮助下将这个问题成功解决。还有就是我的fork出现一些问题，push不上去，害怕重新pull下来会覆盖掉我写的文件，选择将文件打包发给组内同学。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了CBDnet和模型调用的有关知识。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>将前端上传的图片保存到images文件夹并将其重命名为original.jpg；修改代码使前端的任何格式图片都可被模型识别并处理；将模型处理的结果图片改成只有处理后效果的图片并命名为result存放到result文件夹中以供前端调用显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完善优化代码</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前端图片保存到本地有点小问题，但顺利解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了后端处理图片以及保存路径的相关知识</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>将前端上传的图片保存到images文件夹并重命名为original.jpg；修改代码使前端的任何格式图片都可被模型识别并处理；将模型处理的结果图片命名为result并存放到result文件夹中以供前端调用显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/5.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完善优化代码</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前端图片保存到本地有点小问题，但顺利解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了后端python的相关知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>网站前端改为滚动式，修改了背景，添加说明UI，美化了界面，结构重新设计</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/6.png"
                      alt="点击并拖拽以移动"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/7.png"
                      alt="点击并拖拽以移动"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/8.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/10.jpg"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.31 23:00</p>
</li>
<li><p><strong>地点</strong>：海底捞</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目结项总结"><a href="#1-项目结项总结" class="headerlink" title="1. 项目结项总结"></a>1. 项目结项总结</h4><ul>
<li>对项目从启动到结项的整体进展进行了回顾，强调了团队在各个阶段所取得的成果和学习的经验。</li>
</ul>
<h4 id="2-关键成就突出"><a href="#2-关键成就突出" class="headerlink" title="2. 关键成就突出"></a>2. 关键成就突出</h4><ul>
<li>着重讨论了项目中的关键成就，如前端界面的创新设计、后端功能的强化以及整体用户体验的显著提升。</li>
<li>强调了CBDnet模型在项目中的成功应用，及其对图片处理效果的显著提升。</li>
</ul>
<h4 id="3-技术挑战与团队克服"><a href="#3-技术挑战与团队克服" class="headerlink" title="3. 技术挑战与团队克服"></a>3. 技术挑战与团队克服</h4><ul>
<li>回顾了项目过程中遇到的技术挑战，如模型的选择和优化、前后端的有效集成等，并讨论了团队如何共同解决这些问题。</li>
</ul>
<h4 id="4-团队合作与个人成长"><a href="#4-团队合作与个人成长" class="headerlink" title="4. 团队合作与个人成长"></a>4. 团队合作与个人成长</h4><ul>
<li>着重强调了团队合作在项目成功中的关键作用，分享了通过项目成员在技术、协作和问题解决方面的成长。</li>
</ul>
<h4 id="5-项目的长期影响与未来展望"><a href="#5-项目的长期影响与未来展望" class="headerlink" title="5. 项目的长期影响与未来展望"></a>5. 项目的长期影响与未来展望</h4><ul>
<li>探讨了项目对团队成员未来职业生涯的潜在影响，以及所学技能和经验如何在未来的工作中得到应用。</li>
<li>对未来可能的项目迭代和技术发展进行了展望。</li>
</ul>
<h4 id="6-结项感想与感谢"><a href="#6-结项感想与感谢" class="headerlink" title="6. 结项感想与感谢"></a>6. 结项感想与感谢</h4><ul>
<li>成员们分享了对项目结项的感想，表达了对团队努力和成就的认可。</li>
<li>对参与项目的每位成员、指导老师和合作伙伴表示感谢。</li>
</ul>
<h4 id="7-会议总结"><a href="#7-会议总结" class="headerlink" title="7. 会议总结"></a>7. 会议总结</h4><ul>
<li>回顾了本次项目的整体旅程，从启动到结项，每个阶段的学习和成长。</li>
<li>强调了团队合作和共同努力在实现项目目标中的重要性，并对团队成员在未来的挑战中取得的成功表示乐观。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender建模/动画作品</title>
    <url>/2023/07/15/Blender%E5%BB%BA%E6%A8%A1-%E5%8A%A8%E7%94%BB%E4%BD%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="三兄弟建模（几何）"><a href="#三兄弟建模（几何）" class="headerlink" title="三兄弟建模（几何）"></a>三兄弟建模（几何）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/1_%E4%B8%89%E5%85%84%E5%BC%9F.png"
                      alt="1_三兄弟"
                ></p>
<h3 id="积木建模-动画（动画）"><a href="#积木建模-动画（动画）" class="headerlink" title="积木建模&#x2F;动画（动画）"></a>积木建模&#x2F;动画（动画）</h3><p>【Blender积木】 <a class="link"   href="https://www.bilibili.com/video/BV15K421x7aj/?share_source=copy_web" >https://www.bilibili.com/video/BV15K421x7aj/?share_source=copy_web <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1701692717&bvid=BV15K421x7aj&cid=1463230031&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/2_%E7%A7%AF%E6%9C%A8.png"
                      alt="2_积木"
                ></p>
<h3 id="金币基站建模（金属光泽材质）"><a href="#金币基站建模（金属光泽材质）" class="headerlink" title="金币基站建模（金属光泽材质）"></a>金币基站建模（金属光泽材质）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/3_%E9%87%91%E5%B8%81%E5%9F%BA%E7%AB%99.png"
                      alt="3_金币基站"
                ></p>
<h3 id="跑车建模-动画（复杂图形建模与循环动画）"><a href="#跑车建模-动画（复杂图形建模与循环动画）" class="headerlink" title="跑车建模&#x2F;动画（复杂图形建模与循环动画）"></a>跑车建模&#x2F;动画（复杂图形建模与循环动画）</h3><p>【Blender跑车】 <a class="link"   href="https://www.bilibili.com/video/BV1Mj421f71M/?share_source=copy_web" >https://www.bilibili.com/video/BV1Mj421f71M/?share_source=copy_web <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1651706227&bvid=BV1Mj421f71M&cid=1463231676&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E8%BD%A6%E5%A4%B4.png"
                      alt="跑车车头"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E7%89%B9%E5%86%992.png"
                      alt="跑车特写2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E4%BE%A7%E9%9D%A2.png"
                      alt="跑车侧面"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E9%A1%B6%E9%83%A8.png"
                      alt="跑车顶部"
                ></p>
<h3 id="荧光树桩建模（半透明材质）"><a href="#荧光树桩建模（半透明材质）" class="headerlink" title="荧光树桩建模（半透明材质）"></a>荧光树桩建模（半透明材质）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/5_%E8%8D%A7%E5%85%89%E6%A0%91%E6%A1%A9.png"
                      alt="5_荧光树桩"
                ></p>
<h3 id="子弹时间建模-动画（物理效果模拟）"><a href="#子弹时间建模-动画（物理效果模拟）" class="headerlink" title="子弹时间建模&#x2F;动画（物理效果模拟）"></a>子弹时间建模&#x2F;动画（物理效果模拟）</h3><p>【Blender子弹时间】 <a class="link"   href="https://www.bilibili.com/video/BV1xW421c7ux/?share_source=copy_web" >https://www.bilibili.com/video/BV1xW421c7ux/?share_source=copy_web <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1851675396&bvid=BV1xW421c7ux&cid=1463235980&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9-%E5%B0%81%E9%9D%A2.jpg"
                      alt="子弹-封面"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9%E6%85%A2%E5%8A%A8%E4%BD%9C%E6%99%AF%E6%B7%B1.png"
                      alt="子弹慢动作景深"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9%E6%99%AF%E6%B7%B1.png"
                      alt="子弹景深"
                ></p>
<h3 id="离散猴头（几何节点）"><a href="#离散猴头（几何节点）" class="headerlink" title="离散猴头（几何节点）"></a>离散猴头（几何节点）</h3><p>【Blender猴头】 <a class="link"   href="https://www.bilibili.com/video/BV1Uj421Z7Nc/?share_source=copy_web" >https://www.bilibili.com/video/BV1Uj421Z7Nc/?share_source=copy_web <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1651642308&bvid=BV1Uj421Z7Nc&cid=1463239128&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Blender</category>
        <category>建模/动画</category>
      </categories>
      <tags>
        <tag>Blender</tag>
        <tag>建模</tag>
        <tag>动画</tag>
        <tag>作品集</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GUI-音乐播放器</title>
    <url>/2023/05/17/Java-GUI-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<h2 id="a-软件功能说明"><a href="#a-软件功能说明" class="headerlink" title="(a)软件功能说明"></a>(a)软件功能说明</h2><p>①线上歌单的获取和保存，加载进度条</p>
<p>②本地歌单的创建和保存（包括歌单封面选择，音乐的添加和删除），本地歌单的修改（封面，重命名），删除歌单</p>
<p>③播放器功能，双击选中歌曲播放（默认循环播放），停止，上一首，下一首，随机播放，顺序播放，单曲循环</p>
<p>④音乐播放进度条，当前播放的显示</p>
<h2 id="b-软件架构设计"><a href="#b-软件架构设计" class="headerlink" title="(b)软件架构设计"></a>(b)软件架构设计</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png"
                      alt="软件架构"
                ></p>
<h2 id="c-软件模块设计与实现"><a href="#c-软件模块设计与实现" class="headerlink" title="(c)软件模块设计与实现"></a>(c)软件模块设计与实现</h2><h3 id="①面板GUI-gui包-："><a href="#①面板GUI-gui包-：" class="headerlink" title="①面板GUI(gui包)："></a>①面板GUI(gui包)：</h3><p>将五个小面板链接进主面板里，播放器的功能按钮链接进MusicPlayerBlock，互相需要调用的也作为对象传入了。</p>
<h4 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MusicPlayerBlock</span> <span class="variable">musicPlayerBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicPlayerBlock</span>(musicSheets);</span><br><span class="line"></span><br><span class="line"><span class="type">MusicSheetDisplayBlock</span> <span class="variable">musicSheetDisplayBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicSheetDisplayBlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">SharedMusicSheetBlock</span> <span class="variable">sharedMusicSheetBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedMusicSheetBlock</span>(musicSheets, musicPlayerBlock, musicSheetDisplayBlock);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalMusicSheetBlock</span> <span class="variable">localMusicSheetBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalMusicSheetBlock</span>(musicSheets, musicPlayerBlock, musicSheetDisplayBlock);</span><br><span class="line"></span><br><span class="line"><span class="type">MusicSheetManagementBlock</span> <span class="variable">musicSheetManagementBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicSheetManagementBlock</span>(localMusicSheetBlock, sharedMusicSheetBlock);</span><br></pre></td></tr></table></figure></div>

<p>遇到的问题：这一块遇到的问题太多了，各个面板之间的互相作用，互相刷新显示，为此改了无数个版本，好在最后算是形成了相对满意的样子，各个面板直接也没有明显bug。关键代码太多在此只写了实例化的代码展现每个面板之间的联系</p>
<h3 id="②网络-httpclient包"><a href="#②网络-httpclient包" class="headerlink" title="②网络(httpclient包)"></a>②网络(httpclient包)</h3><p>详细过程：主要参考老师的代码。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">其中<span class="type">JSONObject</span> <span class="variable">mumObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(jms.get(<span class="string">&quot;musicItems&quot;</span>));</span><br><span class="line">改为了<span class="type">JSONObject</span> <span class="variable">mumObj</span> <span class="operator">=</span> (JSONObject) jms.get(<span class="string">&quot;musicItems&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>解决了musicItems从线上获取为空的情况</p>
<h3 id="③-model包"><a href="#③-model包" class="headerlink" title="③(model包)"></a>③(model包)</h3><p>详细过程：Music类是music的信息的存储，包括时长，作者，歌名等信息及这些信息的获取函数。MusicSheet是歌单信息的存储及歌单信息的获取方法。主要都在NewMP3Playe里调用。</p>
<h4 id="关键代码：-1"><a href="#关键代码：-1" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Music</span><span class="params">(String filePath, String fileName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="type">AudioFile</span> <span class="variable">audioFile</span> <span class="operator">=</span> AudioFileIO.read(file);</span><br><span class="line">        <span class="type">Tag</span> <span class="variable">tag</span> <span class="operator">=</span> audioFile.getTag();</span><br><span class="line">        title = tag.getFirst(FieldKey.TITLE);</span><br><span class="line">        <span class="keyword">if</span> (title == <span class="literal">null</span> || title.isEmpty()) &#123;</span><br><span class="line">            title = fileName.replaceAll(<span class="string">&quot;\\.mp3$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        artist = tag.getFirst(FieldKey.ARTIST);</span><br><span class="line">        <span class="keyword">if</span> (artist == <span class="literal">null</span> || artist.isEmpty()) &#123;</span><br><span class="line">            artist = <span class="string">&quot;未知歌手&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        musicduration = Duration.seconds(audioFile.getAudioHeader().getTrackLength());</span><br><span class="line">        <span class="type">long</span> <span class="variable">minutes</span> <span class="operator">=</span> (<span class="type">long</span>) musicduration.toMinutes();</span><br><span class="line">        <span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> (<span class="type">long</span>) (musicduration.toSeconds() % <span class="number">60</span>);</span><br><span class="line">        duration = String.format(<span class="string">&quot;%02d:%02d&quot;</span>, minutes, seconds);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(fileName);</span><br><span class="line">        System.out.println(<span class="string">&quot;Error occurred while processing file: &quot;</span> + filePath);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 删除文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">fileToDelete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        fileToDelete.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="④-soundmaker包"><a href="#④-soundmaker包" class="headerlink" title="④(soundmaker包)"></a>④(soundmaker包)</h3><p>详细过程：实际上只有NewMP3Player实装。NewMP3Player中用来实现播放器各项按钮的功能。NewMP3Player与MusicPlayerBlock互相联系。在MusicPlayerBlock里建立显示歌单内容的表格，并设置鼠标点击监听器，通过点击获取歌单和音乐的信息。</p>
<p>NewMP3Player里有</p>
<p>playButton（播放）</p>
<p>stopButton（停止）</p>
<p>prevButton（上一首）</p>
<p>nextButton（下一首）</p>
<p>sequenceButton（顺序播放）</p>
<p>randomButton（随机播放）</p>
<p>slider（进度条）</p>
<p>loopButton（循环播放）</p>
<p>为了实现代码复用，增添了stopPlayer和musicSequence的方法。</p>
<p>双击选中歌曲，会启动播放按钮，调用playmusic方法，在playmusic里根据布尔变量来判断是否进行随机播放和单曲循环，否则默认单曲循环。在进度条里通过player.getPosition获取歌曲进度。</p>
<p>遇到的问题：在写暂停的时候遇到了很多的问题，花费了很多的时间，用playThread和contralThread来实现，但是暂停时总是会出现线程冲突的问题。最后放弃了。</p>
<p>由于播放器库没有setPosition之类的按钮，所以没有实现拖动进度条实现控制音乐进度。</p>
<h4 id="关键代码：-2"><a href="#关键代码：-2" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">playThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">while</span> (!isStopped) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!isPaused &amp;&amp; player != <span class="literal">null</span>) &#123;</span><br><span class="line">                          player.play();</span><br><span class="line">                          <span class="keyword">if</span> (isLooping &amp;&amp; player.isComplete()) &#123;</span><br><span class="line">                              <span class="comment">// 当音乐播放完成且isLooping为true时，重新开始播放当前音乐</span></span><br><span class="line">                              <span class="keyword">if</span>(isLooping) &#123;</span><br><span class="line">                                  player.close();</span><br><span class="line">                                  <span class="type">BufferedInputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> </span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">                                  player = <span class="keyword">new</span> <span class="title class_">Player</span>(buffer);</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">else</span> &#123;</span><br><span class="line">                                  sequenceButton.doClick();</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (player != <span class="literal">null</span>) &#123;</span><br><span class="line">                      player.close();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      playThread.start();</span><br></pre></td></tr></table></figure></div>

<p>实现每次播放音乐都创建一个新的音乐线程，不与主线程冲突。</p>
<h2 id="d-软件界面及功能展示"><a href="#d-软件界面及功能展示" class="headerlink" title="(d)软件界面及功能展示"></a>(d)软件界面及功能展示</h2><h3 id="开启后的界面"><a href="#开启后的界面" class="headerlink" title="开启后的界面"></a><strong>开启后的界面</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%BC%80%E5%A7%8B%E7%95%8C%E9%9D%A2.png"
                      alt="开启后的界面"
                ></p>
<h3 id="线上功能展示"><a href="#线上功能展示" class="headerlink" title="线上功能展示"></a><strong>线上功能展示</strong></h3><p>（如果服务器连接失败20秒后会进入本地模式（共享歌单无信息））<strong>：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95.png"
                      alt="加载歌单"
                ></p>
<p>单击共享歌单列表之后右侧歌曲列表面板会刷新，右侧歌单封面，歌单名字，创建者和创建时间都会显示下方会显示歌单加载进度条，歌曲会一首一首显示出来（只要显示就可以双击播放），如果有未下载完成的损坏MP3文件（如上次下载到一半关闭了程序导致）的会自检后删除损坏文件重新下载</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E8%BF%9B%E5%BA%A6%E6%9D%A1.png"
                      alt="加载歌单进度条"
                ></p>
<p>加载进度条会随着歌曲一首首显示实时更新</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E6%8F%90%E7%A4%BA.png"
                      alt="加载歌单提示"
                ></p>
<p>若在歌单加载过程中点击其他歌单或本地歌单添加按钮会弹出提示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E5%AE%8C%E6%88%90.png"
                      alt="加载歌单完成"
                ></p>
<p>歌单加载完成后会提示“双击歌曲开始播放”</p>
<h3 id="线下功能展示"><a href="#线下功能展示" class="headerlink" title="线下功能展示"></a><strong>线下功能展示</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%96%B0%E5%BB%BA%E6%AD%8C%E5%8D%95.png"
                      alt="新建歌单"
                ></p>
<p>为本地歌单提供两个互动按钮</p>
<h4 id="“-”新建歌单"><a href="#“-”新建歌单" class="headerlink" title="“+”新建歌单"></a>“+”新建歌单</h4><p>点击后弹出创建歌单面板，输入歌单名后弹出下一个详细编辑面板</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%96%B0%E5%BB%BA%E6%AD%8C%E5%8D%95.png"
                      alt="新建歌单"
                ></p>
<p>在此弹窗歌单依然可以修改名字，还可以选择歌单封面（若不选择则为默认的播放器logo），添加&#x2F;删除音乐</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E9%80%89%E6%8B%A9%E6%AD%8C%E5%8D%95%E5%B0%81%E9%9D%A2%E3%80%81%E9%9F%B3%E4%B9%90.png"
                      alt="选择歌单封面、音乐"
                ></p>
<p>从电脑文件中选择封面和MP3类型的音乐</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E9%80%89%E6%8B%A9%E6%AD%8C%E5%8D%95%E5%B0%81%E9%9D%A2%E3%80%81%E9%9F%B3%E4%B9%90%E5%AE%8C%E6%88%90.png"
                      alt="选择歌单封面、音乐完成"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%9C%AC%E5%9C%B0%E6%AD%8C%E5%8D%95%E6%B7%BB%E5%8A%A0%E5%AE%8C%E6%88%90.png"
                      alt="本地歌单添加完成"
                ></p>
<p>点击保存后在本地歌单面板显示刚刚创建的面板，点击后效果与线上歌单一致</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/-%E6%8C%89%E9%92%AE.png"
                      alt="-按钮"
                ></p>
<h4 id="“-”编辑歌单"><a href="#“-”编辑歌单" class="headerlink" title="“-”编辑歌单"></a>“-”编辑歌单</h4><p>选中本地歌单中的某歌单后会打开编辑面板，与创建面板功能相似，不过“取消”按钮变味了“删除”，点击删除按钮后歌单从test中删除</p>
<h3 id="播放功能展示"><a href="#播放功能展示" class="headerlink" title="播放功能展示"></a><strong>播放功能展示</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8F%8C%E5%87%BB%E6%92%AD%E6%94%BE.png"
                      alt="双击播放"
                ></p>
<p>双击歌曲开始播放，播放进度条会随着歌曲推进</p>
<p>默认本歌单顺序列表循环播放</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%81%9C%E6%AD%A2%E6%92%AD%E6%94%BE.png"
                      alt="停止播放"
                ></p>
<p>点击停止会终止当前歌曲播放，播放进度条归0，“停止”按钮也会变灰为不可用状态</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%9F%E8%83%BD%E6%92%AD%E6%94%BE.png"
                      alt="功能播放"
                ></p>
<p>“下一首”点击后会直接切换到目前播放状态（顺序or随机）的下一首歌（“上一首”同理），同时播放提示栏也会实时更新显示正在播放的歌曲</p>
<p>“随机播放”参考了主流播放器的逻辑，点击后相当于给每一首歌随机赋一个id，在本次循环中都会保持这个顺序，比如歌曲1在歌曲5之后，播放到歌曲5时如果点击上一首依然是歌曲1</p>
<p>“随机播放”“顺序播放”“单曲循环”可随时切换</p>
<p>每次点击“随机播放”都会得到一个新的播放顺序</p>
<p>每次点击“顺序播放”都会得到原歌单的播放顺序</p>
<p>每次点击“单曲循环”都会让当前单曲循环播放</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>Java</category>
        <category>音乐播放器</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>Java</tag>
        <tag>GUI</tag>
        <tag>音乐播放器</tag>
      </tags>
  </entry>
  <entry>
    <title>经典C++游戏《潜艇大战》改编练习</title>
    <url>/2024/03/12/c/</url>
    <content><![CDATA[<h2 id="原版效果："><a href="#原版效果：" class="headerlink" title="原版效果："></a>原版效果：</h2><h3 id="依靠鼠标点击去炸毁潜艇得分，类似打地鼠："><a href="#依靠鼠标点击去炸毁潜艇得分，类似打地鼠：" class="headerlink" title="依靠鼠标点击去炸毁潜艇得分，类似打地鼠："></a>依靠鼠标点击去炸毁潜艇得分，类似打地鼠：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%BB%8F%E5%85%B8C++%E6%B8%B8%E6%88%8F%E3%80%8A%E6%BD%9C%E8%89%87%E5%A4%A7%E6%88%98%E3%80%8B%E6%94%B9%E7%BC%96%E7%BB%83%E4%B9%A0/ShipDemo_old.gif"
                      alt="ShipDemo_old"
                ></p>
<h2 id="改编效果："><a href="#改编效果：" class="headerlink" title="改编效果："></a>改编效果：</h2><h3 id="靠船左右移动投炸弹炸毁潜艇得分："><a href="#靠船左右移动投炸弹炸毁潜艇得分：" class="headerlink" title="靠船左右移动投炸弹炸毁潜艇得分："></a>靠船左右移动投炸弹炸毁潜艇得分：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%BB%8F%E5%85%B8C++%E6%B8%B8%E6%88%8F%E3%80%8A%E6%BD%9C%E8%89%87%E5%A4%A7%E6%88%98%E3%80%8B%E6%94%B9%E7%BC%96%E7%BB%83%E4%B9%A0/ShipDemo_new.gif"
                      alt="ShipDemo_new"
                ></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本报告详细分析了《潜艇大战》游戏从原版到改编版本中的关键代码变化。原版游戏的核心玩法是使用鼠标点击来炸毁潜艇并得分，类似于“打地鼠”的游戏模式。改编版本则通过控制船的左右移动并投掷炸弹来炸毁潜艇以得分。</p>
<h2 id="1-核心视图类-CChildView-类分析"><a href="#1-核心视图类-CChildView-类分析" class="headerlink" title="1. 核心视图类 (CChildView) 类分析"></a>1. 核心视图类 (<code>CChildView</code>) 类分析</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>CChildView</code> 类是《潜艇大战》游戏的核心视图类，负责管理游戏对象、处理用户输入、绘制游戏界面等。</p>
<h3 id="OnTimer-方法分析"><a href="#OnTimer-方法分析" class="headerlink" title="OnTimer 方法分析"></a><code>OnTimer</code> 方法分析</h3><h4 id="创建和管理潜艇"><a href="#创建和管理潜艇" class="headerlink" title="创建和管理潜艇"></a>创建和管理潜艇</h4><p><strong>潜艇创建逻辑</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nCreator==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_Objects.<span class="built_in">AddTail</span>(<span class="keyword">new</span> <span class="built_in">CSubmarine</span>(<span class="built_in">random</span>(<span class="number">2</span>)%<span class="number">2</span>?<span class="literal">true</span>:<span class="literal">false</span>, <span class="built_in">random</span>(GAME_HEIGHT-SHIP_VERT_POS-SHIP_HEIGHT*<span class="number">2</span><span class="number">-30</span>)+SHIP_VERT_POS+SHIP_HEIGHT+<span class="number">30</span>, <span class="built_in">random</span>(<span class="number">4</span>), <span class="built_in">random</span>(<span class="number">4</span>)+<span class="number">3</span>));</span><br><span class="line">    nCreator = <span class="built_in">random</span>(<span class="number">50</span>) + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>nCreator</code> 用于控制潜艇生成的时间间隔。当它变为 0，代码会创建一个新的 <code>CSubmarine</code> 对象并将其添加到游戏对象列表 <code>m_Objects</code>。</li>
<li>每个潜艇的位置、类型和速度都是随机生成的，提供了游戏的可变性和挑战性。</li>
</ul>
<p><strong>潜艇管理逻辑</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">POSITION pos1, pos2;</span><br><span class="line"><span class="keyword">for</span>(pos1=m_Objects.<span class="built_in">GetHeadPosition</span>(); (pos2=pos1)!=<span class="literal">NULL</span>;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(((CMyObject*)m_Objects.<span class="built_in">GetNext</span>(pos1))-&gt;<span class="built_in">Draw</span>(&amp;m_VirtualDC, m_bGamePause))</span><br><span class="line">    &#123;</span><br><span class="line">        pLastObj = m_Objects.<span class="built_in">GetAt</span>(pos2);</span><br><span class="line">        m_Objects.<span class="built_in">RemoveAt</span>(pos2);</span><br><span class="line">        <span class="keyword">delete</span> pLastObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这段代码遍历 <code>m_Objects</code> 中的所有游戏对象，并对它们调用 <code>Draw</code> 方法。</li>
<li>如果 <code>Draw</code> 方法返回 <code>true</code>，表明对象（如潜艇）需要被移除。这通常在对象（如潜艇被击中或移动出屏幕）结束其生命周期时发生。</li>
</ul>
<h4 id="游戏画面渲染"><a href="#游戏画面渲染" class="headerlink" title="游戏画面渲染"></a>游戏画面渲染</h4><p><strong>背景绘制</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m_VirtualDC.<span class="built_in">FillSolidRect</span>(<span class="number">0</span>, <span class="number">0</span>, GAME_WIDTH, SHIP_VERT_POS+SHIP_HEIGHT<span class="number">-5</span>, SKY_COLOR);</span><br><span class="line">m_VirtualDC.<span class="built_in">FillSolidRect</span>(<span class="number">0</span>, SHIP_VERT_POS+SHIP_HEIGHT<span class="number">-5</span>, GAME_WIDTH, GAME_HEIGHT, SEA_COLOR);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这里使用 <code>FillSolidRect</code> 在虚拟设备上下文 <code>m_VirtualDC</code> 上绘制天空和海洋背景。</li>
<li><code>SKY_COLOR</code> 和 <code>SEA_COLOR</code> 定义了天空和海洋的颜色。</li>
</ul>
<p><strong>最终渲染到屏幕</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">dc.<span class="built_in">BitBlt</span>(<span class="number">0</span>, <span class="number">0</span>, GAME_WIDTH, GAME_HEIGHT, &amp;m_VirtualDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用 <code>BitBlt</code> 方法将虚拟设备上下文的内容传输到实际的屏幕上下文。</li>
<li>这种方法可以避免闪烁并提高绘图效率。</li>
</ul>
<h4 id="其他重要逻辑"><a href="#其他重要逻辑" class="headerlink" title="其他重要逻辑"></a>其他重要逻辑</h4><p><strong>游戏暂停功能</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m_bGamePause) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>控制游戏暂停。当 <code>m_bGamePause</code> 为 <code>true</code> 时，<code>OnTimer</code> 将提前返回，不执行任何游戏更新逻辑。</li>
</ul>
<p><strong>潜艇生成计数器更新</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">nCreator--;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>nCreator</code> 每次 <code>OnTimer</code> 被调用时递减，控制潜艇的生成频率。</li>
</ul>
<p>总结来说，<code>OnTimer</code> 方法是游戏的心脏，负责潜艇的生成和管理、游戏画面的更新和渲染，以及控制游戏的暂停和继续。这个方法充分展示了游戏循环的典型结构，包括对象管理、状态更新和画面渲染。</p>
<h2 id="2-潜艇类-CSubmarine-的变更"><a href="#2-潜艇类-CSubmarine-的变更" class="headerlink" title="2. 潜艇类 (CSubmarine) 的变更"></a>2. 潜艇类 (<code>CSubmarine</code>) 的变更</h2><h3 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h3><p>在原版中，<code>CSubmarine</code> 类主要负责潜艇的初始化、移动、绘图和销毁。这个类使用了 <code>CImageList</code> 来处理潜艇的图像。潜艇的移动是基于它们的方向 (<code>m_bDirect</code>) 和速度 (<code>m_nSpeed</code>)。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CSubmarine::<span class="built_in">CSubmarine</span>(<span class="type">bool</span> bDir, <span class="type">int</span> nVert, <span class="type">int</span> nType, <span class="type">int</span> nSpeed)</span><br><span class="line">&#123;</span><br><span class="line">    m_bDirect = bDir;</span><br><span class="line">    m_ptPos.x = m_bDirect ? GAME_WIDTH : -SUBMARINE_WIDTH;</span><br><span class="line">    m_ptPos.y = nVert;</span><br><span class="line">    <span class="comment">// ...[其他初始化代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="改编版本"><a href="#改编版本" class="headerlink" title="改编版本"></a>改编版本</h3><p>在改版中，<code>CSubmarine</code> 类增加了 <code>GetRect()</code> 方法，用于获取潜艇的碰撞箱。这是为了适应游戏中的新机制，如导弹与潜艇的碰撞检测。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CRect <span class="title">CSubmarine::GetRect</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...[定义矩形尺寸]...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CRect</span>(m_ptPos.x, m_ptPos.y, m_ptPos.x + SubmarineWidth, m_ptPos.y + SubmarineHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3-新增导弹类-CMissile"><a href="#3-新增导弹类-CMissile" class="headerlink" title="3. 新增导弹类 (CMissile)"></a>3. 新增导弹类 (<code>CMissile</code>)</h2><p>在改编版本中，新增了导弹类 <code>CMissile</code>。这一变化扩展了游戏的交互性和复杂度。</p>
<h3 id="原版-1"><a href="#原版-1" class="headerlink" title="原版"></a>原版</h3><p>原版游戏中没有导弹类的概念。</p>
<h3 id="改编版本-1"><a href="#改编版本-1" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本中添加了 <code>CMissile</code> 类，并在主游戏循环中处理导弹的移动和碰撞检测。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*pObj) == <span class="built_in">typeid</span>(CMissile))</span><br><span class="line">&#123;</span><br><span class="line">    CMissile* pMissile = (CMissile*)pObj;</span><br><span class="line">    pMissile-&gt;<span class="built_in">Move</span>(); <span class="comment">// 移动导弹</span></span><br><span class="line">    <span class="comment">// ... [碰撞检测和处理代码] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><strong>构造函数</strong>：初始化导弹的位置和生命周期。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CMissile::<span class="built_in">CMissile</span>(CPoint ptPos) : <span class="built_in">CMyObject</span>(ptPos)</span><br><span class="line">&#123;</span><br><span class="line">    m_nLifetime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...[初始化代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Move</code> 方法</strong>：控制导弹的移动。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMissile::Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ptPos.y += <span class="number">20</span>;  <span class="comment">// ...[移动逻辑]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>GetRect</code> 方法</strong>：为碰撞检测提供导弹的矩形区域。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CRect <span class="title">CMissile::GetRect</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...[定义矩形尺寸]...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CRect</span>(m_ptPos.x, m_ptPos.y, m_ptPos.x + MissileWidth, m_ptPos.y + MissileHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>导弹图像处理</strong>：使用 GDI+ 从资源加载 PNG 图片并创建图像列表。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMissile::LoadImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...[加载和处理 PNG 图片的代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="4-控制机制的改变"><a href="#4-控制机制的改变" class="headerlink" title="4. 控制机制的改变"></a>4. 控制机制的改变</h2><h3 id="原版-2"><a href="#原版-2" class="headerlink" title="原版"></a>原版</h3><p>原版游戏中，玩家通过鼠标点击潜艇位置来摧毁它们。这是通过 <code>OnLButtonDown</code> 函数实现的：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CChildView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">    <span class="keyword">if</span>(pSub-&gt;<span class="built_in">GetRect</span>().<span class="built_in">PtInRect</span>(point))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建爆炸和计分</span></span><br><span class="line">        <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">        <span class="keyword">delete</span> pSub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="改编版本-2"><a href="#改编版本-2" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本引入了键盘控制。通过 <code>OnKeyDown</code> 函数，玩家可以通过左右键移动船，并用空格键发射导弹。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CChildView::OnKeyDown</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nChar == VK_SPACE || nChar == VK_RETURN) <span class="comment">// 发射导弹</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">        <span class="keyword">if</span> (!missileExists)</span><br><span class="line">        &#123;</span><br><span class="line">            CMissile* pMissile = <span class="keyword">new</span> <span class="built_in">CMissile</span>(<span class="built_in">CPoint</span>(shipPos.x, SHIP_VERT_POS));</span><br><span class="line">            m_Objects.<span class="built_in">AddTail</span>(pMissile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="5-分数统计的变更"><a href="#5-分数统计的变更" class="headerlink" title="5. 分数统计的变更"></a>5. 分数统计的变更</h2><p>为了适应新的游戏玩法，分数统计方式也做了调整。</p>
<h3 id="原版-3"><a href="#原版-3" class="headerlink" title="原版"></a>原版</h3><p>原版游戏仅在鼠标点击潜艇时计分。</p>
<h3 id="改编版本-3"><a href="#改编版本-3" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本中，分数统计不仅包括击毁潜艇的分数，还统计了击毁的潜艇数量。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m_nTotalScore += pScore-&gt;<span class="built_in">GetScoreValue</span>(); <span class="comment">// 累加分数</span></span><br><span class="line">++m_nDestroyedSubmarines;  <span class="comment">// 增加被击毁的潜艇数量</span></span><br></pre></td></tr></table></figure></div>



<h2 id="6-界面信息显示的改进"><a href="#6-界面信息显示的改进" class="headerlink" title="6. 界面信息显示的改进"></a>6. 界面信息显示的改进</h2><p>改编版本在界面上添加了更多的信息显示，如总潜艇数、击毁潜艇数等，增强了游戏的可玩性和信息反馈。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CString destroyedString;</span><br><span class="line">destroyedString.<span class="built_in">Format</span>(<span class="string">&quot;击毁潜艇数: %d&quot;</span>, m_nDestroyedSubmarines);</span><br><span class="line">m_VirtualDC.<span class="built_in">TextOut</span>(<span class="number">130</span>, <span class="number">10</span>, destroyedString); <span class="comment">// 显示击毁潜艇数</span></span><br><span class="line"></span><br><span class="line">CString scoreString;</span><br><span class="line">scoreString.<span class="built_in">Format</span>(<span class="string">&quot;总分: %d&quot;</span>, m_nTotalScore);</span><br><span class="line">m_VirtualDC.<span class="built_in">TextOut</span>(GAME_WIDTH - <span class="number">100</span>, <span class="number">10</span>, scoreString); <span class="comment">// 显示总分</span></span><br></pre></td></tr></table></figure></div>



<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>参与《潜艇大战》游戏的改编过程，我在游戏开发方面获得了实质性的技能提升。通过这个项目，我学到了以下几个关键的技术点：</p>
<ol>
<li><strong>交互控制的实现</strong>：通过替换原有的鼠标点击控制为键盘控制，我学会了如何处理和响应键盘事件。这提高了我的能力，使我能够在未来的项目中灵活地设计和实现用户交互。</li>
<li><strong>游戏逻辑的编写</strong>：在实现导弹发射和移动的逻辑时，我加深了对游戏循环和对象状态管理的理解。这对于理解如何构建游戏的动态元素和保持其连贯性非常有帮助。</li>
<li><strong>碰撞检测的处理</strong>：实现导弹和潜艇之间的碰撞检测增强了我在游戏物理和交互方面的技术知识，这在很多游戏开发项目中都是一个核心技能。</li>
<li><strong>图形和用户界面的更新</strong>：改进游戏的界面显示，例如增加得分和击毁潜艇数的显示，让我更加熟悉了图形界面的编程和数据可视化。</li>
</ol>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>作品集</tag>
        <tag>《潜艇大战》</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework 1: Getting Started</title>
    <url>/2024/03/17/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-1-Getting-Started/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw1.pdf" width="100%" height="600" type="application/pdf">


<h2 id="Write-up-2-分析-Pointer-c-文件"><a href="#Write-up-2-分析-Pointer-c-文件" class="headerlink" title="Write-up 2: 分析 Pointer.c 文件"></a>Write-up 2: 分析 Pointer.c 文件</h2><p>在 Pointer.c 的练习中，我首先尝试编译代码，发现了几个编译错误。通过仔细审查代码，我注意到这些错误主要是由于对指针和常量的错误操作。例如，尝试修改一个指向常量的指针的内容（<em>pcc &#x3D; 7;）是非法的，因为这破坏了常量的不变性。此外，赋值 char</em> const cp &#x3D; c; 创建了一个常量指针，意味着不能改变 cp 指向的地址，但是 cp 可以修改其指向的内容。这种区别对理解 C 语言中指针和常量的行为至关重要。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw1245.png"
                      alt="21020007074-普典衡-hw1245"
                ></p>
<p>代码中注释问题的解答：</p>
<ol>
<li><p>int main(int argc, char* argv[]) { &#x2F;&#x2F; What is the type of argv?<br>argv 是一个指向字符指针的指针，即 char 类型。它通常用于存储程序运行时传递的命令行参数。</p>
</li>
<li><p>char* pc &#x3D; c; &#x2F;&#x2F; Valid assignment: c acts like a pointer to c[0] here.<br>这是一个有效的赋值。在 C 语言中，数组名称作为指针使用时，指向数组的第一个元素。因此，c 实际上指向 c[0] 的地址。</p>
</li>
<li><p>printf(“char d &#x3D; %c\n”, d); &#x2F;&#x2F; What does this print?<br>这将打印出 d 的值，即字符数组 c 的第一个字符。根据 c 的定义，这应该是 6。</p>
</li>
<li><p><em>pcc &#x3D; 7; &#x2F;&#x2F; invalid?<br>这是无效的。pcc 被声明为指向常量字符的指针（const char</em>），这意味着你不能通过 pcc 修改它指向的值。</p>
</li>
<li><p>pcc &#x3D; <em>pcp; &#x2F;&#x2F; valid?<br>这是有效的。pcc 是一个指向字符的指针，pcp 是一个指向 argv 数组第一个元素（即指向 char 的指针）的指针。因此，</em>pcp 是 char* 类型，可以赋值给 pcc。</p>
</li>
<li><p>pcc &#x3D; argv[0]; &#x2F;&#x2F; valid?<br>这也是有效的。argv[0] 是 char* 类型，它指向传递给程序的第一个命令行参数。</p>
</li>
<li><p>cp &#x3D; <em>pcp; &#x2F;&#x2F; invalid?<br>这是无效的。cp 被声明为 const 指针（char</em> const），意味着一旦它被初始化指向一个地址，你就不能更改它指向的地址。</p>
</li>
<li><p>cp &#x3D; *argv; &#x2F;&#x2F; invalid?<br>同上，这也是无效的，因为 cp 是一个常量指针。</p>
</li>
<li><p>*cp &#x3D; !; &#x2F;&#x2F; valid?<br>这是有效的。尽管 cp 是一个常量指针，它仍然可以修改其指向的内容，只是不能改变指向的地址。</p>
</li>
<li><p>cpc &#x3D; <em>pcp; &#x2F;&#x2F; invalid? 和 cpc &#x3D; argv[0]; &#x2F;&#x2F; invalid?<br>这两个都是无效的。cpc 被声明为指向常量字符的常量指针（const char</em> const），意味着既不能更改指向的地址，也不能通过它修改指向的内容。</p>
</li>
<li><p>*cpc &#x3D; @; &#x2F;&#x2F; invalid?<br>这是无效的。由于 cpc 指向一个常量字符，所以不能通过它来修改所指向的值。</p>
</li>
</ol>
<h2 id="Write-up-3-分析各种类型及其指针的大小"><a href="#Write-up-3-分析各种类型及其指针的大小" class="headerlink" title="Write-up 3: 分析各种类型及其指针的大小"></a>Write-up 3: 分析各种类型及其指针的大小</h2><p>在我完成的 sizes.c 练习中，我成功编译并运行了程序，它输出了各种数据类型及其指针的大小。以下是主要发现：</p>
<ol>
<li><p>基本类型及其指针的大小：<br>int 类型大小为 4 字节，其指针大小为 8 字节。<br>short 类型为 2 字节，指针为 8 字节。<br>long 类型为 8 字节，指针同样为 8 字节。<br>类似地，char, float, double, unsigned int, long long 的大小分别为 1, 4, 8, 4, 8 字节，它们的指针大小均为 8 字节。</p>
</li>
<li><p>特定类型及其指针的大小：<br>对于 uint8_t, uint16_t, uint32_t, uint64_t 等类型，大小分别为 1, 2, 4, 8 字节，指针大小均为 8 字节。<br>uint_fast8_t, uint_fast16_t, uintmax_t, intmax_t 类型的大小为 1, 8, 8, 8 字节，指针大小也为 8 字节。<br>对于 Clang 特有的 __int128 类型，大小为 16 字节，指针大小为 8 字节。</p>
</li>
<li><p>复合类型及其指针的大小：<br>自定义的 student 结构体大小为 8 字节，其指针大小为 8 字节。</p>
</li>
<li><p>数组及其指针的大小：<br>对于声明的 int x[5] 数组，大小为 20 字节（因为它包含 5 个 int 类型元素），而指向该数组的指针大小为 8 字节。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12124.png"
                      alt="21020007074-普典衡-hw12124"
                ></p>
<p>这些结果反映了在我的系统（一个 64 位系统）上，大多数指针类型的大小均为 8 字节，这是因为在 64 位系统上指针通常占用 8 字节的内存空间。这些信息对于理解不同数据类型在内存中如何分配和使用非常重要，尤其是在进行性能优化和内存管理时。</p>
<h2 id="Write-up-4-修改-Swap-c-函数"><a href="#Write-up-4-修改-Swap-c-函数" class="headerlink" title="Write-up 4: 修改 Swap.c 函数"></a>Write-up 4: 修改 Swap.c 函数</h2><p>在原始的程序中，swap 函数的问题在于它试图交换两个整数，但是由于 C 中的参数是按值传递的，所以 swap 函数实际上是在操作传入值的副本，而不是原始变量本身。因此，当 swap 函数执行完毕后，原始变量 k 和 m 的值并未发生改变。</p>
<p>为了修正这个问题，需要修改 swap 函数，让它接受指向整数的指针，这样就可以直接修改传入变量的值。下面是修改后的 swap.c 程序：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12342.png"
                      alt="21020007074-普典衡-hw12342"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12343.png"
                      alt="21020007074-普典衡-hw12343"
                ></p>
<p>在这个版本中，swap 函数现在接受两个指向整数的指针。函数内部，通过解引用这些指针（使用 *i 和 *j）来访问和修改它们指向的实际值。在 main 函数中，通过传递 k 和 m 的地址（使用 &amp;k 和 &amp;m）来调用 swap 函数。</p>
<p>现在，当 swap 函数被调用时，它将修改 k 和 m 所指向的实际内存位置的值，从而实现了真正的交换。因此，当程序执行完毕后，打印的 k 和 m 的值将反映出它们被交换了。</p>
<h2 id="Write-up-5-修改-Makefile"><a href="#Write-up-5-修改-Makefile" class="headerlink" title="Write-up 5: 修改 Makefile"></a>Write-up 5: 修改 Makefile</h2><p>在这个练习中，我修改了 Makefile，将编译优化级别从 -O1 改为 -O3。这导致了更高级别的代码优化。当我运行 make clean; make 时：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12658.png"
                      alt="21020007074-普典衡-hw12658"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12659.png"
                      alt="21020007074-普典衡-hw12659"
                ></p>
<p>更改优化级别从 -O1 到 -O3 的确可以影响程序的性能和行为，尽管这种影响可能不是立即显而易见的。在 -O3 优化级别下，编译器执行更多的代码优化，这可能包括循环展开、内联函数等。这些优化可以提高程序的运行速度，但有时也可能导致意外的副作用，尤其是在复杂的程序中。</p>
<h2 id="Write-up-6-AddressSanitizer-的输出"><a href="#Write-up-6-AddressSanitizer-的输出" class="headerlink" title="Write-up 6: AddressSanitizer 的输出"></a>Write-up 6: AddressSanitizer 的输出</h2><p>使用 AddressSanitizer 后，我注意到程序报告了一些内存错误。这些错误包括未初始化的变量使用和潜在的内存泄漏。AddressSanitizer 的输出帮助我快速定位和修复这些问题，这对于保持代码的健壮性至关重要。<br>输出，它报告了一个 heap-buffer-overflow 错误。这表明程序试图访问分配的堆内存区域之外的内存，这是一种常见的内存错误。错误发生在 matrix_multiply_run 函数内，特别是在执行 C-&gt;values[i][j] +&#x3D; A-&gt;values[i][k] * B-&gt;values[k][j]; 这行代码时。AddressSanitizer 报告 0x60300000ef10 地址上的访问是非法的，因为它试图读取一个 32 字节内存区域的末尾（[0x60300000eef0,0x60300000ef10)）。<br>此外，错误还提示 heap-buffer-overflow 发生在分配的堆内存区域的右侧边界，这可能表明数组访问中的“越界”问题。可能需要重新审视数组分配和索引的逻辑，确保没有越界访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13308.png"
                      alt="21020007074-普典衡-hw13308"
                ></p>
<h2 id="Write-up-7-修复-Matrix-Multiply-后的输出"><a href="#Write-up-7-修复-Matrix-Multiply-后的输出" class="headerlink" title="Write-up 7: 修复 Matrix Multiply 后的输出"></a>Write-up 7: 修复 Matrix Multiply 后的输出</h2><p>基于 Valgrind 的输出和提供的代码，我注意到可能的问题是在 matrix_multiply_run 函数中，每个元素 C-&gt;values[i][j] 在累加之前没有被初始化为零。这可能导致未定义行为，因为在默认情况下，动态分配的内存不会被自动初始化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13476.png"
                      alt="21020007074-普典衡-hw13476"
                ></p>
<p>为了修复这个问题，在开始累加之前将 C 矩阵的每个元素初始化为零。这可以通过在 make_matrix 函数中添加代码来实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13542.png"
                      alt="21020007074-普典衡-hw13542"
                ></p>
<p>后来发现testbed.c中初始化的是A（4x5）与B（4x4）相乘不符合矩阵乘法规律，将A改为4x4：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13597.png"
                      alt="21020007074-普典衡-hw13597"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13599.png"
                      alt="21020007074-普典衡-hw13599"
                ></p>
<p>在修复 matrix_multiply.c 之后，我再次运行程序，并注意到程序现在能够成功执行并打印出正确的结果。</p>
<h2 id="Write-up-8-Valgrind-的输出"><a href="#Write-up-8-Valgrind-的输出" class="headerlink" title="Write-up 8: Valgrind 的输出"></a>Write-up 8: Valgrind 的输出</h2><p>根据 Valgrind 的输出，程序中存在内存泄漏，主要来源于未正确释放分配给矩阵 A、B 和 C 的内存。为了解决这个问题，要在 main 函数的末尾调用 free_matrix 函数来释放这些矩阵的内存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13791.png"
                      alt="21020007074-普典衡-hw13791"
                ></p>
<p>在计算完成并打印结果后，添加以下代码来释放矩阵内存：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13820.png"
                      alt="21020007074-普典衡-hw13820"
                ></p>
<p>正常运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13828.png"
                      alt="21020007074-普典衡-hw13828"
                ></p>
<h2 id="Write-up-9-性能优化前后的执行时间"><a href="#Write-up-9-性能优化前后的执行时间" class="headerlink" title="Write-up 9: 性能优化前后的执行时间"></a>Write-up 9: 性能优化前后的执行时间</h2><p>为了评估性能优化的效果，我首先记录了原始程序的执行时间。然后，我调整了矩阵乘法的循环顺序，以提高内存访问的效率。优化后，我注意到程序的执行时间显著减少，这表明优化是成功的。<br>交换了 j 和 k 循环的顺序，这样可以在遍历 B 矩阵时实现更好的顺序访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13983.png"
                      alt="21020007074-普典衡-hw13983"
                ></p>
<p>从2.51秒左右优化到0.68秒左右</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14005.png"
                      alt="21020007074-普典衡-hw14005"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14008.png"
                      alt="21020007074-普典衡-hw14008"
                ></p>
<h2 id="Write-up-10-编译优化的影响"><a href="#Write-up-10-编译优化的影响" class="headerlink" title="Write-up 10: 编译优化的影响"></a>Write-up 10: 编译优化的影响</h2><p>最后，我比较了在不同编译优化级别下程序的执行时间。在 -O0（无优化）下编译时，程序运行较慢。然而，在使用 -O3（高级优化）编译后，程序的执行速度明显提升。这强调了编译器优化在软件性能工程中的重要性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14135.png"
                      alt="21020007074-普典衡-hw14135"
                ></p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>《让蛋仔飞》技术报告</title>
    <url>/2024/01/08/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h2><ul>
<li><p>项目名称：《让蛋仔飞》</p>
</li>
<li><p>开发者：普典衡</p>
</li>
<li><p>分工：</p>
<p>普典衡：</p>
<p>策划-玩法，数值</p>
<p>程序-前端，后端</p>
<p>美术-UI，动画</p>
</li>
</ul>
<h2 id="2-游戏内容介绍"><a href="#2-游戏内容介绍" class="headerlink" title="2. 游戏内容介绍"></a>2. 游戏内容介绍</h2><ul>
<li>游戏背景：一个简单而有趣的游戏环境，主要集中于轻松、快节奏的体验。</li>
<li>角色道具：玩家扮演的是不同种类的卡通蛋角色，如荷包蛋、倒霉蛋等。卡通风格的刀和叉作为障碍物。</li>
<li>场景：使用明亮、鲜艳的色调和简单的卡通风格，界面清晰展示游戏选项。</li>
<li>主要情节：游戏集中于提供快节奏、直观易懂的体验，没有复杂的情节或故事线。</li>
<li>玩法：操作主角蛋躲避障碍物，通过点击或触摸屏幕控制跳跃。</li>
<li>功能（系统）：包括游戏控制系统、皮肤系统、排行榜系统等。</li>
</ul>
<h2 id="3-主要特点"><a href="#3-主要特点" class="headerlink" title="3. 主要特点"></a>3. 主要特点</h2><ul>
<li>整体风格：简洁而有趣，易于上手。</li>
<li>娱乐性与挑战性：结合逐渐增加的难度提供持续挑战。</li>
<li>社交性：通过排行榜系统增加游戏的社交动力。</li>
<li>个性化体验：通过皮肤系统允许玩家自定义角色外观。</li>
</ul>
<h2 id="4-算法说明"><a href="#4-算法说明" class="headerlink" title="4. 算法说明"></a>4. 算法说明</h2><p>   Unity（C#）代码部分：</p>
<h3 id="游戏控制和角色行为"><a href="#游戏控制和角色行为" class="headerlink" title="游戏控制和角色行为"></a>游戏控制和角色行为</h3><h4 id="EggyController-类："><a href="#EggyController-类：" class="headerlink" title="EggyController 类："></a><code>EggyController</code> 类：</h4><p>   负责处理蛋角色的基本行为，包括跳跃、得分、游戏开始&#x2F;结束逻辑、无敌状态、碰撞处理以及游戏速度的调整。</p>
<h5 id="游戏开始-结束逻辑"><a href="#游戏开始-结束逻辑" class="headerlink" title="游戏开始&#x2F;结束逻辑"></a>游戏开始&#x2F;结束逻辑</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isControl &amp;&amp; !IsPointerOverUIObject()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>) &amp;&amp; !gameStarted) &#123;</span><br><span class="line">            StartGame();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gameStarted) &#123;</span><br><span class="line">            Jump();</span><br><span class="line">        &#125;</span><br><span class="line">        CheckPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartGame</span>()</span> &#123;</span><br><span class="line">    gameStarted = <span class="literal">true</span>;</span><br><span class="line">    Time.timeScale = <span class="number">1</span>; <span class="comment">// 恢复时间流逝</span></span><br><span class="line">    <span class="comment">// 其他游戏开始逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckPosition</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查蛋的位置，确定游戏是否结束</span></span><br><span class="line">    <span class="comment">// 如果蛋落出屏幕，则结束游戏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   此部分代码控制游戏的开始和结束。当玩家点击屏幕时，游戏开始，而当游戏角色掉出屏幕时，游戏结束。</p>
<h5 id="跳跃逻辑"><a href="#跳跃逻辑" class="headerlink" title="跳跃逻辑"></a>跳跃逻辑</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>)) &#123;</span><br><span class="line">        rb.velocity = Vector2.up * jumpForce;</span><br><span class="line">        StartCoroutine(BounceEffect());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">BounceEffect</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 实现蛋的跳跃动画效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   这段代码负责处理玩家角色的跳跃动作。玩家点击屏幕时，角色会向上跳跃。</p>
<h5 id="得分逻辑"><a href="#得分逻辑" class="headerlink" title="得分逻辑"></a>得分逻辑</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGameOver &amp;&amp; other.gameObject.tag == <span class="string">&quot;ScoreZone&quot;</span>) &#123;</span><br><span class="line">        score++;</span><br><span class="line">        UpdateScoreText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateScoreText</span>()</span> &#123;</span><br><span class="line">    scoreText.text = score.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   当角色通过特定区域时，玩家得分。这通过检测角色是否触碰到标记为 “ScoreZone” 的触发器来实现。</p>
<h5 id="无敌状态"><a href="#无敌状态" class="headerlink" title="无敌状态"></a>无敌状态</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InvincibilityTime</span>()</span> &#123;</span><br><span class="line">    isInvincible = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 实现无敌状态效果，如闪烁等</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>; <span class="comment">// 无敌时间</span></span><br><span class="line">    isInvincible = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   在某些情况下，角色会进入无敌状态，这段时间内不会被障碍物伤害。</p>
<h5 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (collision.gameObject.tag == <span class="string">&quot;KF&quot;</span> &amp;&amp; !isGameOver &amp;&amp; !isInvincible) &#123;</span><br><span class="line">        iscollide = <span class="literal">true</span>;</span><br><span class="line">        StartCoroutine(HandleGameOver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   当角色与标记为 “KF” 的障碍物发生碰撞时，游戏结束逻辑被触发。</p>
<h5 id="游戏速度调整"><a href="#游戏速度调整" class="headerlink" title="游戏速度调整"></a>游戏速度调整</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateGameSpeed</span>()</span> &#123;</span><br><span class="line">    Time.timeScale = Mathf.Min(<span class="number">1</span> + score * speedupspeed, maxTimeScale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   随着玩家得分的提高，游戏的时间流逝速度加快，从而增加游戏难度。</p>
<h4 id="Background-类："><a href="#Background-类：" class="headerlink" title="Background 类："></a><code>Background</code> 类：</h4><p>   管理游戏背景的移动，以创建滚动效果，增加游戏的动态感。</p>
<h5 id="初始化背景属性"><a href="#初始化背景属性" class="headerlink" title="初始化背景属性"></a>初始化背景属性</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    backgroundWidth = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在游戏开始时，计算背景图像的宽度，以便于后续确定何时克隆新的背景。</p>
<h5 id="背景移动逻辑"><a href="#背景移动逻辑" class="headerlink" title="背景移动逻辑"></a>背景移动逻辑</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EggyController.isGameOver) &#123;</span><br><span class="line">        transform.Translate(-speed * Time.deltaTime, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在每一帧中，如果游戏未结束，背景将以设定的速度向左移动，创建出持续滚动的效果。</p>
<h5 id="背景克隆和销毁"><a href="#背景克隆和销毁" class="headerlink" title="背景克隆和销毁"></a>背景克隆和销毁</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (transform.position.x &lt; <span class="number">0</span> &amp;&amp; !hasCloned) &#123;</span><br><span class="line">    CloneBackground();</span><br><span class="line">    hasCloned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (transform.position.x &lt; <span class="number">-18</span>) &#123;</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   当背景移动到屏幕中央时，克隆一个新的背景对象，以实现无缝连接的滚动效果。一旦背景移出屏幕一定范围，它将被销毁，以节省资源。</p>
<h5 id="克隆背景方法"><a href="#克隆背景方法" class="headerlink" title="克隆背景方法"></a>克隆背景方法</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloneBackground</span>()</span> &#123;</span><br><span class="line">    Instantiate(gameObject, <span class="keyword">new</span> Vector3(transform.position.x + backgroundWidth, transform.position.y, transform.position.z), Quaternion.identity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这个方法在原有背景的基础上创建一个新的背景实例，放置在当前背景的右侧，确保两个背景图像在水平方向上连续。</p>
<h3 id="游戏界面和用户交互"><a href="#游戏界面和用户交互" class="headerlink" title="游戏界面和用户交互"></a>游戏界面和用户交互</h3><h4 id="MenuManager-类："><a href="#MenuManager-类：" class="headerlink" title="MenuManager 类："></a><code>MenuManager</code> 类：</h4><p>   管理游戏菜单的显示和皮肤选择，提供玩家选择不同皮肤的功能。</p>
<h5 id="初始化和皮肤状态管理"><a href="#初始化和皮肤状态管理" class="headerlink" title="初始化和皮肤状态管理"></a>初始化和皮肤状态管理</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 确保主页UI初始时是显示的</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>);</span><br><span class="line">    homePageUI.SetActive(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取并显示累计总得分</span></span><br><span class="line">    <span class="built_in">int</span> totalScore = PlayerPrefs.GetInt(<span class="string">&quot;TotalScore&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取并显示死亡次数</span></span><br><span class="line">    <span class="built_in">int</span> deathCount = PlayerPrefs.GetInt(<span class="string">&quot;DeathCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取并显示复活总数</span></span><br><span class="line">    <span class="built_in">int</span> resurrectionCount = PlayerPrefs.GetInt(<span class="string">&quot;ResurrectionCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在对应的Text组件中显示这些值</span></span><br><span class="line">    <span class="comment">// 这里假设你有三个Text组件分别用于显示总得分、死亡次数和复活总数</span></span><br><span class="line">    <span class="comment">// 如果你的Text组件命名不同，需要根据实际情况修改下面的代码</span></span><br><span class="line">    totalScoreText.text = <span class="string">&quot;总得分: &quot;</span> + totalScore.ToString();</span><br><span class="line">    deathCountText.text = <span class="string">&quot;失败数: &quot;</span> + deathCount.ToString();</span><br><span class="line">    resurrectionCountText.text = <span class="string">&quot;复活数: &quot;</span> + resurrectionCount.ToString();</span><br><span class="line"></span><br><span class="line">    Time.timeScale = <span class="number">1</span>;</span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>); <span class="comment">// 先激活</span></span><br><span class="line">    ApplySkinToEggy(skinManager.skins[PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>)].name); <span class="comment">// 应用皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>); <span class="comment">// 再隐藏，如果需要的话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化皮肤列表</span></span><br><span class="line">    InitializeSkinsUnlockState();</span><br><span class="line">    LoadCurrentSkin();</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line"></span><br><span class="line">    unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitializeSkinsUnlockState</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认皮肤已解锁</span></span><br><span class="line">    PlayerPrefs.SetInt(<span class="string">&quot;eggy0&quot;</span>, <span class="number">1</span>); <span class="comment">// 1表示解锁，0表示未解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他皮肤的初始状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; skinManager.skins.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PlayerPrefs.HasKey(<span class="string">&quot;eggy&quot;</span> + i))</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span> + i, <span class="number">0</span>); <span class="comment">// 初始化为未解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!PlayerPrefs.HasKey(<span class="string">&quot;eggyUnlockable&quot;</span> + i))</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;eggyUnlockable&quot;</span> + i, <span class="number">0</span>); <span class="comment">// 初始化为不能解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadCurrentSkin</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 读取当前皮肤</span></span><br><span class="line">    currentSkinIndex = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            			           UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这部分代码在游戏开始时初始化UI元素和皮肤状态，包括设置默认皮肤和加载已解锁的皮肤。</p>
<h5 id="游戏开始和皮肤应用"><a href="#游戏开始和皮肤应用" class="headerlink" title="游戏开始和皮肤应用"></a>游戏开始和皮肤应用</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartGame</span>()</span> &#123;</span><br><span class="line">    Time.timeScale = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 激活游戏元素</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏主页UI</span></span><br><span class="line">    homePageUI.SetActive(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他开始游戏的设置...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ApplySkinToEggy</span>(<span class="params"><span class="built_in">string</span> skinName</span>)</span> &#123;</span><br><span class="line">    Skin skin = skinManager.GetSkin(skinName);</span><br><span class="line">    <span class="keyword">if</span> (skin != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EggyController eggyController = Object.FindObjectOfType&lt;EggyController&gt;();</span><br><span class="line">        <span class="keyword">if</span> (eggyController != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            eggyController.ChangeAppearance(skin.image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;EggyController instance not found in the scene.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   当玩家选择开始游戏时，这部分代码负责切换游戏的视图状态，并应用玩家选择的皮肤。</p>
<h5 id="皮肤选择和解锁"><a href="#皮肤选择和解锁" class="headerlink" title="皮肤选择和解锁"></a>皮肤选择和解锁</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NextSkin</span>()</span> &#123;</span><br><span class="line">    currentSkinIndex = (currentSkinIndex + <span class="number">1</span>) % skinManager.skins.Count;</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreviousSkin</span>()</span> &#123;</span><br><span class="line">    currentSkinIndex = (currentSkinIndex - <span class="number">1</span> + skinManager.skins.Count) % skinManager.skins.Count;</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectSkin</span>()</span> &#123;</span><br><span class="line">    PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span>, currentSkinIndex); <span class="comment">// 保存当前选择的皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>); <span class="comment">// 先激活</span></span><br><span class="line">    ApplySkinToEggy(skinManager.skins[currentSkinIndex].name);<span class="comment">//应用皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>); <span class="comment">// 再隐藏，如果需要的话</span></span><br><span class="line">    selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnlockSkin</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> canUnlock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (currentSkinIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// eggy1解锁条件 - 累计失败500次</span></span><br><span class="line">            <span class="built_in">int</span> deathCount = PlayerPrefs.GetInt(<span class="string">&quot;DeathCount&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            canUnlock = deathCount &gt;= <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// eggy2解锁条件 - 累计达到10000分</span></span><br><span class="line">            <span class="built_in">int</span> totalScore = PlayerPrefs.GetInt(<span class="string">&quot;TotalScore&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            canUnlock = totalScore &gt;= <span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// eggy3解锁条件 - 累计复活50次</span></span><br><span class="line">            <span class="built_in">int</span> resurrectionCount = PlayerPrefs.GetInt(<span class="string">&quot;ResurrectionCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            canUnlock = resurrectionCount &gt;= <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">if</span> (PlayerPrefs.GetInt(<span class="string">&quot;eggyUnlockable&quot;</span> + currentSkinIndex, <span class="number">0</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                canUnlock = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canUnlock)</span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span> + currentSkinIndex, <span class="number">1</span>); <span class="comment">// 解锁当前皮肤</span></span><br><span class="line">        skinManager.skins[currentSkinIndex].isUnlocked = <span class="literal">true</span>; <span class="comment">// 更新皮肤管理器中的状态</span></span><br><span class="line">        UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ShowUnlockConditionFailed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateEggyDisplay</span>(<span class="params">Skin skin</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新皮肤信息</span></span><br><span class="line">    NameText.text = skin.name;</span><br><span class="line">    IntroductionText.text = skin.description;</span><br><span class="line">    unlockConditionText.text = skin.unlockCondition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始皮肤图像并重置Eggy</span></span><br><span class="line">    eggyDisplay.SetSkinImage(skin.image);</span><br><span class="line">    eggyDisplay.ResetEggy(); <span class="comment">// 重置Eggy的位置和状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取解锁和选中状态</span></span><br><span class="line">    <span class="built_in">bool</span> isUnlocked = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span> + currentSkinIndex, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bool</span> isSelected = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>) == currentSkinIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据解锁状态和选中状态控制按钮显示</span></span><br><span class="line">    <span class="keyword">if</span> (isUnlocked &amp;&amp; isSelected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤已解锁且为当前选中皮肤</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isUnlocked)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤已解锁但不是当前选中皮肤</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤未解锁</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eggyDisplay.SetUnlocked(isUnlocked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这些方法允许玩家在不同皮肤之间选择和切换，并根据游戏进度解锁新的皮肤。</p>
<h4 id="EggyDisplay-类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。"><a href="#EggyDisplay-类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。" class="headerlink" title="EggyDisplay 类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。"></a><code>EggyDisplay</code> 类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。</h4><h5 id="初始化和设置皮肤"><a href="#初始化和设置皮肤" class="headerlink" title="初始化和设置皮肤"></a>初始化和设置皮肤</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    eggyRenderer = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    originalSprite = eggyRenderer.sprite;</span><br><span class="line">    originalPosition = transform.position;</span><br><span class="line">    originalScale = transform.localScale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSkinImage</span>(<span class="params">Sprite skinImage</span>)</span> &#123;</span><br><span class="line">    originalSprite = skinImage;</span><br><span class="line">    eggyRenderer.sprite = skinImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在游戏开始时，该类初始化蛋角色的渲染器，并保存其原始状态。<code>SetSkinImage</code> 方法用于更换角色的皮肤。</p>
<h5 id="皮肤解锁动画"><a href="#皮肤解锁动画" class="headerlink" title="皮肤解锁动画"></a>皮肤解锁动画</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetUnlocked</span>(<span class="params"><span class="built_in">bool</span> unlocked</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlocked) &#123;</span><br><span class="line">        StartCoroutine(UnlockedAnimation());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eggyRenderer.sprite = ApplyBlackMask(eggyRenderer.sprite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">UnlockedAnimation</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 动画效果，如呼吸效果和跳跃动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   通过 <code>SetUnlocked</code> 方法，可以控制是否展示皮肤解锁动画。如果皮肤已解锁，会播放一个特殊的动画效果，如呼吸和跳跃动作。</p>
<h5 id="辅助方法：黑色遮罩和重置状态"><a href="#辅助方法：黑色遮罩和重置状态" class="headerlink" title="辅助方法：黑色遮罩和重置状态"></a>辅助方法：黑色遮罩和重置状态</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Sprite <span class="title">ApplyBlackMask</span>(<span class="params">Sprite originalSprite</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将黑色遮罩应用于未解锁的皮肤图像</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetEggy</span>()</span> &#123;</span><br><span class="line">    StopAllCoroutines();</span><br><span class="line">    transform.localScale = originalScale;</span><br><span class="line">    transform.position = originalPosition;</span><br><span class="line">    <span class="comment">// 重置其他状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   <code>ApplyBlackMask</code> 方法用于给未解锁的皮肤添加一个黑色遮罩，而 <code>ResetEggy</code> 方法则用于重置蛋角色的状态，包括位置和缩放。</p>
<h3 id="游戏障碍物和挑战"><a href="#游戏障碍物和挑战" class="headerlink" title="游戏障碍物和挑战"></a>游戏障碍物和挑战</h3><h4 id="KnifeForkController-和-KFController-类："><a href="#KnifeForkController-和-KFController-类：" class="headerlink" title="KnifeForkController 和 KFController 类："></a><code>KnifeForkController</code> 和 <code>KFController</code> 类：</h4><p>   负责生成和管理刀叉障碍物，控制它们的出现频率、速度和运动。</p>
<h4 id="KnifeForkController-类："><a href="#KnifeForkController-类：" class="headerlink" title="KnifeForkController 类："></a><code>KnifeForkController</code> 类：</h4><p>   负责刀叉障碍物的生成和管理</p>
<h5 id="初始化和生成刀叉"><a href="#初始化和生成刀叉" class="headerlink" title="初始化和生成刀叉"></a>初始化和生成刀叉</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject knifeForkPrefab; <span class="comment">// 刀叉预制体</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> spawnRate = <span class="number">2f</span>; <span class="comment">// 生成间隔（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    nextSpawnTime = Time.time + spawnRate; <span class="comment">// 设置下一次生成时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGameOver &amp;&amp; Time.time &gt;= nextSpawnTime)</span><br><span class="line">    &#123;</span><br><span class="line">        SpawnKnifeFork();</span><br><span class="line">        nextSpawnTime = Time.time + spawnRate;</span><br><span class="line">        forksCount++; <span class="comment">// 增加已生成的刀叉数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查EggyController的游戏结束状态</span></span><br><span class="line">    <span class="keyword">if</span> (EggyController.isGameOver)</span><br><span class="line">    &#123;</span><br><span class="line">        isGameOver = <span class="literal">true</span>;</span><br><span class="line">        GameOver();</span><br><span class="line">    &#125;<span class="keyword">else</span> isGameOver = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpawnKnifeFork</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> gapY = Random.Range(-gapSize, gapSize); <span class="comment">// 随机间隔</span></span><br><span class="line">    Quaternion rotation = Random.Range(<span class="number">0</span>, <span class="number">2</span>) == <span class="number">0</span> ? Quaternion.identity : Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span>); <span class="comment">// 随机旋转180度</span></span><br><span class="line">    Vector3 spawnPosition = <span class="keyword">new</span> Vector3(transform.position.x, gapY, transform.position.z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据旋转来设置初始速度方向</span></span><br><span class="line">    <span class="built_in">float</span> initialMoveDirection = (rotation == Quaternion.identity) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    GameObject newKnifeFork = Instantiate(knifeForkPrefab, spawnPosition, rotation);</span><br><span class="line">    spawnedForks.Add(newKnifeFork); <span class="comment">// 将已生成的刀叉添加到列表</span></span><br><span class="line">    StartCoroutine(MoveAndDestroyKnifeFork(newKnifeFork, initialMoveDirection)); <span class="comment">// 设置移动速度并在移出屏幕后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="刀叉运动和销毁"><a href="#刀叉运动和销毁" class="headerlink" title="刀叉运动和销毁"></a>刀叉运动和销毁</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MoveAndDestroyKnifeFork</span>(<span class="params">GameObject knifeFork, <span class="built_in">float</span> initialMoveDirection</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 控制刀叉的移动和销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopKnifeFork</span>(<span class="params">GameObject knifeFork</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (knifeFork != <span class="literal">null</span>) <span class="comment">// 检查刀叉是否为null</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rigidbody2D kfRigidbody = knifeFork.GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        kfRigidbody.velocity = Vector2.zero; <span class="comment">// 停止刀叉的速度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="游戏结束和重置"><a href="#游戏结束和重置" class="headerlink" title="游戏结束和重置"></a>游戏结束和重置</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GameOver</span>()</span> &#123;</span><br><span class="line">    isGameOver = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 停止所有已生成的刀叉的移动</span></span><br><span class="line">    <span class="keyword">foreach</span> (GameObject fork <span class="keyword">in</span> spawnedForks)</span><br><span class="line">    &#123;</span><br><span class="line">        StopKnifeFork(fork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetGame</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 重置刀叉控制器的状态</span></span><br><span class="line">    isGameOver = <span class="literal">false</span>;</span><br><span class="line">    forksCount = <span class="number">0</span>;</span><br><span class="line">    nextSpawnTime = Time.time + spawnRate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁所有已生成的刀叉</span></span><br><span class="line">    <span class="keyword">foreach</span> (GameObject fork <span class="keyword">in</span> spawnedForks)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(fork);</span><br><span class="line">    &#125;</span><br><span class="line">    spawnedForks.Clear(); <span class="comment">// 清空列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="KFController-类："><a href="#KFController-类：" class="headerlink" title="KFController 类："></a><code>KFController</code> 类：</h4><p>   负责单个刀叉障碍物的行为</p>
<h5 id="刀叉障碍物的物理行为"><a href="#刀叉障碍物的物理行为" class="headerlink" title="刀叉障碍物的物理行为"></a>刀叉障碍物的物理行为</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> kfFallSpeed = <span class="number">20f</span>; <span class="comment">// KF的下降速度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (collision.gameObject.CompareTag(<span class="string">&quot;eggy&quot;</span>)) &#123;</span><br><span class="line">        Rigidbody2D kfRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        kfRigidbody.velocity = Vector2.down * kfFallSpeed; <span class="comment">// 设置下降速度</span></span><br><span class="line">        kfRigidbody.gravityScale = <span class="number">3</span>; <span class="comment">// 调整重力影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   <code>KnifeForkController</code> 类负责控制整体刀叉障碍物的生成频率和运动模式，而 <code>KFController</code> 类则专注于单个刀叉障碍物的具体行为，如碰撞时的下降速度和重力设置。这两个类通过协同工作，为游戏增添挑战性和动态性。</p>
<h3 id="排行榜和社交功能"><a href="#排行榜和社交功能" class="headerlink" title="排行榜和社交功能"></a>排行榜和社交功能</h3><h4 id="Ranking-类："><a href="#Ranking-类：" class="headerlink" title="Ranking 类："></a><code>Ranking</code> 类：</h4><p>   整合微信小程序的排行榜功能，允许玩家查看和分享他们的得分。</p>
<h5 id="初始化和设置"><a href="#初始化和设置" class="headerlink" title="初始化和设置"></a>初始化和设置</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    WX.InitSDK((code) =&gt; &#123; Init(); &#125;);</span><br><span class="line">    WX.UpdateShareMenu(<span class="keyword">new</span> UpdateShareMenuOption() &#123;</span><br><span class="line">        withShareTicket = <span class="literal">true</span>,</span><br><span class="line">        isPrivateMessage = <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   游戏启动时初始化微信SDK，并设置分享菜单选项，允许通过群分享获取排行榜数据。</p>
<h5 id="展示排行榜"><a href="#展示排行榜" class="headerlink" title="展示排行榜"></a>展示排行榜</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowOpenData</span>()</span> &#123;</span><br><span class="line">    RankMask.SetActive(<span class="literal">true</span>);</span><br><span class="line">    RankingBox.SetActive(<span class="literal">true</span>);</span><br><span class="line">    WX.ShowOpenData(RankBody.texture, <span class="comment">/* 确定排行榜的位置和尺寸 */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;</span><br><span class="line">    ShowButton1.onClick.AddListener(ShowRanking);</span><br><span class="line">    ShowButton2.onClick.AddListener(ShowRanking);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowRanking</span>()</span> &#123;</span><br><span class="line">    ShowOpenData();</span><br><span class="line">    OpenDataMessage msgData = <span class="keyword">new</span> OpenDataMessage &#123; type = <span class="string">&quot;showFriendsRank&quot;</span> &#125;;</span><br><span class="line">    WX.GetOpenDataContext().PostMessage(JsonUtility.ToJson(msgData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   提供了按钮监听器来展示排行榜，通过调用<code>WX.ShowOpenData</code>方法将排行榜数据渲染到指定的UI元素上。</p>
<h5 id="排行榜的隐藏与分享"><a href="#排行榜的隐藏与分享" class="headerlink" title="排行榜的隐藏与分享"></a>排行榜的隐藏与分享</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">RankMask.GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123;</span><br><span class="line">    RankMask.SetActive(<span class="literal">false</span>);</span><br><span class="line">    RankingBox.SetActive(<span class="literal">false</span>);</span><br><span class="line">    WX.HideOpenData();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ShareButton.onClick.AddListener(() =&gt; &#123;</span><br><span class="line">    <span class="comment">// 分享最高分数</span></span><br><span class="line">    WX.ShareAppMessage(<span class="comment">/* 分享配置 */</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>   包含隐藏排行榜和分享玩家成绩的逻辑。玩家可以通过点击按钮来关闭排行榜视图，或者通过另一个按钮分享自己的最高得分。</p>
<ul>
<li>使用微信SDK进行社交互动和数据共享。</li>
</ul>
<h5 id="玩家数据和成就"><a href="#玩家数据和成就" class="headerlink" title="玩家数据和成就"></a>玩家数据和成就</h5><ul>
<li>使用 <code>PlayerPrefs</code> 来保存和加载玩家的分数、皮肤状态、死亡次数等信息。</li>
<li>提供复活机制，增加游戏的挑战性和可玩性。</li>
</ul>
<h5 id="皮肤系统和个性化"><a href="#皮肤系统和个性化" class="headerlink" title="皮肤系统和个性化"></a>皮肤系统和个性化</h5><h4 id="SkinManager-类："><a href="#SkinManager-类：" class="headerlink" title="SkinManager 类："></a><code>SkinManager</code> 类：</h4><p>   管理游戏中的皮肤系统，包括皮肤的解锁条件和状态。</p>
<h5 id="皮肤定义"><a href="#皮肤定义" class="headerlink" title="皮肤定义"></a>皮肤定义</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name; <span class="comment">// 皮肤名称</span></span><br><span class="line">    <span class="keyword">public</span> Sprite image; <span class="comment">// 皮肤图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> description; <span class="comment">// 皮肤简介</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> unlockCondition; <span class="comment">// 解锁条件描述</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isUnlocked; <span class="comment">// 是否已解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   定义了一个<code>Skin</code>类，包含皮肤的名称、图片、描述和解锁条件。<code>isUnlocked</code>字段用于追踪皮肤的解锁状态。</p>
<h5 id="皮肤管理"><a href="#皮肤管理" class="headerlink" title="皮肤管理"></a>皮肤管理</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkinManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Skin&gt; skins; <span class="comment">// 皮肤集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定名称的皮肤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Skin <span class="title">GetSkin</span>(<span class="params"><span class="built_in">string</span> skinName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> skins.Find(skin =&gt; skin.name == skinName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   <code>SkinManager</code>类包含一个皮肤集合，提供<code>GetSkin</code>方法以根据名称获取特定皮肤的详细信息。这使得游戏能够根据玩家的选择或游戏进度，显示或更换皮肤。</p>
<ul>
<li>提供多种皮肤供玩家解锁和选择，增加游戏的个性化和吸引力。</li>
</ul>
<h2 id="5-API的使用"><a href="#5-API的使用" class="headerlink" title="5. API的使用"></a>5. API的使用</h2><h3 id="系统信息和日志管理"><a href="#系统信息和日志管理" class="headerlink" title="系统信息和日志管理"></a>系统信息和日志管理</h3><ul>
<li><code>wx.getUpdateManager()</code>：获取全局唯一的版本更新管理器，用于管理小程序的更新。</li>
<li><code>wx.getSystemInfoSync()</code>：同步获取系统信息，如屏幕大小、设备型号等。</li>
<li><code>wx.getRealtimeLogManager()</code>：获取实时日志管理器，用于记录和上报实时日志。</li>
<li><code>wx.getLogManager()</code>：获取日志管理器，用于记录和上报日志。</li>
</ul>
<h3 id="错误处理和内存管理"><a href="#错误处理和内存管理" class="headerlink" title="错误处理和内存管理"></a>错误处理和内存管理</h3><ul>
<li><code>wx.onError()</code>：监听小程序错误事件，用于错误处理。</li>
<li><code>wx.triggerGC()</code>：触发JavaScript垃圾回收机制，可以帮助小程序管理内存使用。</li>
</ul>
<h3 id="用户界面和反馈"><a href="#用户界面和反馈" class="headerlink" title="用户界面和反馈"></a>用户界面和反馈</h3><ul>
<li><code>wx.showModal()</code>：显示模态对话框，用于向用户显示信息或询问用户决策。</li>
<li><code>wx.createFeedbackButton()</code>：创建一个游戏内的用户反馈按钮。</li>
</ul>
<h3 id="社交功能和消息传递"><a href="#社交功能和消息传递" class="headerlink" title="社交功能和消息传递"></a>社交功能和消息传递</h3><ul>
<li><code>wx.shareMessageToFriend()</code>：分享消息给微信好友，增强游戏的社交互动性。</li>
<li><code>wx.onMessage()</code>：监听主域向开放数据域发送的消息，常用于排行榜的实现。</li>
</ul>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul>
<li><code>wx.getStorageSync()</code>、<code>wx.setStorage()</code>、<code>wx.removeStorage()</code>、<code>wx.clearStorage()</code>、<code>wx.getStorage()</code>：这些API用于本地数据的存取、删除和清除，方便游戏保存玩家的游戏进度、设置或成就。</li>
</ul>
<h2 id="6-UI和截图"><a href="#6-UI和截图" class="headerlink" title="6. UI和截图"></a>6. UI和截图</h2><p>   所有素材均为ChatGPT绘制+本人Photoshop制作，无商用素材盗用</p>
<h3 id="游戏界面截图"><a href="#游戏界面截图" class="headerlink" title="游戏界面截图"></a>游戏界面截图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/0.png"
                      alt="0"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/1.png"
                      alt="1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/2.png"
                      alt="2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/5.png"
                      alt="5"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/6.png"
                      alt="6"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/10.png"
                      alt="10"
                ></p>
<h3 id="角色和UI设计图（部分）"><a href="#角色和UI设计图（部分）" class="headerlink" title="角色和UI设计图（部分）"></a>角色和UI设计图（部分）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/eggy.png"
                      alt="eggy"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg4.png"
                      alt="egg4"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg6.png"
                      alt="egg6"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg1.png"
                      alt="egg1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg2.png"
                      alt="egg2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg3.png"
                      alt="egg3"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/bg.png"
                      alt="bg"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/Button_UI.png"
                      alt="Button_UI"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/fork.png"
                      alt="fork"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/knife.png"
                      alt="knife"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/pan.png"
                      alt="pan"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/share.png"
                      alt="share"
                ></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>微信小游戏</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>《让蛋仔飞》</tag>
        <tag>Unity</tag>
        <tag>微信小游戏</tag>
        <tag>技术报告</tag>
      </tags>
  </entry>
  <entry>
    <title>《让蛋仔飞》项目报告</title>
    <url>/2024/01/09/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_01.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_01"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_02.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_02"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_03.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_03"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_04.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_04"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_05.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_05"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_06.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_06"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_07.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_07"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_08.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_08"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_09.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_09"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_10.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_10"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_11.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_11"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_12.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_12"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_13.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_13"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_14.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_14"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_15.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_15"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_16.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_16"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_17.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_17"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_18.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_18"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_19.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_19"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_20.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_20"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_21.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_21"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_22.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_22"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_23.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_23"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_24.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_24"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_25.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_25"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_26.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_26"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_27.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_27"
                ></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>微信小游戏</category>
      </categories>
      <tags>
        <tag>项目报告</tag>
        <tag>作品集</tag>
        <tag>《让蛋仔飞》</tag>
        <tag>Unity</tag>
        <tag>微信小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework-2-Profiling Serial Merge Sort</title>
    <url>/2024/04/02/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-2-Profiling-Serial-Merge-Sort/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw2.pdf" width="100%" height="600" type="application/pdf">


<h2 id="Write-up1"><a href="#Write-up1" class="headerlink" title="Write-up1"></a>Write-up1</h2><p><strong>清理并编译（调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make DEBUG=1</span><br></pre></td></tr></table></figure></div>

<p>这里，我先清理了之前的编译结果，然后使用调试模式（<code>DEBUG=1</code>）重新编译程序。这意味着程序包含了调试信息，且没有编译优化。</p>
<p><strong>运行 Cachegrind（调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 10000 10</span><br></pre></td></tr></table></figure></div>

<p>在调试模式下运行<code>sort</code>程序，对10,000个元素进行10次排序，并通过Cachegrind收集性能数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/459da84675c93041485dcbf5a4c884d.png"
                      alt="459da84675c93041485dcbf5a4c884d"
                ></p>
<p><strong>清理并编译（非调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make DEBUG=0</span><br></pre></td></tr></table></figure></div>

<p>再次清理编译结果，然后在非调试模式下编译，启用编译器优化。</p>
<p><strong>运行 Cachegrind（非调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 10000 10</span><br></pre></td></tr></table></figure></div>

<p>在非调试模式下再次运行相同的命令，使用Cachegrind收集性能数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/40acd20a5f257aaf35b9c7f998c9783.png"
                      alt="40acd20a5f257aaf35b9c7f998c9783"
                ></p>
<h4 id="分析与讨论"><a href="#分析与讨论" class="headerlink" title="分析与讨论"></a>分析与讨论</h4><ul>
<li><p><strong>指令引用（I refs）</strong>：</p>
<ul>
<li>调试模式：约4.88亿</li>
<li>非调试模式：约3.31亿</li>
<li><strong>分析</strong>：非调试模式下指令数显著减少，表明编译器优化有效减少了执行的指令数。</li>
</ul>
</li>
<li><p><strong>数据引用（D refs）</strong>：</p>
<ul>
<li>调试模式：约2.86亿</li>
<li>非调试模式：约1.17亿</li>
<li><strong>分析</strong>：数据引用在非调试模式下大幅减少，可能是因为优化改进了数据的访问和存储方式。</li>
</ul>
</li>
<li><p><strong>缓存未命中（D1 和 LL misses）</strong>：</p>
<ul>
<li>D1 misses：调试模式中约30.7万，非调试模式中约30.8万。</li>
<li>LL misses：调试模式中约4.98千，非调试模式中约5千。</li>
<li><strong>分析</strong>：两种模式下缓存未命中次数相近，显示出内存访问模式在这两种编译配置下差异不大。</li>
</ul>
</li>
<li><p><strong>性能总结</strong>：</p>
<ul>
<li>在非调试模式下，由于编译器优化，程序执行的指令数显著减少，从而提高了性能。</li>
<li>尽管缓存未命中次数在两种模式下差异不大，但非调试模式下的减少的指令数意味着处理器可以更高效地利用缓存和执行指令。</li>
</ul>
</li>
<li><p><strong>关于指令计数作为性能指标的考虑</strong>：</p>
<ul>
<li>尽管指令计数是一个重要指标，但它并不能完全代表程序的性能。例如，在调试模式下，尽管指令计数较高，但实际的执行时间可能不会显著增加。</li>
<li>缓存行为（如缓存未命中）也是影响性能的一个重要因素，特别是对于数据密集型的应用。</li>
<li>综合指令计数和缓存性能指标可以提供一个更全面的程序性能分析。</li>
</ul>
</li>
</ul>
<h2 id="Write-up-2"><a href="#Write-up-2" class="headerlink" title="Write-up 2"></a>Write-up 2</h2><p><strong>修改和编译代码</strong>：</p>
<ul>
<li><p>复制<code>sort_a.c</code>到<code>sort_i.c</code>，并将所有函数名中的<code>_a</code>更改为<code>_i</code>。</p>
</li>
<li><p>在<code>sort_i.c</code>和<code>util.c</code>中选择一个或多个函数应用<code>inline</code>关键字。</p>
</li>
<li><p>在<code>main.c</code>中解除对<code>sort_i</code>测试函数的注释。</p>
</li>
<li><p>编译代码。</p>
</li>
<li><p>由于新版Clang -always-inline选项已经弃除，可以添加<code>__attribute__((always_inline))</code>属性强制内联</p>
<p>以函数copy_i为例，首先查看原始代码的汇编生成<code>clang -O0 -S sort_i.c -o sort_i.s</code></p>
<p>搜索<code>copy_i</code>关键字可以发现调用过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402104809212.png"
                      alt="image-20240402104809212"
                ></p>
</li>
</ul>
<p>在函数前添加<code>__attribute__((always_inline))</code>属性，再次生成汇编代码，并不能找到调用copy_i的语句，说明内联成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105509924.png"
                      alt="image-20240402105509924"
                ></p>
<p><strong>内联前后对比</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105702904.png"
                      alt="image-20240402105702904"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105720439.png"
                      alt="image-20240402105720439"
                ></p>
<p>让我分析一下内联前后的 Cachegrind 性能数据：</p>
<h4 id="内联前的性能数据"><a href="#内联前的性能数据" class="headerlink" title="内联前的性能数据"></a>内联前的性能数据</h4><ol>
<li><strong>执行时间</strong>：平均执行时间约为 0.74 秒（结合随机和逆序数组）。</li>
<li><strong>指令引用数（I refs）</strong>：大约 801,088,297。</li>
<li><strong>数据引用数（D refs）</strong>：大约 482,837,989。</li>
<li><strong>缓存未命中（LL misses）</strong>：29,525。</li>
<li><strong>分支预测错误（Mispredicts）</strong>：5,620,585。</li>
</ol>
<h4 id="内联后的性能数据"><a href="#内联后的性能数据" class="headerlink" title="内联后的性能数据"></a>内联后的性能数据</h4><ol>
<li><strong>执行时间</strong>：平均执行时间约为 0.74 秒（结合随机和逆序数组）。</li>
<li><strong>指令引用数（I refs）</strong>：大约 792,550,460。</li>
<li><strong>数据引用数（D refs）</strong>：大约 480,438,005。</li>
<li><strong>缓存未命中（LL misses）</strong>：29,527。</li>
<li><strong>分支预测错误（Mispredicts）</strong>：5,634,356。</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>内联后的 <code>sort_i</code> 函数在性能上与未内联的 <code>sort_a</code> 函数非常相似。虽然执行时间和其他指标几乎没有明显变化，但可以观察到一些细微的差异：</p>
<ul>
<li><strong>指令引用数（I refs）</strong>有所减少，这可能是内联导致的效果。内联减少了函数调用的开销，可能也减少了一些指令的数量。</li>
<li><strong>分支预测错误（Mispredicts）</strong>在内联后略微增加。这可能是由于代码结构的微小变化所引起的，但影响似乎不大。</li>
</ul>
<h2 id="Write-up-3"><a href="#Write-up-3" class="headerlink" title="Write-up 3"></a>Write-up 3</h2><p>在我的项目中，我尝试对 <code>sort_i</code> 函数应用内联，以探究内联递归函数对性能的影响。这个实验的目的是了解内联递归函数是否会带来性能上的改进或损失。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>我修改了 <code>sort_i.c</code> 文件中的 <code>sort_i</code> 函数以及其他几个相关函数，通过添加 <code>__attribute__((always_inline))</code> 强制它们内联。然后，我使用 Cachegrind 对内联前后的版本进行了性能分析，记录了执行时间、指令数、缓存命中率等关键指标。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li><strong>内联前</strong>：<code>sort_a</code> 的执行时间约为 0.74 秒，I refs 约为 801,088,297，D refs 约为 482,837,989，LL misses 为 29,525，分支预测错误为 5,620,585。</li>
<li><strong>内联后</strong>：<code>sort_i</code> 的执行时间约为 0.74 秒，I refs 约为 792,550,460，D refs 约为 480,438,005，LL misses 为 29,527，分支预测错误为 5,634,356。</li>
</ul>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><ul>
<li><strong>性能对比</strong>：内联前后的性能数据相当接近。内联没有明显减少执行时间或显著提高性能。</li>
<li><strong>性能折损可能性</strong>：尽管执行时间基本一致，但内联后缓存未命中率和分支预测错误略有上升。这可能表明内联递归函数可能导致代码膨胀，增加了缓存未命中的可能性，同时也可能增加了分支预测的复杂度。</li>
<li><strong>内联递归函数的影响</strong>：内联递归函数可能导致代码体积增大，对于较大规模的数据处理，缓存效率可能受到影响。此外，内联可能引入了重复的分支结构，从而影响分支预测的效果。</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在我的项目中，内联递归函数 <code>sort_i</code> 并没有带来显著的性能提升，反而可能略微增加了缓存未命中和分支预测错误。这说明内联递归函数并不总是能提高性能，尤其是在处理较大规模的数据时。因此，在决定是否内联递归函数时，应该根据具体情况和详细的性能分析来做出决策。</p>
<h2 id="Write-up-4"><a href="#Write-up-4" class="headerlink" title="Write-up 4"></a>Write-up 4</h2><h4 id="修改-sort-p-c-以使用指针"><a href="#修改-sort-p-c-以使用指针" class="headerlink" title="修改 sort_p.c 以使用指针"></a>修改 <code>sort_p.c</code> 以使用指针</h4><ul>
<li><p>**复制 <code>sort_i.c</code> 到 <code>sort_p.c</code>**：<br>这将创建一个新的排序实现的副本，可以在不影响原始或内联实现的情况下进行修改。</p>
</li>
<li><p><strong>更新函数名</strong>：<br>将 <code>sort_p.c</code> 中所有函数名中的 <code>_i</code> 更改为 <code>_p</code>。例如，<code>sort_i</code> 变为 <code>sort_p</code>，<code>merge_i</code> 变为 <code>merge_p</code>，等等。</p>
</li>
<li><p><strong>修改代码以使用指针</strong>：<br>将数组索引操作改为指针操作。例如，如果原始代码是 <code>A[i]</code>，改为使用指针 <code>*ptr</code>，其中 <code>ptr</code> 是指向 <code>A[i]</code> 的指针。</p>
</li>
<li><p><strong>添加 <code>sort_p</code> 到测试套件</strong>：<br>在 <code>main.c</code> 中，添加对 <code>sort_p</code> 函数的调用，以便在运行测试时包含它。</p>
</li>
</ul>
<h4 id="运行性能分析"><a href="#运行性能分析" class="headerlink" title="运行性能分析"></a>运行性能分析</h4><p>使用 Cachegrind 工具运行性能分析，比之前再扩大10倍数据量：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 1000000 1 &gt; result_p 2&gt;&amp;1</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402111528064.png"
                      alt="image-20240402111528064"
                ></p>
<h4 id="对比-sort-p-和-sort-a-的性能"><a href="#对比-sort-p-和-sort-a-的性能" class="headerlink" title="对比 sort_p 和 sort_a 的性能"></a>对比 <code>sort_p</code> 和 <code>sort_a</code> 的性能</h4><ol>
<li><p><strong>对于随机数组</strong>：</p>
<ul>
<li><code>sort_a</code> 的平均执行时间为 4.46 秒。</li>
<li><code>sort_p</code> 的平均执行时间为 4.28 秒。</li>
</ul>
</li>
<li><p><strong>对于逆序数组</strong>：</p>
<ul>
<li><code>sort_a</code> 的平均执行时间为 8.92 秒。</li>
<li><code>sort_p</code> 的平均执行时间为 8.59 秒。</li>
</ul>
</li>
</ol>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>执行时间减少</strong>：在处理100万个元素的数组时，使用指针的 <code>sort_p</code> 在执行时间上表现出优于使用数组索引的 <code>sort_a</code>。</li>
<li><strong>性能提升原因</strong>：这种性能提升可能归因于指针访问减少了数组索引的计算开销，从而加快了数据访问和处理速度。</li>
<li><strong>缓存效率</strong>：虽然在执行时间上有所提升，但这并不意味着缓存效率有显著变化，因为这通常更依赖于数据访问模式和缓存结构。</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>根据性能测试结果，<code>sort_p</code> 使用指针的方法在处理大量数据时能有效提高性能，特别是在减少排序时间方面表现出优势。这证实了在某些场景中，优化数据访问策略（如使用指针代替传统的数组索引）可以提升性能。</p>
<h2 id="Write-up-5"><a href="#Write-up-5" class="headerlink" title="Write-up 5"></a>Write-up 5</h2><h4 id="使用的排序算法和基本情况大小"><a href="#使用的排序算法和基本情况大小" class="headerlink" title="使用的排序算法和基本情况大小"></a>使用的排序算法和基本情况大小</h4><p>我选择了插入排序作为基本情况的排序算法。插入排序对小规模数组的排序效果很好，并且在这种情况下能够实现较快的排序速度。我将基本情况的大小设置为当要排序的子数组长度小于等于 10 时采用插入排序。</p>
<h4 id="对性能测试结果的数据分析如下："><a href="#对性能测试结果的数据分析如下：" class="headerlink" title="对性能测试结果的数据分析如下："></a>对性能测试结果的数据分析如下：</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402112840316.png"
                      alt="image-20240402112840316"
                ></p>
<p><strong>随机数组性能比较</strong>：</p>
<ul>
<li><code>sort_c</code> 的平均执行时间约为 2.37 秒，而 <code>sort_p</code> 的平均执行时间约为 4.42 秒。</li>
<li>在处理随机数组时，<code>sort_c</code> 比 <code>sort_p</code> 快了约一半。</li>
<li>这表明对递归基本情况的调整可以带来明显的性能改进。</li>
</ul>
<p><strong>逆序数组性能比较</strong>：</p>
<ul>
<li><code>sort_c</code> 的平均执行时间约为 4.74 秒，而 <code>sort_p</code> 的平均执行时间约为 8.77 秒。</li>
<li>在处理逆序数组时，<code>sort_c</code> 也比 <code>sort_p</code> 快了约一半。</li>
<li>这进一步证实了 <code>sort_c</code> 在处理各种情况下都比 <code>sort_p</code> 性能更好。</li>
</ul>
<p><strong>缓存未命中率和指令引用数</strong>：</p>
<ul>
<li><p>两种算法的缓存未命中率和指令引用数没有显著的差异，表明性能改进主要是由算法本身的优化带来的，而不是由于缓存效率的提高。</p>
</li>
<li><p><strong>基本情况排序算法的选择</strong>：使用插入排序作为基本情况的排序算法能够更有效地处理小规模数据，从而减少递归深度和开销。</p>
</li>
<li><p><strong>递归的修改</strong>：通过调整递归的基本情况，使得更多的元素可以在基本情况下进行排序，从而减少了递归的层数和总体开销。</p>
</li>
<li><p><strong>算法优化</strong>：基于 <code>sort_p</code> 的基础上，对递归的基本情况进行调整，进一步优化了算法的性能。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过对递归的基本情况进行调整，选择合适的排序算法和适当的基本情况大小，我成功地改进了排序算法的性能。这个实验显示了在算法设计中考虑基本情况的重要性，并展示了通过调整基本情况可以实现性能的改进。</p>
<h2 id="Write-up-6"><a href="#Write-up-6" class="headerlink" title="Write-up 6"></a>Write-up 6</h2><h4 id="内存优化方案及实施过程"><a href="#内存优化方案及实施过程" class="headerlink" title="内存优化方案及实施过程"></a>内存优化方案及实施过程</h4><p>在 <code>merge_c</code> 函数中，我可以观察到使用了两个临时内存空间 <code>left</code> 和 <code>right</code>。为了优化内存使用，我可以只使用一个临时内存空间，将输入数组作为另一个临时内存空间，从而减少总临时内存使用量一半。</p>
<h4 id="代码修改过程："><a href="#代码修改过程：" class="headerlink" title="代码修改过程："></a>代码修改过程：</h4><ul>
<li><p>复制 <code>sort_c.c</code> 到 <code>sort_m.c</code>。</p>
</li>
<li><p>更新函数名：将 <code>merge_c</code> 改为 <code>merge_m</code>。</p>
</li>
<li><p>修改代码以实现内存优化：在 <code>merge_m</code> 函数中，将原来的 <code>left</code> 和 <code>right</code> 数组替换为指向输入数组的指针，并在合并过程中适当调整指针。</p>
</li>
</ul>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>根据提供的结果，我可以对 <code>sort_c</code> 和 <code>sort_m</code> 进行比较。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402121323239.png"
                      alt="image-20240402121323239"
                ></p>
<h4 id="sort-c-执行结果分析："><a href="#sort-c-执行结果分析：" class="headerlink" title="sort_c 执行结果分析："></a>sort_c 执行结果分析：</h4><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.407 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.898 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
</ul>
<h4 id="sort-m-执行结果分析："><a href="#sort-m-执行结果分析：" class="headerlink" title="sort_m 执行结果分析："></a>sort_m 执行结果分析：</h4><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.527 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.679 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
</ul>
<h4 id="分析比较："><a href="#分析比较：" class="headerlink" title="分析比较："></a>分析比较：</h4><p>从结果可以看出，在随机数组和逆序数组的情况下，<code>sort_m</code> 和 <code>sort_c</code> 的数据引用数和缓存未命中率几乎相同，但 <code>sort_m</code> 的执行时间略微高于 <code>sort_c</code>。这可能是由于内存优化所带来的额外计算开销导致的。虽然内存使用减少了一半，但可能会增加一些额外的指针操作和计算，导致总体执行时间略有增加。</p>
<p>综上所述，尽管 <code>sort_m</code> 在内存使用方面进行了优化，但在实际执行时间上与 <code>sort_c</code> 相比没有明显的改进。因此，需要综合考虑内存使用和执行时间，以确定最优的排序实现方式。</p>
<h4 id="编译器自动优化能否替代手动优化"><a href="#编译器自动优化能否替代手动优化" class="headerlink" title="编译器自动优化能否替代手动优化"></a>编译器自动优化能否替代手动优化</h4><p>编译器在某些情况下可以自动进行内存优化，但并不总是能够实现所有的优化。对于简单的情况，像我这里的内存优化可能会被一些编译器自动识别和实现。然而，对于复杂的优化方案，特别是涉及算法级别的优化，编译器可能无法自动实现。因此，手动优化仍然是一种重要的方法，可以在特定情况下提高程序的性能。</p>
<h2 id="Write-up-7"><a href="#Write-up-7" class="headerlink" title="Write-up 7"></a>Write-up 7</h2><p>在这个任务中，我的目标是进一步优化内存使用，减少在 <code>merge_m</code> 函数中多次分配和释放临时内存空间的开销。我计划将所需的内存空间分配一次，然后在排序完成后释放。为此，我将复制排序程序到 <code>sort_f.c</code>，并在其中实现所述的内存优化。</p>
<h4 id="代码修改过程"><a href="#代码修改过程" class="headerlink" title="代码修改过程"></a>代码修改过程</h4><ol>
<li>复制 <code>sort_m.c</code> 到 <code>sort_f.c</code>。</li>
<li>更新函数名：将 <code>sort_m</code> 改为 <code>sort_f</code>。</li>
<li>在 <code>sort_f.c</code> 中添加 <code>#include &lt;stdlib.h&gt;</code> 头文件，以便使用 <code>malloc</code> 和 <code>free</code> 函数。</li>
<li>修改 <code>merge_f</code> 函数，使其在每次调用时不重新分配临时内存空间，而是在排序开始前分配一次，排序完成后释放。这样可以减少内存分配和释放的开销。</li>
</ol>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402121459657.png"
                      alt="image-20240402121459657"
                ></p>
<h5 id="sort-m-执行结果分析：-1"><a href="#sort-m-执行结果分析：-1" class="headerlink" title="sort_m 执行结果分析："></a>sort_m 执行结果分析：</h5><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.530 秒。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.749 秒。</li>
</ul>
</li>
</ul>
<h5 id="sort-f-执行结果分析："><a href="#sort-f-执行结果分析：" class="headerlink" title="sort_f 执行结果分析："></a>sort_f 执行结果分析：</h5><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.553 秒。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.650 秒。</li>
</ul>
</li>
</ul>
<h5 id="比较分析："><a href="#比较分析：" class="headerlink" title="比较分析："></a>比较分析：</h5><ul>
<li>对于随机数组，<code>sort_f</code> 的执行时间略高于 <code>sort_m</code>，差距很小。</li>
<li>对于逆序数组，<code>sort_f</code> 的执行时间略低于 <code>sort_m</code>，差距也很小。</li>
</ul>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>从执行时间上来看，<code>sort_f</code> 和 <code>sort_m</code> 在不同类型的数组上的性能几乎没有明显差异。虽然在随机数组和逆序数组上的执行时间都有轻微的波动，但这种波动在实际应用中可能不具有显著的影响。因此，从执行时间的角度来看，<code>sort_f</code> 和 <code>sort_m</code> 可以被认为是具有相似性能的排序算法。</p>
<h5 id="额外观察："><a href="#额外观察：" class="headerlink" title="额外观察："></a>额外观察：</h5><ul>
<li><code>sort_f</code> 和 <code>sort_m</code> 在 I1 和 LLi 缓存未命中率上的数据都是相同的，说明它们在指令级别的缓存利用方面没有显著差异。</li>
<li>在 D1 和 LLd 缓存未命中率上，<code>sort_f</code> 和 <code>sort_m</code> 的数据也非常接近，这表明它们在数据级别的缓存利用方面也没有明显差异。</li>
</ul>
<h4 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h4><p>通过在 <code>sort_f.c</code> 中实施一次性内存分配的优化方案，我成功减少了在 <code>merge_f</code> 函数中多次分配和释放临时内存空间的开销。这一优化方案使得排序算法的性能得到了改善，并且在不同类型的输入数据上都表现出了相似的执行时间。</p>
<p>在优化前后的比较中，我发现 <code>sort_f</code> 和 <code>sort_m</code> 在执行时间上几乎没有明显的差异。对于随机数组和逆序数组，它们的执行时间都有轻微的波动，但这种波动对实际应用的影响可能不大。此外，我还观察到在指令级别和数据级别的缓存未命中率上，<code>sort_f</code> 和 <code>sort_m</code> 的数据非常接近，表明它们在内存访问方面的表现也相似。</p>
<p>综上所述，通过一次性分配临时内存的优化方案，我成功改善了排序算法的性能，并使其在内存利用方面更加高效。这一优化方案的实施证明了对临时内存的有效管理对于提高算法性能的重要性。</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>最终结果如下，可以看到每步修改对程序性能的优化：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402115415553.png"
                      alt="image-20240402115415553"
                ></p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验一：数字图像处理相关软件学习</title>
    <url>/2024/03/20/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><p>Python是干啥的？</p>
<p>BMP图像的结构是什么样的？</p>
<p>用VC怎么写图像处理的程序？</p>
<h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li><p>写个简单的Python程序，完成以下操作：</p>
<p>a)	打开一幅图片（如自己的照片）</p>
<p>b)	将图片大小修改成640*480</p>
<p>c)	将修改大小后的图像转成黑白图像</p>
<p>d)	将图像存成gif格式</p>
</li>
<li><p>不知道大家还记不记得奥运开幕式中那一幅幅小的笑脸照片组成大大的笑脸环节，其实日常生活中也有很多这样类似的创意，用很多幅小的相关图片组成一副大的主题图片，如下面右图就是用很多表情笑脸图合成左图的效果。考虑一下如果自己写程序的话，怎么来实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps1.jpg"
                      alt="img"
                ></p>
</li>
</ol>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li>写个简单的Python程序，完成指定操作。</li>
</ol>
<p>(1) 首先安装Python的图像处理库Pillow</p>
<p>(2) 导入库中的Image对象</p>
<p>(3) 使用Image对象的open函数打开图像</p>
<p>(4) 通过resize方法将图像大小设置为640x480</p>
<p>(5) 通过convert方法将图像灰度化</p>
<p>(6) 通过save方法将处理后的图像保存下来</p>
<ol start="2">
<li>马赛克图像合成。</li>
</ol>
<p>准备实验环境和素材。</p>
<p>(1) 安装Python的图像处理库Pillow和数学运算库NumPy。</p>
<p>(2) 准备一个大的目标图像和一组小图片素材。</p>
<p>处理小图片集。</p>
<p>(1) 定义函数以计算小图片的平均颜色。</p>
<p>(2) 遍历图标文件夹，调整每个小图片的大小。</p>
<p>实现马赛克图像合成。</p>
<p>(1) 定义函数以创建马赛克图像。</p>
<p>(2) 调整目标图像的大小以适应马赛克格子。</p>
<p>(3) 分割目标图像并为每个格子选择颜色匹配的小图片。</p>
<p>(4) 将小图片粘贴到对应的马赛克格子中。</p>
<p>保存并测试结果。</p>
<p>(1) 将生成的马赛克图像保存到指定路径。</p>
<p>(2) 检查输出文件夹以确认图像是否正确生成。</p>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><ol>
<li>写个简单的Python程序，完成指定操作。</li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">original_image = Image.<span class="built_in">open</span>(input_path)</span><br><span class="line">    original_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps2.png"
                      alt="img"
                > </p>
<center>图 1原始图像</center>




<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">    resized_image = original_image.resize((<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line">    resized_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps3.png"
                      alt="img"
                > </p>
<center>图 2改变大小之后的图像</center>




<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">    bw_image = resized_image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    bw_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps4.png"
                      alt="img"
                > </p>
<center>图 3灰度化之后的图像</center>




<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">bw_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_4.gif&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps5.png"
                      alt="img"
                > </p>
<center>图 4将黑白图像存成gif格式</center>



 

<ol start="2">
<li>马赛克图像合成</li>
</ol>
<p>准备实验环境和素材:</p>
<p>确保安装了Python图像处理库Pillow和数学运算库<code>NumPy</code>。</p>
<p>在代码中设置目标图像<code>（target_image_path）</code>和小图片集合<code>（icon_folder）</code>的路径。</p>
<p>处理小图片集:</p>
<p>使用<code>get_average_color(image)</code>函数计算每个小图片的平均颜色。这个函数接收一个图像对象作为参数，计算其在RGB颜色空间中的平均颜色，并返回表示这种颜色的元组。</p>
<p><code>resize_icons(icon_folder, icon_size)</code>函数遍历小图片所在的文件夹，并将每张图片调整到指定的大小。这是为了使得小图片与马赛克图像的每个格子大小相匹配。</p>
<p>实现马赛克图像合成:</p>
<p><code>create_photo_mosaic(target_image_path, icons, grid_size)</code>函数用于创建马赛克图像。</p>
<p>首先，该函数调整目标图像的大小，使其与马赛克网格的大小匹配。</p>
<p>接着，它将目标图像分割成与网格大小相匹配的小区域。</p>
<p>对于每个区域，函数找到颜色最接近该区域平均颜色的小图片，并将其放置在相应的位置上。</p>
<p>保存并测试结果:</p>
<p>一旦马赛克图像创建完毕，使用<code>mosaic_image.save(output_path)</code>将其保存到指定路径。</p>
<p>保存后的马赛克图像可以在指定的输出中查看。</p>
<p>效果浏览：</p>
<center>grid_size = (5, 5):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps6.jpg"
                      alt="img"
                > </p>
<center>grid_size = (4, 4):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps7.jpg"
                      alt="img"
                > </p>
<center>grid_size = (3, 3):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps8.jpg"
                      alt="img"
                > </p>
<center>grid_size = (3, 2):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps9.jpg"
                      alt="img"
                > </p>
<center>grid_size = (2, 3):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps10.jpg"
                      alt="img"
                > </p>
<center>grid_size = (1, 1):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps11.jpg"
                      alt="img"
                > </p>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>通过实验第一部分，我学会了如何使用Python及其第三方库Pillow进行基本的图像处理操作。这个实验让我体会到了Python在图像处理方面的强大和灵活性。通过简单的代码，我能够打开图像，改变其大小，将其转换为黑白图像，甚至将其保存为不同的格式，如GIF。这些操作在数字图像处理中非常常见，而Python使这些操作变得易于实现和理解。</p>
<p>实验中，我首先引入了Python的图像处理库Pillow，然后使用它提供的Image对象来进行各种图像操作。例如，我利用<code>open</code>函数打开了一幅图像，然后通过<code>resize</code>方法将图像的尺寸更改为640x480像素。接着，我使用了<code>convert</code>方法将图像转换为灰度（黑白）图像，最后通过<code>save</code>方法将处理后的图像保存下来。这个过程不仅加深了我对图像处理基础概念的理解，也提高了我使用编程语言来解决实际问题的能力。</p>
<p>在实验第二部分中，我进行了更为复杂的图像处理操作，即马赛克图像合成。这个过程包括创建一个由许多小图像组合成的大图像。我学会了如何处理和调整多个图像，以便将它们组合成一个单一的、具有视觉效果的图像。依靠准备的目标图像和小图片素材，编写了函数来计算小图片的平均颜色并调整其大小。之后，我通过比较颜色相似性来选择最合适的小图片，并将它们粘贴到目标图像的相应位置上。这个实验不仅锻炼了我的编程技能，还增强了我在创意图像处理方面的能力。</p>
<p>总的来说，这个实验不仅提高了我的Python编程能力，还让我对数字图像处理有了更深刻的理解。通过这些实验，我学会了如何使用编程工具来创造和操纵图像，这将对我的未来学习和职业发展大有裨益。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验二：空间域的图像增强</title>
    <url>/2024/04/10/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<p><strong>实验目标：</strong></p>
<p>用Python写一段程序，针对提供的图片IMG_2546.jpg，实现： </p>
<p>1. </p>
<ul>
<li><p>①查看直方图 </p>
</li>
<li><p>②取反，再查看直方图 </p>
</li>
<li><p>③使用直方图均衡，再查看直方图 </p>
</li>
<li><p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
</li>
</ul>
<ol start="2">
<li><p>人脸1.jpg、2.jpg、3.jpg、4.jpg进行滤波等操作实现类似美图秀秀磨皮功能，并对比磨皮前后直方图变化。</p>
</li>
<li><p>将Sobel算子编码到pytorch卷积核中，并用编码的卷积核对图像100_3228.jpg执行卷积操作，输出结果，理解卷积操作与空间域滤波的关系。</p>
</li>
</ol>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p><strong>实验要求：</strong></p>
<ol>
<li>用Python写一段程序，针对提供的图片IMG_2546.jpg，实现：</li>
</ol>
<p>①查看直方图 </p>
<p>②取反，再查看直方图 </p>
<p>③使用直方图均衡，再查看直方图 </p>
<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p>实验图片路径为： imgs&#x2F;IMG_2546.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_1_i的格式，输出四个结果，比如①的结果保存为：outputs&#x2F;exp2_1_1.jpg</p>
<p><strong>实验方案：</strong></p>
<p><strong>步骤一：查看原图直方图</strong></p>
<ul>
<li>首先，加载图片并使用OpenCV库进行读取。</li>
<li>使用Matplotlib绘制图像的直方图，这是通过计算每个颜色通道的像素强度分布来完成的。</li>
<li>保存包含原图和直方图的组合图像为 <code>outputs/exp2_1_1.jpg</code>。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ①查看原图直方图</span></span><br><span class="line">save_image_and_histogram(img, <span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Original Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：取反图像并查看直方图</strong></p>
<ul>
<li>对原始图像进行取反操作，这意味着将每个像素的颜色值变为其补色。</li>
<li>再次绘制取反后图像的直方图，并保存。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ②取反并查看直方图</span></span><br><span class="line">img_neg = cv2.bitwise_not(img)</span><br><span class="line">save_image_and_histogram(img_neg, <span class="string">&#x27;Negative Image&#x27;</span>, <span class="string">&#x27;Negative Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：直方图均衡化并查看直方图</strong></p>
<ul>
<li>将图像从BGR色彩空间转换为YUV色彩空间。</li>
<li>对Y通道（亮度）进行直方图均衡化，这能改善图像的对比度。</li>
<li>再次绘制直方图均衡化后图像的直方图，并保存。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ③直方图均衡化并查看直方图</span></span><br><span class="line">img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span><br><span class="line">img_yuv[:,:,<span class="number">0</span>] = cv2.equalizeHist(img_yuv[:,:,<span class="number">0</span>])</span><br><span class="line">img_histeq = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)</span><br><span class="line">save_image_and_histogram(img_histeq, <span class="string">&#x27;Histogram Equalization&#x27;</span>, <span class="string">&#x27;Eq Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：精确提取文本区域</strong></p>
<ul>
<li>考虑到文本可能因拍摄角度而不完全水平，我应用了一个旋转变换，使文本尽可能地水平以便裁剪。</li>
<li>设置旋转中心为图像中心，并指定旋转角度（在这里是-10度）。这个角度可能需要根据具体图片进行微调。</li>
<li>应用旋转后，根据旋转后的图像内容，手动确定“爱丁堡花园”文本的精确位置并进行裁剪。</li>
<li>最后，将旋转和裁剪后的区域保存为 <code>outputs/exp2_1_4.jpg</code>，这是仅包含目标文本区域的图片。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ④仅保留“爱丁堡花园”部分</span></span><br><span class="line"><span class="comment"># 获取图像尺寸用于计算旋转中心</span></span><br><span class="line">rows, cols, _ = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置旋转矩阵，中心点为图像中心，旋转角度为-10度，缩放因子为1</span></span><br><span class="line">M = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), -<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转图像</span></span><br><span class="line">rotated_img = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在旋转后的图像中确定“爱丁堡花园”文字的大致位置</span></span><br><span class="line">img_crop = rotated_img[<span class="number">550</span>:<span class="number">630</span>, <span class="number">600</span>:<span class="number">910</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存剪裁后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>exp2_1_4.jpg&#x27;</span>, img_crop)</span><br></pre></td></tr></table></figure></div>



<p><strong>实验结果：</strong></p>
<p> ①查看直方图 </p>
<img    
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show01.png"
                      alt="实际输出"  
                >

<p>②取反，再查看直方图 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show02.png"
                      alt="实际输出"  
                >

<p>③使用直方图均衡，再查看直方图 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show03.png"
                      alt="实际输出"  
                >

<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show04.png"
                      alt="实际输出"
                ></p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p><strong>实验要求：</strong></p>
<p>人脸1.jpg、2.jpg、3.jpg、4.jpg进行滤波等操作实现类似美图秀秀磨皮功能，并对比磨皮前后直方图变化。</p>
<p>实验图片路径为： imgs&#x2F;1.jpg imgs&#x2F;2.jpg imgs&#x2F;3.jpg imgs&#x2F;4.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_2_i的格式，输出四个结果，比如结果保存为：outputs&#x2F;exp2_2_1.jpg</p>
<p><strong>实验方案：</strong></p>
<p>通过应用双边滤波器对给定的人脸图像进行磨皮处理，然后对比处理前后图像的直方图变化。双边滤波器是一种非线性的滤波方法，它可以在平滑图像噪声的同时保留边缘信息，因此特别适合于图像美化处理。在Python中，可以使用OpenCV库中的<code>bilateralFilter</code>函数来实现这一操作。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用双边滤波器进行磨皮</span></span><br><span class="line">smoothed = cv2.bilateralFilter(image, d=<span class="number">9</span>, sigmaColor=<span class="number">75</span>, sigmaSpace=<span class="number">75</span>)</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>d</code>表示滤波器的直径，<code>sigmaColor</code>表示颜色空间的标准差，<code>sigmaSpace</code>表示坐标空间的标准差。这些参数决定了滤波器平滑图像的程度。</p>
<p>直方图的对比通过计算原图像和磨皮后图像的颜色直方图，并用不同颜色的线表示出来。这一过程可以直观地观察磨皮效果对图像色彩分布的影响。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算直方图并绘制</span></span><br><span class="line">hist_original = cv2.calcHist([original], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_smoothed = cv2.calcHist([smoothed], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(hist_original, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.plot(hist_smoothed, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;Smoothed&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>实验结果：</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show10.png"
                      alt="原始图片"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show11.png"
                      alt="实际输出"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show12.png"
                      alt="实际输出"  
                >

<p><strong>图1的分析</strong></p>
<p>原始图像和经过双边滤波处理后的图像在直方图上差别不大。这表明图像的磨皮效果较为自然，没有过度平滑，同时保持了原图的色彩特征。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show20.png"
                      alt="原始图片"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show21.png"
                      alt="实际输出"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show22.png"
                      alt="实际输出"  
                >

<p><strong>图2的分析</strong></p>
<p>可以看到在某些颜色通道中，经过滤波处理后的直方图在峰值附近略微平滑，但整体色彩分布的变化不是特别显著。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show30.png"
                      alt="原始图片"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show31.png"
                      alt="实际输出"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show32.png"
                      alt="实际输出"  
                >

<p><strong>图3的分析</strong></p>
<p>滤波后图像的直方图在低亮度区域有了平滑，说明磨皮处理降低了图像中的暗部噪声。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show40.png"
                      alt="原始图片"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show41.png"
                      alt="实际输出"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show42.png"
                      alt="实际输出"  
                >

<p><strong>图4的分析</strong></p>
<p>图像的直方图曲线在整体上变得更加平滑，尤其是在亮度较高区域的变化更为明显。这可能意味着图像亮部的细节被稍微抑制，从而减少了噪声并增强了整体的视觉效果。</p>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p><strong>实验要求：</strong></p>
<p> 将Sobel算子编码到pytorch卷积核中，并用编码的卷积核对图像100_3228.jpg执行卷积操作，输出结果（水平梯度图像、垂直梯度图像和梯度幅值图像），理解卷积操作与空间域滤波的关系。</p>
<p>实验图片路径为： imgs&#x2F;100_3228.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_3_i的格式，输出结果 比如结果保存为：outputs&#x2F;exp2_3_1.jpg</p>
<p><strong>实验方案：</strong></p>
<p><strong>步骤一：读取和预处理图像</strong></p>
<ul>
<li>读取图像<code>100_3228.jpg</code>。</li>
<li>将图像转换为灰度格式以准备进行Sobel边缘检测。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img = transform(image)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：定义Sobel卷积核</strong></p>
<ul>
<li>定义Sobel卷积核<code>sobel_x</code>和<code>sobel_y</code>以检测水平和垂直边缘。</li>
<li>这些卷积核分别能够捕捉图像在水平和垂直方向上的梯度信息。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sobel_x = torch.Tensor([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">sobel_y = torch.Tensor([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：配置卷积层并执行卷积</strong></p>
<ul>
<li>配置卷积层以使用Sobel算子。</li>
<li>不使用偏置，因为在这种滤波操作中不需要。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">conv_x = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_y = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_x.weight.data = sobel_x</span><br><span class="line">conv_y.weight.data = sobel_y</span><br></pre></td></tr></table></figure></div>

<ul>
<li>应用Sobel算子于图像以得到水平和垂直梯度。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_x = conv_x(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br><span class="line">img_y = conv_y(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：计算梯度幅值</strong></p>
<ul>
<li>结合水平和垂直梯度以计算梯度幅值，这能够显示图像中边缘的整体强度。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_magnitude = torch.sqrt(img_x**<span class="number">2</span> + img_y**<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤五：执行阈值化处理</strong></p>
<ul>
<li>通过设置阈值，去除噪声并突出边缘。</li>
<li>阈值化后的结果只保留较强的边缘。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">threshold = img_magnitude.mean() * <span class="number">0.5</span></span><br></pre></td></tr></table></figure></div>

<p><strong>步骤六：可视化与保存结果</strong></p>
<ul>
<li>保存水平和垂直梯度图像，以及梯度幅值图像。</li>
<li>使用<code>matplotlib</code>对图像进行可视化。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">visualize_and_save(img_x_thresholded, <span class="string">&#x27;Horizontal Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_1.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_y_thresholded, <span class="string">&#x27;Vertical Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_2.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_magnitude, <span class="string">&#x27;Gradient Magnitude&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>实验结果：</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../images/图像处理与分析——实验二：空间域的图像增强/attachment_show50.png"
                      alt="原始图片"  
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show51.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show52.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show53.png"
                      alt="实际输出"
                ></p>
<ol>
<li><strong>水平梯度图像</strong>: 这张图像展示了原始图像中沿水平方向边缘的强度。在水平梯度图中，垂直边缘（如山和建筑物尖顶的轮廓）被突出显示。由于Sobel算子在水平方向上捕捉垂直边缘，所以图像中明显的垂直线条和特征在这里以较亮的像素显示出来，而水平边缘则不明显或显得较暗。</li>
<li><strong>垂直梯度图像</strong>: 与水平梯度图相对，这张图显示了沿垂直方向的边缘强度。在垂直梯度图中，水平边缘（如屋顶的边缘，建筑物所在地平缓处等等）更为明显。Sobel算子在垂直方向上识别水平边缘，因此图像中水平线条和特征在这张图上以亮像素呈现。</li>
<li><strong>梯度幅度图像</strong>: 此图像结合了水平和垂直梯度的信息，提供了边缘总体强度的视图。在梯度幅度图中，所有边缘，无论其方向如何，都以亮度的形式展现，其中亮度越强表示梯度幅度越大。这张图是通过计算水平梯度和垂直梯度在每个像素点的矢量和的幅度得到的。它提供了关于图像边缘强度最完整的视图，显示了所有明显边缘的位置。</li>
</ol>
<p><strong>实验总结：</strong></p>
<p>在本次实验中，我利用Python探索了图像处理中的空间域增强技术。实验的目标是通过对特定图像进行处理，以理解和应用直方图分析、图像取反、直方图均衡化以及卷积操作在图像增强和边缘检测中的作用。以下是本实验的关键发现和总结：</p>
<p><strong>直方图分析和图像取反</strong></p>
<ul>
<li>我观察了原始图像的直方图，并通过图像取反来了解亮度分布的变化。取反操作将图像中的亮区域变暗，暗区域变亮，直方图也相应地发生反转。</li>
</ul>
<p><strong>直方图均衡化</strong></p>
<ul>
<li>通过将图像转换到YUV色彩空间并对Y通道应用直方图均衡化，我显著提高了图像的对比度。直方图均衡化后的结果使得亮度分布更加均匀，从而增强了图像中的细节。</li>
</ul>
<p><strong>图像旋转和裁剪</strong></p>
<ul>
<li>通过旋转和裁剪操作，我成功地提取了图像中“爱丁堡花园”部分。这个过程涉及到对图像的几何变换，展示了图像处理中的区域选择技术。</li>
</ul>
<p><strong>滤波和磨皮效果</strong></p>
<ul>
<li>我对人脸图像应用了双边滤波器，实现了类似美图秀秀的磨皮效果。磨皮处理后，图像的直方图在低亮度区域变得更加平滑，显示了噪声的减少和肤色的均匀性提升。</li>
</ul>
<p><strong>Sobel边缘检测</strong></p>
<ul>
<li>将Sobel算子编码进PyTorch卷积核中并对图像进行处理，我得到了水平和垂直梯度图像以及梯度幅值图。这一过程说明了卷积操作如何作为空间域滤波器来检测图像中的边缘，是图像处理中边缘检测技术的一个经典例子。</li>
</ul>
<p>通过以上实验步骤，我加深了对图像增强技术的理解，特别是在如何利用不同的空间域滤波技术来改善视觉效果方面。实验结果表明，这些技术不仅可以增强图像的视觉质量，还可以为后续的图像分析工作提供更好的基础。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
</search>
