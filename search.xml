<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺1</title>
    <url>/2023/11/19/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-1-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li>使用Photoshop制作了网页的主界面视图UI效果示意图和LOGO</li>
<li>按照设计计划制作了网站HTML页面</li>
<li>展示GitHub当日代码&#x2F;文档签入记录：</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/1.png"
                      alt="1"
                ></li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>继续美化前端，思考更多前端功能，配合后端</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>添加更多便捷功能，提升用户体验</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>前端各种插件按钮的位置大小调整，排列方式和外观，页面缩放引起的组件排列等等的调试问题</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用，加强了web前端的知识</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>了解学会使用fork，学习了解如何搭建web项目和配置，完成了部分前端任务。</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/2.png"
                      alt="2"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>与后端结合，实现前端的图像显示和页面优化。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>将前端与后端结合，对页面进一步美化。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>对项目的规划还不够了解，遇到一些技术问题需要加强合作。</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用，学会用js设计网页。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学习了fork的使用，学习并尝试实现了CNN自动编码器的基本框架，训练模型中。</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/3.png"
                      alt="3"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>继续修改错误，继续调试CNN编码器训练。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>将CNN编码器训练完成，争取得到输出结果。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>错误很多，不熟悉用java编写CNN，训练过程中的错误还没有得到修改，正在学习和修改中。</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会使用fork，了解了nd4j库的使用及CNN基本结构。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学会fork的使用，学习了解如何搭建web项目的系统框架，制定初步的计划</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/4.png"
                      alt="4"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>搭建好整体系统框架</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>搭建后台接受前端传来的图片，调用训练好的神经网络模型，返回处理好的图片给前端</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>对项目的规划还不够清晰，对大部分运用到的知识不够熟练</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用以及多人协同完成一个项目</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学习了fork的使用，在git上创建了仓库</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/5.png"
                      alt="5"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>系统架构搭建，搭建好整体的Web项目的系统框架，使用Django框架来实现开发。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>搭建后台，接受前端传来的图片url，同时以python脚本的形式调用训练好的神经网络模型，再将处理好的图片返回给前端。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>没有学习过python，不太了解后端的工作，不了解Django如何调用训练好的模型</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学习了基本的git和python知识，对于后续调用训练好的模型还比较困惑</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li><p>Logo<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/6.png"
                      alt="6"
                ></p>
</li>
<li><p>主界面UI初版示意图<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/7.png"
                      alt="7"
                ></p>
</li>
<li><p>网站主页面<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/8.png"
                      alt="8"
                ></p>
</li>
<li><p>点击图片放大显示功能<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/9.png"
                      alt="9"
                ></p>
</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/10.png"
                      alt="10"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.11.19 14:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室303</p>
</li>
<li><p><strong>内容</strong>：</p>
<ul>
<li><h4 id="团队进展"><a href="#团队进展" class="headerlink" title="团队进展"></a>团队进展</h4><ul>
<li><strong>前端开发</strong>：<ul>
<li>完成了网页主界面视图UI和LOGO的制作，以及网站HTML页面的初步设计。</li>
<li>已实现部分前端功能，并对前端进行初步美化。</li>
</ul>
</li>
<li><strong>后端开发</strong>：<ul>
<li>着手搭建Web项目的系统框架。</li>
<li>初步学习并尝试实现CNN自动编码器的基础框架，模型训练正在进行中。</li>
</ul>
</li>
<li><strong>项目管理和协调</strong>：<ul>
<li>团队成员均已学习使用fork进行协作。</li>
<li>项目的GitHub代码和文档签入记录展示了目前的进展。</li>
</ul>
</li>
</ul>
<h4 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h4><ul>
<li><strong>前端开发</strong>：<ul>
<li>继续改善前端设计和用户体验，增加更多便捷功能。</li>
<li>将前端与后端结合，优化图像显示和页面设计。</li>
</ul>
</li>
<li><strong>后端开发</strong>：<ul>
<li>继续完善CNN编码器的训练，解决遇到的技术难题。</li>
<li>完成系统框架的搭建，特别是后台处理模块，以实现前端图像的接收和处理。</li>
</ul>
</li>
<li><strong>团队协作</strong>：<ul>
<li>加强团队成员间的沟通和协作，尤其是在项目规划和技术问题解决方面。</li>
<li>持续学习和掌握新知识和工具。</li>
</ul>
</li>
</ul>
<h4 id="当前挑战"><a href="#当前挑战" class="headerlink" title="当前挑战"></a>当前挑战</h4><ul>
<li>团队成员对项目规划和所用技术不够熟悉，需要加强学习和协作。</li>
<li>在CNN编码器的训练和后端开发中遇到了一些技术难题，正在寻求解决方案。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺2</title>
    <url>/2023/12/18/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-2-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>前端微调，使导航栏固定在屏幕，删除冗余按钮，使下拉菜单正常实现，进行了UI和背景调整的美化工作</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化滚动式前端，添加轮转图片，设计网页介绍UI和按钮UI等等</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>动画效果还未实现</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端动效以及美化，阅读了相关案例代码</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>更改页面结构为滑动式长页面，增添了模态框，增添了轮播图片动效</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>修改UI里的一些新的bug，完成前后端的对接工作，丰富美化页面</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入，模型训练困难，轮播图总是自己放大，动画效果加载失败</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端动效美化知识，阅读了相关代码</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>参考老师的代码，实现了CBDnet模型进行去噪，模型训练完成。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>协助负责后端的同学进行模型的调用。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>采用CNN模型，总是会出现图片部位丢失的错误，所以改用CBDnet模型。由于模型是用GPU运行的，我只能在同学的电脑上运行</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了CBDnet的有关知识。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>辅助训练备选模型，挑选出效果最好的模型，解决图片上传报错的问题</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步实现图片的传输，完成前后端对接工作</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型训练的效果图存在各种各样的问题，图片的传输依旧有点混乱</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解到不同的路径写法，学习到不同路径对图片传输的影响</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>辅助训练模型，编写后端接口</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/5.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成后端任务，实现图片的传输与保存</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>训练的模型去噪效果不是很好，图片太过模糊，并且对图片格式要求很严格</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了python的一些基础知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>网站前端改为滚动式，美化了界面，结构重新设计</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/6.png"
                      alt="6"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/7.png"
                      alt="7"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/8.png"
                      alt="8"
                ></li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/10.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.17 19:00</p>
</li>
<li><p><strong>地点</strong>：腾讯会议</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-前端开发进展"><a href="#1-前端开发进展" class="headerlink" title="1. 前端开发进展"></a>1. 前端开发进展</h4><ul>
<li><strong>界面重设计</strong>：网站前端已改为滚动式，为用户提供了更流畅的浏览体验。</li>
<li><strong>UI&#x2F;UX改善</strong>：对用户界面和体验进行了显著的美化和优化，使网站更加吸引用户。</li>
<li><strong>动效和微调</strong>：实现了一些基本的动画效果，对导航栏、下拉菜单等元素进行了微调，以提高页面的整体美观性和用户体验。</li>
</ul>
<h4 id="2-后端开发与模型训练"><a href="#2-后端开发与模型训练" class="headerlink" title="2. 后端开发与模型训练"></a>2. 后端开发与模型训练</h4><ul>
<li><strong>模型选择与训练</strong>：经过对比，选择了CBDnet模型进行去噪处理，模型训练有初步成果。</li>
<li><strong>后端接口与集成</strong>：开发了后端接口，正在努力实现前后端的顺畅对接，以及图片的有效传输与保存。</li>
</ul>
<h4 id="3-遇到的挑战"><a href="#3-遇到的挑战" class="headerlink" title="3. 遇到的挑战"></a>3. 遇到的挑战</h4><ul>
<li><strong>模型效果与优化</strong>：目前模型去噪效果存在一些问题，如图片模糊、格式要求严格等，团队正在积极寻找解决方案。</li>
<li><strong>动画效果实现</strong>：一些复杂的动画效果实现上存在困难，团队成员正在学习相关技术以改善这一点。</li>
</ul>
<h4 id="4-收获与展望"><a href="#4-收获与展望" class="headerlink" title="4. 收获与展望"></a>4. 收获与展望</h4><ul>
<li><strong>技术提升</strong>：通过本项目，团队成员在前端设计、后端开发和模型训练方面都有了显著的成长。</li>
<li><strong>团队协作</strong>：加强了团队间的沟通和协作，通过共同解决问题增强了团队凝聚力。</li>
</ul>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul>
<li>本次Beta冲刺阶段，团队成员共同努力，取得了显著的进步。尽管面临诸多挑战，但团队通过有效的沟通和协作，不断优化项目，朝着最终目标稳步前进。未来，团队将继续致力于解决剩余的技术难题，并期待在项目最终阶段呈现出更加完善的成果。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender——建模/动画作品</title>
    <url>/2023/07/15/Blender%E5%BB%BA%E6%A8%A1-%E5%8A%A8%E7%94%BB%E4%BD%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="三兄弟建模（几何）"><a href="#三兄弟建模（几何）" class="headerlink" title="三兄弟建模（几何）"></a>三兄弟建模（几何）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/1_%E4%B8%89%E5%85%84%E5%BC%9F.png"
                      alt="1_三兄弟"
                ></p>
<h3 id="积木建模-动画（动画）"><a href="#积木建模-动画（动画）" class="headerlink" title="积木建模&#x2F;动画（动画）"></a>积木建模&#x2F;动画（动画）</h3><a class="button center large" href='https://www.bilibili.com/video/BV15K421x7aj/?share_source=copy_web' title='【Blender积木】'><i class='fa-solid fa-play-circle'></i> 【Blender积木】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1701692717&bvid=BV15K421x7aj&cid=1463230031&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/2_%E7%A7%AF%E6%9C%A8.png"
                      alt="2_积木"
                ></p>
<h3 id="金币基站建模（金属光泽材质）"><a href="#金币基站建模（金属光泽材质）" class="headerlink" title="金币基站建模（金属光泽材质）"></a>金币基站建模（金属光泽材质）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/3_%E9%87%91%E5%B8%81%E5%9F%BA%E7%AB%99.png"
                      alt="3_金币基站"
                ></p>
<h3 id="跑车建模-动画（复杂图形建模与循环动画）"><a href="#跑车建模-动画（复杂图形建模与循环动画）" class="headerlink" title="跑车建模&#x2F;动画（复杂图形建模与循环动画）"></a>跑车建模&#x2F;动画（复杂图形建模与循环动画）</h3><a class="button center large" href='https://www.bilibili.com/video/BV1Mj421f71M/?share_source=copy_web' title='【Blender跑车】'><i class='fa-solid fa-play-circle'></i> 【Blender跑车】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1651706227&bvid=BV1Mj421f71M&cid=1463231676&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E8%BD%A6%E5%A4%B4.png"
                      alt="跑车车头"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E7%89%B9%E5%86%992.png"
                      alt="跑车特写2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E4%BE%A7%E9%9D%A2.png"
                      alt="跑车侧面"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E9%A1%B6%E9%83%A8.png"
                      alt="跑车顶部"
                ></p>
<h3 id="荧光树桩建模（半透明材质）"><a href="#荧光树桩建模（半透明材质）" class="headerlink" title="荧光树桩建模（半透明材质）"></a>荧光树桩建模（半透明材质）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/5_%E8%8D%A7%E5%85%89%E6%A0%91%E6%A1%A9.png"
                      alt="5_荧光树桩"
                ></p>
<h3 id="子弹时间建模-动画（物理效果模拟）"><a href="#子弹时间建模-动画（物理效果模拟）" class="headerlink" title="子弹时间建模&#x2F;动画（物理效果模拟）"></a>子弹时间建模&#x2F;动画（物理效果模拟）</h3><a class="button center large" href='https://www.bilibili.com/video/BV1xW421c7ux/?share_source=copy_web' title='【Blender子弹时间】'><i class='fa-solid fa-play-circle'></i> 【Blender子弹时间】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1851675396&bvid=BV1xW421c7ux&cid=1463235980&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9-%E5%B0%81%E9%9D%A2.jpg"
                      alt="子弹-封面"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9%E6%85%A2%E5%8A%A8%E4%BD%9C%E6%99%AF%E6%B7%B1.png"
                      alt="子弹慢动作景深"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9%E6%99%AF%E6%B7%B1.png"
                      alt="子弹景深"
                ></p>
<h3 id="离散猴头（几何节点）"><a href="#离散猴头（几何节点）" class="headerlink" title="离散猴头（几何节点）"></a>离散猴头（几何节点）</h3><a class="button center large" href='https://www.bilibili.com/video/BV1Uj421Z7Nc/?share_source=copy_web' title='【Blender猴头】'><i class='fa-solid fa-play-circle'></i> 【Blender猴头】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1651642308&bvid=BV1Uj421Z7Nc&cid=1463239128&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Blender</category>
        <category>建模/动画</category>
      </categories>
      <tags>
        <tag>Blender</tag>
        <tag>建模</tag>
        <tag>动画</tag>
        <tag>作品集</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺2</title>
    <url>/2023/11/26/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-2-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>优化了前端显示，修复了不同屏幕分辨率下的显示错误bug</li>
<li>将Java项目转为Python的flask项目</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/1.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>配合后端接口，加入类似锁的机制防止卡死</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>添加更多便捷功能，提升用户体验，继续美化前端，思考更多前端功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>页面缩放引起的组件遮挡消失，滑动条显示问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对前端的理解更深入，学会了pycharm转换更改项目所用的Python版本，对前后端对接还不太清楚</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>学习了python，安装了pycharm，并配置了python。更新了前端网页，学习前后端交互相关知识。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/2.png"
                      alt="2"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化页面设计，配合后端交互。</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>提升用户体验，继续美化页面，实现图片的流转。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>pycharm打开不了网页，python安装失败。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了python，前后端等知识。疑问是现在的训练模型需要的是一个数据集，如何将单个图片放到文件夹中。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>决定使用pycharm完成项目，配置pycharm环境，完成加噪并去噪的CNN自动编码器。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/3.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>尝试去掉加噪部分，对一张本身带噪声的图片进行去噪。</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>完成模型训练并接入后端</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>python版本过新，导致TensorFlow模块不能安装，只能重新安装3.9版本。数据集下载失败，只能通过本地下载，再用路径读取。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对CNN模型有了更多认识，学会了pycharm的使用。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>配置pycharm环境，了解接口文档的写法，学习前后端交互知识</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/4.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>将模型接入后端，写接口文档，完成前后端交互</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>前后端交互，与模型的数据对接</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>在pycharm中因为版本问题下载框架失败，已解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>大概了解了接口文档的写法,简单学习前后端交互 ，对图片的传输和对接过程还是不太清楚</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>尝试用pycharm将模型接入后端，并用apifox写接口文档</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/5.png"
                      alt="5"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>将模型接入后端并继续完成接口文档</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>与前端对接</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>python版本问题，将模型接入后端时遇到了一些问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了简单的后端知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>正常网页分辨率显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
<li>窄分辨率显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/7.png"
                      alt="7"
                >编辑</li>
<li>数据集的模型训练</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/8.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/9.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.11.26 16:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室304</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目进展概况"><a href="#1-项目进展概况" class="headerlink" title="1. 项目进展概况"></a>1. 项目进展概况</h4><ul>
<li>讨论了团队成员在项目中的整体进展情况，包括前端显示优化、项目从Java转换到Python Flask的进展，以及前后端交互的学习和实现。</li>
<li>着重强调了对不同屏幕分辨率的适配问题，确保网页在不同设备上均能正常显示。</li>
</ul>
<h4 id="2-技术难点和解决方案"><a href="#2-技术难点和解决方案" class="headerlink" title="2. 技术难点和解决方案"></a>2. 技术难点和解决方案</h4><ul>
<li>分析了在项目开发中遇到的技术难题，如页面缩放导致的组件遮挡和滑动条显示问题，以及Python版本兼容性问题。</li>
<li>讨论了可能的解决方案，包括技术选型调整、版本兼容性检查，以及增强团队成员之间的技术交流。</li>
</ul>
<h4 id="3-后续计划和任务分配"><a href="#3-后续计划和任务分配" class="headerlink" title="3. 后续计划和任务分配"></a>3. 后续计划和任务分配</h4><ul>
<li>计划了接下来的工作，包括继续优化前端页面设计，加强前后端的数据交互，以及将机器学习模型更好地集成到后端。</li>
<li>对剩余任务进行了详细的分配，确保每位团队成员都清楚自己的责任和接下来的工作重点。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺1</title>
    <url>/2023/12/10/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-1-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>优化前端格式和排列表现</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步优化前端功能与界面，设计UI，实现新增的转换按钮的功能（与后端对接）</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>组件扩展使整体屏幕分辨率改变出现bug，调整组件位置已经禁用横向滚动条之后解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对JavaScript与HTML理解更好，对前端布局理解加深</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>更改了顶部导航栏，重新安排了按钮的位置，修改了按钮的颜色。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端的对接工作，将模型接入传送过程，实装相应的按钮和进度条的功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入，模型训练困难</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习前端，学习python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>修改模型，实现输入图片与输出图片颜色一致；增加训练轮数和卷积层数，以减请轻去噪后的模糊情况。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续修改模型，同时学习CNN编码器相关知识，寻求更好的模型用于图像去噪。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>电脑没有独显，模型训练很慢，而且图像模糊还没有得到解决。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对CNN编码器的了解更多，认识了很多去噪算法。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>协助模型训练的同学进行模型训练,修改部分细节使图片更适应模型</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/4.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成模型训练及后端传输图片</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>之前的模型训练效果不好，重新开始训练，模型和前端的交接遇到点问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解了模型训练的一些知识</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>协助模型训练的同学进行模型训练</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成模型训练及后端传输图片</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>之前的模型训练效果不好，重新开始训练</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解了模型训练的一些知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>增加及修改加了顶部菜单栏的组件</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/10.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.10 20:00</p>
</li>
<li><p><strong>地点</strong>：腾讯会议</p>
</li>
<li><p><strong>内容</strong>：</p>
<h3 id="进展回顾"><a href="#进展回顾" class="headerlink" title="进展回顾"></a>进展回顾</h3><ol>
<li><strong>前端开发</strong>:<ul>
<li>在前端方面取得了重要进展。包括对前端格式的优化、排列表现的改善、顶部导航栏的重新设计，以及按钮颜色的调整。</li>
<li>计划进一步增强前端功能和界面设计，特别是实现新的转换按钮功能，并与后端紧密对接。</li>
</ul>
</li>
<li><strong>模型训练与后端开发</strong>:<ul>
<li>模型训练上，实现了输入输出图片颜色一致性的改进，并通过增加训练轮数和卷积层数减轻了去噪后的模糊情况。</li>
<li>后续计划着重于模型的进一步改进，特别是针对CNN编码器的深入学习和应用，以及模型和前端的有效整合。</li>
</ul>
</li>
</ol>
<h3 id="遇到的挑战"><a href="#遇到的挑战" class="headerlink" title="遇到的挑战"></a>遇到的挑战</h3><ul>
<li>团队面临的主要挑战包括前端组件扩展导致的bug、模型训练的效率问题以及前后端的有效整合。</li>
</ul>
<h3 id="收获与展望"><a href="#收获与展望" class="headerlink" title="收获与展望"></a>收获与展望</h3><ul>
<li>成员们在JavaScript、HTML、Python语言及前后端交互方面有了更深入的理解和应用。</li>
<li>对CNN编码器和去噪算法的认识更加深入，为未来的开发提供了坚实的基础。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来看，每位成员都在其专长领域作出了积极贡献。虽然面临一些技术挑战，但团队成员通过有效合作，已经取得了显著的进展，并对未来的工作有了清晰的规划和方向。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GUI——音乐播放器</title>
    <url>/2023/05/17/Java-GUI-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<h2 id="a-软件功能说明"><a href="#a-软件功能说明" class="headerlink" title="(a)软件功能说明"></a>(a)软件功能说明</h2><p>①线上歌单的获取和保存，加载进度条</p>
<p>②本地歌单的创建和保存（包括歌单封面选择，音乐的添加和删除），本地歌单的修改（封面，重命名），删除歌单</p>
<p>③播放器功能，双击选中歌曲播放（默认循环播放），停止，上一首，下一首，随机播放，顺序播放，单曲循环</p>
<p>④音乐播放进度条，当前播放的显示</p>
<h2 id="b-软件架构设计"><a href="#b-软件架构设计" class="headerlink" title="(b)软件架构设计"></a>(b)软件架构设计</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png"
                      alt="软件架构"
                ></p>
<h2 id="c-软件模块设计与实现"><a href="#c-软件模块设计与实现" class="headerlink" title="(c)软件模块设计与实现"></a>(c)软件模块设计与实现</h2><h3 id="①面板GUI-gui包-："><a href="#①面板GUI-gui包-：" class="headerlink" title="①面板GUI(gui包)："></a>①面板GUI(gui包)：</h3><p>将五个小面板链接进主面板里，播放器的功能按钮链接进MusicPlayerBlock，互相需要调用的也作为对象传入了。</p>
<h4 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MusicPlayerBlock</span> <span class="variable">musicPlayerBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicPlayerBlock</span>(musicSheets);</span><br><span class="line"></span><br><span class="line"><span class="type">MusicSheetDisplayBlock</span> <span class="variable">musicSheetDisplayBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicSheetDisplayBlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">SharedMusicSheetBlock</span> <span class="variable">sharedMusicSheetBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedMusicSheetBlock</span>(musicSheets, musicPlayerBlock, musicSheetDisplayBlock);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalMusicSheetBlock</span> <span class="variable">localMusicSheetBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalMusicSheetBlock</span>(musicSheets, musicPlayerBlock, musicSheetDisplayBlock);</span><br><span class="line"></span><br><span class="line"><span class="type">MusicSheetManagementBlock</span> <span class="variable">musicSheetManagementBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicSheetManagementBlock</span>(localMusicSheetBlock, sharedMusicSheetBlock);</span><br></pre></td></tr></table></figure></div>

<p>遇到的问题：这一块遇到的问题太多了，各个面板之间的互相作用，互相刷新显示，为此改了无数个版本，好在最后算是形成了相对满意的样子，各个面板直接也没有明显bug。关键代码太多在此只写了实例化的代码展现每个面板之间的联系</p>
<h3 id="②网络-httpclient包"><a href="#②网络-httpclient包" class="headerlink" title="②网络(httpclient包)"></a>②网络(httpclient包)</h3><p>详细过程：主要参考老师的代码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">其中<span class="type">JSONObject</span> <span class="variable">mumObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(jms.get(<span class="string">&quot;musicItems&quot;</span>));</span><br><span class="line">改为了<span class="type">JSONObject</span> <span class="variable">mumObj</span> <span class="operator">=</span> (JSONObject) jms.get(<span class="string">&quot;musicItems&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>解决了musicItems从线上获取为空的情况</p>
<h3 id="③-model包"><a href="#③-model包" class="headerlink" title="③(model包)"></a>③(model包)</h3><p>详细过程：Music类是music的信息的存储，包括时长，作者，歌名等信息及这些信息的获取函数。MusicSheet是歌单信息的存储及歌单信息的获取方法。主要都在NewMP3Playe里调用。</p>
<h4 id="关键代码：-1"><a href="#关键代码：-1" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Music</span><span class="params">(String filePath, String fileName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="type">AudioFile</span> <span class="variable">audioFile</span> <span class="operator">=</span> AudioFileIO.read(file);</span><br><span class="line">        <span class="type">Tag</span> <span class="variable">tag</span> <span class="operator">=</span> audioFile.getTag();</span><br><span class="line">        title = tag.getFirst(FieldKey.TITLE);</span><br><span class="line">        <span class="keyword">if</span> (title == <span class="literal">null</span> || title.isEmpty()) &#123;</span><br><span class="line">            title = fileName.replaceAll(<span class="string">&quot;\\.mp3$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        artist = tag.getFirst(FieldKey.ARTIST);</span><br><span class="line">        <span class="keyword">if</span> (artist == <span class="literal">null</span> || artist.isEmpty()) &#123;</span><br><span class="line">            artist = <span class="string">&quot;未知歌手&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        musicduration = Duration.seconds(audioFile.getAudioHeader().getTrackLength());</span><br><span class="line">        <span class="type">long</span> <span class="variable">minutes</span> <span class="operator">=</span> (<span class="type">long</span>) musicduration.toMinutes();</span><br><span class="line">        <span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> (<span class="type">long</span>) (musicduration.toSeconds() % <span class="number">60</span>);</span><br><span class="line">        duration = String.format(<span class="string">&quot;%02d:%02d&quot;</span>, minutes, seconds);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(fileName);</span><br><span class="line">        System.out.println(<span class="string">&quot;Error occurred while processing file: &quot;</span> + filePath);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 删除文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">fileToDelete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        fileToDelete.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="④-soundmaker包"><a href="#④-soundmaker包" class="headerlink" title="④(soundmaker包)"></a>④(soundmaker包)</h3><p>详细过程：实际上只有NewMP3Player实装。NewMP3Player中用来实现播放器各项按钮的功能。NewMP3Player与MusicPlayerBlock互相联系。在MusicPlayerBlock里建立显示歌单内容的表格，并设置鼠标点击监听器，通过点击获取歌单和音乐的信息。</p>
<p>NewMP3Player里有</p>
<p>playButton（播放）</p>
<p>stopButton（停止）</p>
<p>prevButton（上一首）</p>
<p>nextButton（下一首）</p>
<p>sequenceButton（顺序播放）</p>
<p>randomButton（随机播放）</p>
<p>slider（进度条）</p>
<p>loopButton（循环播放）</p>
<p>为了实现代码复用，增添了stopPlayer和musicSequence的方法。</p>
<p>双击选中歌曲，会启动播放按钮，调用playmusic方法，在playmusic里根据布尔变量来判断是否进行随机播放和单曲循环，否则默认单曲循环。在进度条里通过player.getPosition获取歌曲进度。</p>
<p>遇到的问题：在写暂停的时候遇到了很多的问题，花费了很多的时间，用playThread和contralThread来实现，但是暂停时总是会出现线程冲突的问题。最后放弃了。</p>
<p>由于播放器库没有setPosition之类的按钮，所以没有实现拖动进度条实现控制音乐进度。</p>
<h4 id="关键代码：-2"><a href="#关键代码：-2" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">playThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">while</span> (!isStopped) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!isPaused &amp;&amp; player != <span class="literal">null</span>) &#123;</span><br><span class="line">                          player.play();</span><br><span class="line">                          <span class="keyword">if</span> (isLooping &amp;&amp; player.isComplete()) &#123;</span><br><span class="line">                              <span class="comment">// 当音乐播放完成且isLooping为true时，重新开始播放当前音乐</span></span><br><span class="line">                              <span class="keyword">if</span>(isLooping) &#123;</span><br><span class="line">                                  player.close();</span><br><span class="line">                                  <span class="type">BufferedInputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> </span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">                                  player = <span class="keyword">new</span> <span class="title class_">Player</span>(buffer);</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">else</span> &#123;</span><br><span class="line">                                  sequenceButton.doClick();</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (player != <span class="literal">null</span>) &#123;</span><br><span class="line">                      player.close();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      playThread.start();</span><br></pre></td></tr></table></figure></div>

<p>实现每次播放音乐都创建一个新的音乐线程，不与主线程冲突。</p>
<h2 id="d-软件界面及功能展示"><a href="#d-软件界面及功能展示" class="headerlink" title="(d)软件界面及功能展示"></a>(d)软件界面及功能展示</h2><h3 id="开启后的界面"><a href="#开启后的界面" class="headerlink" title="开启后的界面"></a><strong>开启后的界面</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%BC%80%E5%A7%8B%E7%95%8C%E9%9D%A2.png"
                      alt="开启后的界面"
                ></p>
<h3 id="线上功能展示"><a href="#线上功能展示" class="headerlink" title="线上功能展示"></a><strong>线上功能展示</strong></h3><p>（如果服务器连接失败20秒后会进入本地模式（共享歌单无信息））<strong>：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95.png"
                      alt="加载歌单"
                ></p>
<p>单击共享歌单列表之后右侧歌曲列表面板会刷新，右侧歌单封面，歌单名字，创建者和创建时间都会显示下方会显示歌单加载进度条，歌曲会一首一首显示出来（只要显示就可以双击播放），如果有未下载完成的损坏MP3文件（如上次下载到一半关闭了程序导致）的会自检后删除损坏文件重新下载</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E8%BF%9B%E5%BA%A6%E6%9D%A1.png"
                      alt="加载歌单进度条"
                ></p>
<p>加载进度条会随着歌曲一首首显示实时更新</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E6%8F%90%E7%A4%BA.png"
                      alt="加载歌单提示"
                ></p>
<p>若在歌单加载过程中点击其他歌单或本地歌单添加按钮会弹出提示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E5%AE%8C%E6%88%90.png"
                      alt="加载歌单完成"
                ></p>
<p>歌单加载完成后会提示“双击歌曲开始播放”</p>
<h3 id="线下功能展示"><a href="#线下功能展示" class="headerlink" title="线下功能展示"></a><strong>线下功能展示</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%96%B0%E5%BB%BA%E6%AD%8C%E5%8D%95.png"
                      alt="新建歌单"
                ></p>
<p>为本地歌单提供两个互动按钮</p>
<h4 id="“-”新建歌单"><a href="#“-”新建歌单" class="headerlink" title="“+”新建歌单"></a>“+”新建歌单</h4><p>点击后弹出创建歌单面板，输入歌单名后弹出下一个详细编辑面板</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%96%B0%E5%BB%BA%E6%AD%8C%E5%8D%95.png"
                      alt="新建歌单"
                ></p>
<p>在此弹窗歌单依然可以修改名字，还可以选择歌单封面（若不选择则为默认的播放器logo），添加&#x2F;删除音乐</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E9%80%89%E6%8B%A9%E6%AD%8C%E5%8D%95%E5%B0%81%E9%9D%A2%E3%80%81%E9%9F%B3%E4%B9%90.png"
                      alt="选择歌单封面、音乐"
                ></p>
<p>从电脑文件中选择封面和MP3类型的音乐</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E9%80%89%E6%8B%A9%E6%AD%8C%E5%8D%95%E5%B0%81%E9%9D%A2%E3%80%81%E9%9F%B3%E4%B9%90%E5%AE%8C%E6%88%90.png"
                      alt="选择歌单封面、音乐完成"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%9C%AC%E5%9C%B0%E6%AD%8C%E5%8D%95%E6%B7%BB%E5%8A%A0%E5%AE%8C%E6%88%90.png"
                      alt="本地歌单添加完成"
                ></p>
<p>点击保存后在本地歌单面板显示刚刚创建的面板，点击后效果与线上歌单一致</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/-%E6%8C%89%E9%92%AE.png"
                      alt="-按钮"
                ></p>
<h4 id="“-”编辑歌单"><a href="#“-”编辑歌单" class="headerlink" title="“-”编辑歌单"></a>“-”编辑歌单</h4><p>选中本地歌单中的某歌单后会打开编辑面板，与创建面板功能相似，不过“取消”按钮变味了“删除”，点击删除按钮后歌单从test中删除</p>
<h3 id="播放功能展示"><a href="#播放功能展示" class="headerlink" title="播放功能展示"></a><strong>播放功能展示</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8F%8C%E5%87%BB%E6%92%AD%E6%94%BE.png"
                      alt="双击播放"
                ></p>
<p>双击歌曲开始播放，播放进度条会随着歌曲推进</p>
<p>默认本歌单顺序列表循环播放</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%81%9C%E6%AD%A2%E6%92%AD%E6%94%BE.png"
                      alt="停止播放"
                ></p>
<p>点击停止会终止当前歌曲播放，播放进度条归0，“停止”按钮也会变灰为不可用状态</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%9F%E8%83%BD%E6%92%AD%E6%94%BE.png"
                      alt="功能播放"
                ></p>
<p>“下一首”点击后会直接切换到目前播放状态（顺序or随机）的下一首歌（“上一首”同理），同时播放提示栏也会实时更新显示正在播放的歌曲</p>
<p>“随机播放”参考了主流播放器的逻辑，点击后相当于给每一首歌随机赋一个id，在本次循环中都会保持这个顺序，比如歌曲1在歌曲5之后，播放到歌曲5时如果点击上一首依然是歌曲1</p>
<p>“随机播放”“顺序播放”“单曲循环”可随时切换</p>
<p>每次点击“随机播放”都会得到一个新的播放顺序</p>
<p>每次点击“顺序播放”都会得到原歌单的播放顺序</p>
<p>每次点击“单曲循环”都会让当前单曲循环播放</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>Java</category>
        <category>音乐播放器</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>Java</tag>
        <tag>GUI</tag>
        <tag>音乐播放器</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺3</title>
    <url>/2023/12/03/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-3-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>成功连接前后端，前端上传按钮点击后可以选择图片上传，上传后在前端有显示，并且通过后端将上传图片存储在了images里</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步优化前端功能与界面，实现新增的转换按钮的功能（与后端对接）</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前后端连接错误，改正script中的方法后解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对JavaScript与HTML理解更深入，对前端布局理解</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>增加了一个开始去噪的按钮，配置了ui图像，调整页面，修改按钮的颜色。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端的对接工作，将模型接入传送过程，实装相应的按钮和进度条的功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习前端，学习python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>使用训练的模型对本地图片进行去噪，对模型多次修改以达到期望效果。</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续修改模型，实现输出图片颜色与输入图片相同。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>刚开始的模型，输入输出图片颜色与原图像不一致，改过之后输入图片正确，但是输出图像不仅模糊，而且没有色彩，这个问题现在依旧没有解决。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习CNN自动编码器，学习了python语法。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>尝试获取前端图片并将其传给模型进行训练，但只完成从前端获取图片存到本地文件夹</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端对接工作，将模型接入传送过程</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>图片保存路径与预期不符，还无法连接到模型</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了一些后端相关知识，学习了python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>进行了前后端的部分对接，目前实现了从前端获取要修复的图片到本地</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/5.png"
                      alt="5"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完成前后端对接工作，实现将训练好的图片传回给前端</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前后端对接时出现问题，前端上传的图片无法保存到本地制定文件夹</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了相关的Python知识，了解前后端对接的基本工作</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>添加了转换按钮</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/10.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.3 16:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室303</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目进展概况"><a href="#1-项目进展概况" class="headerlink" title="1. 项目进展概况"></a>1. 项目进展概况</h4><ul>
<li><strong>前后端连接</strong>：成功实现了前后端的基本连接，使前端可以上传图片，后端可以接收并存储这些图片。</li>
<li><strong>界面优化</strong>：团队成员对用户界面进行了改进，增加了去噪按钮，并优化了界面的整体布局和视觉效果。</li>
<li><strong>模型训练与应用</strong>：对去噪模型进行了训练和调整，以便更好地处理上传的图片。</li>
</ul>
<h4 id="2-技术难点和解决方案"><a href="#2-技术难点和解决方案" class="headerlink" title="2. 技术难点和解决方案"></a>2. 技术难点和解决方案</h4><ul>
<li><strong>前后端对接问题</strong>：解决了前后端连接时出现的错误，主要通过调整代码和脚本实现。</li>
<li><strong>模型集成问题</strong>：正在努力将去噪模型完全集成到前后端流程中，以便实现自动处理上传的图片。</li>
<li><strong>图像处理问题</strong>：在图像去噪的模型训练中遇到了输出图像颜色和清晰度的问题，团队正在通过调整模型参数和算法来解决这些问题。</li>
</ul>
<h4 id="3-后续计划和任务分配"><a href="#3-后续计划和任务分配" class="headerlink" title="3. 后续计划和任务分配"></a>3. 后续计划和任务分配</h4><ul>
<li><strong>前端功能优化</strong>：继续提升用户界面，包括增加新的功能按钮和改进现有布局。</li>
<li><strong>模型优化与集成</strong>：继续调整和改进去噪模型，确保模型能够有效集成到整个系统中。</li>
<li><strong>前后端进一步对接</strong>：加强前后端的协同工作，确保系统的流畅运行，特别是在图像上传和处理方面。</li>
</ul>
<p>团队将继续密切协作，确保按时完成项目目标，同时解决任何新出现的技术挑战。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺3</title>
    <url>/2023/12/24/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-3-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>删除了所有冗余文件，完成了下载功能，优化了所有UI，加入了介提示等等。调整了按钮布局，添加了开发者信息，对网站流程进行了优化，可以作为正式版</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化网页介绍UI和功能等等</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>图片模型去噪完之后没有显示到前段，路径丢失与函数调用关系的调试。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端美化，以及前后端接口使用，学习了pycharm，以及前端CSS，HTML，JavaScript的知识</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>完成了前端，实现了上传显示下载等功能，增加了进度条和去噪时锁定页面的功能。 接下来的计划：继续优化模型。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>在实现按钮的过程中，出现了找不到位置的问题，之后模型运行成功，但是一直没有自动更新显示去噪后的图片。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了pycharm，学习了HTML等前端知识，探索了滚动式长页面网页的实现。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>完成CBDnet模型训练，实现图片去噪，协助负责后端的同学进行模型的调用。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化模型。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>一开始模型在只有CPU的电脑上运行会失败，后来在学长的帮助下将这个问题成功解决。还有就是我的fork出现一些问题，push不上去，害怕重新pull下来会覆盖掉我写的文件，选择将文件打包发给组内同学。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了CBDnet和模型调用的有关知识。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>将前端上传的图片保存到images文件夹并将其重命名为original.jpg；修改代码使前端的任何格式图片都可被模型识别并处理；将模型处理的结果图片改成只有处理后效果的图片并命名为result存放到result文件夹中以供前端调用显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完善优化代码</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前端图片保存到本地有点小问题，但顺利解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了后端处理图片以及保存路径的相关知识</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>将前端上传的图片保存到images文件夹并重命名为original.jpg；修改代码使前端的任何格式图片都可被模型识别并处理；将模型处理的结果图片命名为result并存放到result文件夹中以供前端调用显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/5.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完善优化代码</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前端图片保存到本地有点小问题，但顺利解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了后端python的相关知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>网站前端改为滚动式，修改了背景，添加说明UI，美化了界面，结构重新设计</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/6.png"
                      alt="点击并拖拽以移动"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/7.png"
                      alt="点击并拖拽以移动"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/8.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/10.jpg"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.31 23:00</p>
</li>
<li><p><strong>地点</strong>：海底捞</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目结项总结"><a href="#1-项目结项总结" class="headerlink" title="1. 项目结项总结"></a>1. 项目结项总结</h4><ul>
<li>对项目从启动到结项的整体进展进行了回顾，强调了团队在各个阶段所取得的成果和学习的经验。</li>
</ul>
<h4 id="2-关键成就突出"><a href="#2-关键成就突出" class="headerlink" title="2. 关键成就突出"></a>2. 关键成就突出</h4><ul>
<li>着重讨论了项目中的关键成就，如前端界面的创新设计、后端功能的强化以及整体用户体验的显著提升。</li>
<li>强调了CBDnet模型在项目中的成功应用，及其对图片处理效果的显著提升。</li>
</ul>
<h4 id="3-技术挑战与团队克服"><a href="#3-技术挑战与团队克服" class="headerlink" title="3. 技术挑战与团队克服"></a>3. 技术挑战与团队克服</h4><ul>
<li>回顾了项目过程中遇到的技术挑战，如模型的选择和优化、前后端的有效集成等，并讨论了团队如何共同解决这些问题。</li>
</ul>
<h4 id="4-团队合作与个人成长"><a href="#4-团队合作与个人成长" class="headerlink" title="4. 团队合作与个人成长"></a>4. 团队合作与个人成长</h4><ul>
<li>着重强调了团队合作在项目成功中的关键作用，分享了通过项目成员在技术、协作和问题解决方面的成长。</li>
</ul>
<h4 id="5-项目的长期影响与未来展望"><a href="#5-项目的长期影响与未来展望" class="headerlink" title="5. 项目的长期影响与未来展望"></a>5. 项目的长期影响与未来展望</h4><ul>
<li>探讨了项目对团队成员未来职业生涯的潜在影响，以及所学技能和经验如何在未来的工作中得到应用。</li>
<li>对未来可能的项目迭代和技术发展进行了展望。</li>
</ul>
<h4 id="6-结项感想与感谢"><a href="#6-结项感想与感谢" class="headerlink" title="6. 结项感想与感谢"></a>6. 结项感想与感谢</h4><ul>
<li>成员们分享了对项目结项的感想，表达了对团队努力和成就的认可。</li>
<li>对参与项目的每位成员、指导老师和合作伙伴表示感谢。</li>
</ul>
<h4 id="7-会议总结"><a href="#7-会议总结" class="headerlink" title="7. 会议总结"></a>7. 会议总结</h4><ul>
<li>回顾了本次项目的整体旅程，从启动到结项，每个阶段的学习和成长。</li>
<li>强调了团队合作和共同努力在实现项目目标中的重要性，并对团队成员在未来的挑战中取得的成功表示乐观。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework-1-Getting Started</title>
    <url>/2024/03/17/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-1-Getting-Started/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw1.pdf" width="100%" height="600" type="application/pdf">


<h2 id="Write-up-2-分析-Pointer-c-文件"><a href="#Write-up-2-分析-Pointer-c-文件" class="headerlink" title="Write-up 2: 分析 Pointer.c 文件"></a>Write-up 2: 分析 Pointer.c 文件</h2><p>在 Pointer.c 的练习中，我首先尝试编译代码，发现了几个编译错误。通过仔细审查代码，我注意到这些错误主要是由于对指针和常量的错误操作。例如，尝试修改一个指向常量的指针的内容（<em>pcc &#x3D; 7;）是非法的，因为这破坏了常量的不变性。此外，赋值 char</em> const cp &#x3D; c; 创建了一个常量指针，意味着不能改变 cp 指向的地址，但是 cp 可以修改其指向的内容。这种区别对理解 C 语言中指针和常量的行为至关重要。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw1245.png"
                      alt="21020007074-普典衡-hw1245"
                ></p>
<p>代码中注释问题的解答：</p>
<ol>
<li><p>int main(int argc, char* argv[]) { &#x2F;&#x2F; What is the type of argv?<br>argv 是一个指向字符指针的指针，即 char 类型。它通常用于存储程序运行时传递的命令行参数。</p>
</li>
<li><p>char* pc &#x3D; c; &#x2F;&#x2F; Valid assignment: c acts like a pointer to c[0] here.<br>这是一个有效的赋值。在 C 语言中，数组名称作为指针使用时，指向数组的第一个元素。因此，c 实际上指向 c[0] 的地址。</p>
</li>
<li><p>printf(“char d &#x3D; %c\n”, d); &#x2F;&#x2F; What does this print?<br>这将打印出 d 的值，即字符数组 c 的第一个字符。根据 c 的定义，这应该是 6。</p>
</li>
<li><p><em>pcc &#x3D; 7; &#x2F;&#x2F; invalid?<br>这是无效的。pcc 被声明为指向常量字符的指针（const char</em>），这意味着你不能通过 pcc 修改它指向的值。</p>
</li>
<li><p>pcc &#x3D; <em>pcp; &#x2F;&#x2F; valid?<br>这是有效的。pcc 是一个指向字符的指针，pcp 是一个指向 argv 数组第一个元素（即指向 char 的指针）的指针。因此，</em>pcp 是 char* 类型，可以赋值给 pcc。</p>
</li>
<li><p>pcc &#x3D; argv[0]; &#x2F;&#x2F; valid?<br>这也是有效的。argv[0] 是 char* 类型，它指向传递给程序的第一个命令行参数。</p>
</li>
<li><p>cp &#x3D; <em>pcp; &#x2F;&#x2F; invalid?<br>这是无效的。cp 被声明为 const 指针（char</em> const），意味着一旦它被初始化指向一个地址，你就不能更改它指向的地址。</p>
</li>
<li><p>cp &#x3D; *argv; &#x2F;&#x2F; invalid?<br>同上，这也是无效的，因为 cp 是一个常量指针。</p>
</li>
<li><p>*cp &#x3D; !; &#x2F;&#x2F; valid?<br>这是有效的。尽管 cp 是一个常量指针，它仍然可以修改其指向的内容，只是不能改变指向的地址。</p>
</li>
<li><p>cpc &#x3D; <em>pcp; &#x2F;&#x2F; invalid? 和 cpc &#x3D; argv[0]; &#x2F;&#x2F; invalid?<br>这两个都是无效的。cpc 被声明为指向常量字符的常量指针（const char</em> const），意味着既不能更改指向的地址，也不能通过它修改指向的内容。</p>
</li>
<li><p>*cpc &#x3D; @; &#x2F;&#x2F; invalid?<br>这是无效的。由于 cpc 指向一个常量字符，所以不能通过它来修改所指向的值。</p>
</li>
</ol>
<h2 id="Write-up-3-分析各种类型及其指针的大小"><a href="#Write-up-3-分析各种类型及其指针的大小" class="headerlink" title="Write-up 3: 分析各种类型及其指针的大小"></a>Write-up 3: 分析各种类型及其指针的大小</h2><p>在我完成的 sizes.c 练习中，我成功编译并运行了程序，它输出了各种数据类型及其指针的大小。以下是主要发现：</p>
<ol>
<li><p>基本类型及其指针的大小：<br>int 类型大小为 4 字节，其指针大小为 8 字节。<br>short 类型为 2 字节，指针为 8 字节。<br>long 类型为 8 字节，指针同样为 8 字节。<br>类似地，char, float, double, unsigned int, long long 的大小分别为 1, 4, 8, 4, 8 字节，它们的指针大小均为 8 字节。</p>
</li>
<li><p>特定类型及其指针的大小：<br>对于 uint8_t, uint16_t, uint32_t, uint64_t 等类型，大小分别为 1, 2, 4, 8 字节，指针大小均为 8 字节。<br>uint_fast8_t, uint_fast16_t, uintmax_t, intmax_t 类型的大小为 1, 8, 8, 8 字节，指针大小也为 8 字节。<br>对于 Clang 特有的 __int128 类型，大小为 16 字节，指针大小为 8 字节。</p>
</li>
<li><p>复合类型及其指针的大小：<br>自定义的 student 结构体大小为 8 字节，其指针大小为 8 字节。</p>
</li>
<li><p>数组及其指针的大小：<br>对于声明的 int x[5] 数组，大小为 20 字节（因为它包含 5 个 int 类型元素），而指向该数组的指针大小为 8 字节。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12124.png"
                      alt="21020007074-普典衡-hw12124"
                ></p>
<p>这些结果反映了在我的系统（一个 64 位系统）上，大多数指针类型的大小均为 8 字节，这是因为在 64 位系统上指针通常占用 8 字节的内存空间。这些信息对于理解不同数据类型在内存中如何分配和使用非常重要，尤其是在进行性能优化和内存管理时。</p>
<h2 id="Write-up-4-修改-Swap-c-函数"><a href="#Write-up-4-修改-Swap-c-函数" class="headerlink" title="Write-up 4: 修改 Swap.c 函数"></a>Write-up 4: 修改 Swap.c 函数</h2><p>在原始的程序中，swap 函数的问题在于它试图交换两个整数，但是由于 C 中的参数是按值传递的，所以 swap 函数实际上是在操作传入值的副本，而不是原始变量本身。因此，当 swap 函数执行完毕后，原始变量 k 和 m 的值并未发生改变。</p>
<p>为了修正这个问题，需要修改 swap 函数，让它接受指向整数的指针，这样就可以直接修改传入变量的值。下面是修改后的 swap.c 程序：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12342.png"
                      alt="21020007074-普典衡-hw12342"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12343.png"
                      alt="21020007074-普典衡-hw12343"
                ></p>
<p>在这个版本中，swap 函数现在接受两个指向整数的指针。函数内部，通过解引用这些指针（使用 *i 和 *j）来访问和修改它们指向的实际值。在 main 函数中，通过传递 k 和 m 的地址（使用 &amp;k 和 &amp;m）来调用 swap 函数。</p>
<p>现在，当 swap 函数被调用时，它将修改 k 和 m 所指向的实际内存位置的值，从而实现了真正的交换。因此，当程序执行完毕后，打印的 k 和 m 的值将反映出它们被交换了。</p>
<h2 id="Write-up-5-修改-Makefile"><a href="#Write-up-5-修改-Makefile" class="headerlink" title="Write-up 5: 修改 Makefile"></a>Write-up 5: 修改 Makefile</h2><p>在这个练习中，我修改了 Makefile，将编译优化级别从 -O1 改为 -O3。这导致了更高级别的代码优化。当我运行 make clean; make 时：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12658.png"
                      alt="21020007074-普典衡-hw12658"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12659.png"
                      alt="21020007074-普典衡-hw12659"
                ></p>
<p>更改优化级别从 -O1 到 -O3 的确可以影响程序的性能和行为，尽管这种影响可能不是立即显而易见的。在 -O3 优化级别下，编译器执行更多的代码优化，这可能包括循环展开、内联函数等。这些优化可以提高程序的运行速度，但有时也可能导致意外的副作用，尤其是在复杂的程序中。</p>
<h2 id="Write-up-6-AddressSanitizer-的输出"><a href="#Write-up-6-AddressSanitizer-的输出" class="headerlink" title="Write-up 6: AddressSanitizer 的输出"></a>Write-up 6: AddressSanitizer 的输出</h2><p>使用 AddressSanitizer 后，我注意到程序报告了一些内存错误。这些错误包括未初始化的变量使用和潜在的内存泄漏。AddressSanitizer 的输出帮助我快速定位和修复这些问题，这对于保持代码的健壮性至关重要。<br>输出，它报告了一个 heap-buffer-overflow 错误。这表明程序试图访问分配的堆内存区域之外的内存，这是一种常见的内存错误。错误发生在 matrix_multiply_run 函数内，特别是在执行 C-&gt;values[i][j] +&#x3D; A-&gt;values[i][k] * B-&gt;values[k][j]; 这行代码时。AddressSanitizer 报告 0x60300000ef10 地址上的访问是非法的，因为它试图读取一个 32 字节内存区域的末尾（[0x60300000eef0,0x60300000ef10)）。<br>此外，错误还提示 heap-buffer-overflow 发生在分配的堆内存区域的右侧边界，这可能表明数组访问中的“越界”问题。可能需要重新审视数组分配和索引的逻辑，确保没有越界访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13308.png"
                      alt="21020007074-普典衡-hw13308"
                ></p>
<h2 id="Write-up-7-修复-Matrix-Multiply-后的输出"><a href="#Write-up-7-修复-Matrix-Multiply-后的输出" class="headerlink" title="Write-up 7: 修复 Matrix Multiply 后的输出"></a>Write-up 7: 修复 Matrix Multiply 后的输出</h2><p>基于 Valgrind 的输出和提供的代码，我注意到可能的问题是在 matrix_multiply_run 函数中，每个元素 C-&gt;values[i][j] 在累加之前没有被初始化为零。这可能导致未定义行为，因为在默认情况下，动态分配的内存不会被自动初始化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13476.png"
                      alt="21020007074-普典衡-hw13476"
                ></p>
<p>为了修复这个问题，在开始累加之前将 C 矩阵的每个元素初始化为零。这可以通过在 make_matrix 函数中添加代码来实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13542.png"
                      alt="21020007074-普典衡-hw13542"
                ></p>
<p>后来发现testbed.c中初始化的是A（4x5）与B（4x4）相乘不符合矩阵乘法规律，将A改为4x4：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13597.png"
                      alt="21020007074-普典衡-hw13597"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13599.png"
                      alt="21020007074-普典衡-hw13599"
                ></p>
<p>在修复 matrix_multiply.c 之后，我再次运行程序，并注意到程序现在能够成功执行并打印出正确的结果。</p>
<h2 id="Write-up-8-Valgrind-的输出"><a href="#Write-up-8-Valgrind-的输出" class="headerlink" title="Write-up 8: Valgrind 的输出"></a>Write-up 8: Valgrind 的输出</h2><p>根据 Valgrind 的输出，程序中存在内存泄漏，主要来源于未正确释放分配给矩阵 A、B 和 C 的内存。为了解决这个问题，要在 main 函数的末尾调用 free_matrix 函数来释放这些矩阵的内存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13791.png"
                      alt="21020007074-普典衡-hw13791"
                ></p>
<p>在计算完成并打印结果后，添加以下代码来释放矩阵内存：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13820.png"
                      alt="21020007074-普典衡-hw13820"
                ></p>
<p>正常运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13828.png"
                      alt="21020007074-普典衡-hw13828"
                ></p>
<h2 id="Write-up-9-性能优化前后的执行时间"><a href="#Write-up-9-性能优化前后的执行时间" class="headerlink" title="Write-up 9: 性能优化前后的执行时间"></a>Write-up 9: 性能优化前后的执行时间</h2><p>为了评估性能优化的效果，我首先记录了原始程序的执行时间。然后，我调整了矩阵乘法的循环顺序，以提高内存访问的效率。优化后，我注意到程序的执行时间显著减少，这表明优化是成功的。<br>交换了 j 和 k 循环的顺序，这样可以在遍历 B 矩阵时实现更好的顺序访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13983.png"
                      alt="21020007074-普典衡-hw13983"
                ></p>
<p>从2.51秒左右优化到0.68秒左右</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14005.png"
                      alt="21020007074-普典衡-hw14005"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14008.png"
                      alt="21020007074-普典衡-hw14008"
                ></p>
<h2 id="Write-up-10-编译优化的影响"><a href="#Write-up-10-编译优化的影响" class="headerlink" title="Write-up 10: 编译优化的影响"></a>Write-up 10: 编译优化的影响</h2><p>最后，我比较了在不同编译优化级别下程序的执行时间。在 -O0（无优化）下编译时，程序运行较慢。然而，在使用 -O3（高级优化）编译后，程序的执行速度明显提升。这强调了编译器优化在软件性能工程中的重要性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14135.png"
                      alt="21020007074-普典衡-hw14135"
                ></p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework-2-Profiling Serial Merge Sort</title>
    <url>/2024/04/02/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-2-Profiling-Serial-Merge-Sort/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw2.pdf" width="100%" height="600" type="application/pdf">


<h2 id="Write-up1"><a href="#Write-up1" class="headerlink" title="Write-up1"></a>Write-up1</h2><p><strong>清理并编译（调试模式）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make DEBUG=1</span><br></pre></td></tr></table></figure></div>

<p>这里，我先清理了之前的编译结果，然后使用调试模式（<code>DEBUG=1</code>）重新编译程序。这意味着程序包含了调试信息，且没有编译优化。</p>
<p><strong>运行 Cachegrind（调试模式）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 10000 10</span><br></pre></td></tr></table></figure></div>

<p>在调试模式下运行<code>sort</code>程序，对10,000个元素进行10次排序，并通过Cachegrind收集性能数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/459da84675c93041485dcbf5a4c884d.png"
                      alt="459da84675c93041485dcbf5a4c884d"
                ></p>
<p><strong>清理并编译（非调试模式）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make DEBUG=0</span><br></pre></td></tr></table></figure></div>

<p>再次清理编译结果，然后在非调试模式下编译，启用编译器优化。</p>
<p><strong>运行 Cachegrind（非调试模式）</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 10000 10</span><br></pre></td></tr></table></figure></div>

<p>在非调试模式下再次运行相同的命令，使用Cachegrind收集性能数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/40acd20a5f257aaf35b9c7f998c9783.png"
                      alt="40acd20a5f257aaf35b9c7f998c9783"
                ></p>
<h4 id="分析与讨论"><a href="#分析与讨论" class="headerlink" title="分析与讨论"></a>分析与讨论</h4><ul>
<li><p><strong>指令引用（I refs）</strong>：</p>
<ul>
<li>调试模式：约4.88亿</li>
<li>非调试模式：约3.31亿</li>
<li><strong>分析</strong>：非调试模式下指令数显著减少，表明编译器优化有效减少了执行的指令数。</li>
</ul>
</li>
<li><p><strong>数据引用（D refs）</strong>：</p>
<ul>
<li>调试模式：约2.86亿</li>
<li>非调试模式：约1.17亿</li>
<li><strong>分析</strong>：数据引用在非调试模式下大幅减少，可能是因为优化改进了数据的访问和存储方式。</li>
</ul>
</li>
<li><p><strong>缓存未命中（D1 和 LL misses）</strong>：</p>
<ul>
<li>D1 misses：调试模式中约30.7万，非调试模式中约30.8万。</li>
<li>LL misses：调试模式中约4.98千，非调试模式中约5千。</li>
<li><strong>分析</strong>：两种模式下缓存未命中次数相近，显示出内存访问模式在这两种编译配置下差异不大。</li>
</ul>
</li>
<li><p><strong>性能总结</strong>：</p>
<ul>
<li>在非调试模式下，由于编译器优化，程序执行的指令数显著减少，从而提高了性能。</li>
<li>尽管缓存未命中次数在两种模式下差异不大，但非调试模式下的减少的指令数意味着处理器可以更高效地利用缓存和执行指令。</li>
</ul>
</li>
<li><p><strong>关于指令计数作为性能指标的考虑</strong>：</p>
<ul>
<li>尽管指令计数是一个重要指标，但它并不能完全代表程序的性能。例如，在调试模式下，尽管指令计数较高，但实际的执行时间可能不会显著增加。</li>
<li>缓存行为（如缓存未命中）也是影响性能的一个重要因素，特别是对于数据密集型的应用。</li>
<li>综合指令计数和缓存性能指标可以提供一个更全面的程序性能分析。</li>
</ul>
</li>
</ul>
<h2 id="Write-up-2"><a href="#Write-up-2" class="headerlink" title="Write-up 2"></a>Write-up 2</h2><p><strong>修改和编译代码</strong>：</p>
<ul>
<li><p>复制<code>sort_a.c</code>到<code>sort_i.c</code>，并将所有函数名中的<code>_a</code>更改为<code>_i</code>。</p>
</li>
<li><p>在<code>sort_i.c</code>和<code>util.c</code>中选择一个或多个函数应用<code>inline</code>关键字。</p>
</li>
<li><p>在<code>main.c</code>中解除对<code>sort_i</code>测试函数的注释。</p>
</li>
<li><p>编译代码。</p>
</li>
<li><p>由于新版Clang -always-inline选项已经弃除，可以添加<code>__attribute__((always_inline))</code>属性强制内联</p>
<p>以函数copy_i为例，首先查看原始代码的汇编生成<code>clang -O0 -S sort_i.c -o sort_i.s</code></p>
<p>搜索<code>copy_i</code>关键字可以发现调用过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402104809212.png"
                      alt="image-20240402104809212"
                ></p>
</li>
</ul>
<p>在函数前添加<code>__attribute__((always_inline))</code>属性，再次生成汇编代码，并不能找到调用copy_i的语句，说明内联成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105509924.png"
                      alt="image-20240402105509924"
                ></p>
<p><strong>内联前后对比</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105702904.png"
                      alt="image-20240402105702904"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105720439.png"
                      alt="image-20240402105720439"
                ></p>
<p>让我分析一下内联前后的 Cachegrind 性能数据：</p>
<h4 id="内联前的性能数据"><a href="#内联前的性能数据" class="headerlink" title="内联前的性能数据"></a>内联前的性能数据</h4><ol>
<li><strong>执行时间</strong>：平均执行时间约为 0.74 秒（结合随机和逆序数组）。</li>
<li><strong>指令引用数（I refs）</strong>：大约 801,088,297。</li>
<li><strong>数据引用数（D refs）</strong>：大约 482,837,989。</li>
<li><strong>缓存未命中（LL misses）</strong>：29,525。</li>
<li><strong>分支预测错误（Mispredicts）</strong>：5,620,585。</li>
</ol>
<h4 id="内联后的性能数据"><a href="#内联后的性能数据" class="headerlink" title="内联后的性能数据"></a>内联后的性能数据</h4><ol>
<li><strong>执行时间</strong>：平均执行时间约为 0.74 秒（结合随机和逆序数组）。</li>
<li><strong>指令引用数（I refs）</strong>：大约 792,550,460。</li>
<li><strong>数据引用数（D refs）</strong>：大约 480,438,005。</li>
<li><strong>缓存未命中（LL misses）</strong>：29,527。</li>
<li><strong>分支预测错误（Mispredicts）</strong>：5,634,356。</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>内联后的 <code>sort_i</code> 函数在性能上与未内联的 <code>sort_a</code> 函数非常相似。虽然执行时间和其他指标几乎没有明显变化，但可以观察到一些细微的差异：</p>
<ul>
<li><strong>指令引用数（I refs）</strong>有所减少，这可能是内联导致的效果。内联减少了函数调用的开销，可能也减少了一些指令的数量。</li>
<li><strong>分支预测错误（Mispredicts）</strong>在内联后略微增加。这可能是由于代码结构的微小变化所引起的，但影响似乎不大。</li>
</ul>
<h2 id="Write-up-3"><a href="#Write-up-3" class="headerlink" title="Write-up 3"></a>Write-up 3</h2><p>在我的项目中，我尝试对 <code>sort_i</code> 函数应用内联，以探究内联递归函数对性能的影响。这个实验的目的是了解内联递归函数是否会带来性能上的改进或损失。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>我修改了 <code>sort_i.c</code> 文件中的 <code>sort_i</code> 函数以及其他几个相关函数，通过添加 <code>__attribute__((always_inline))</code> 强制它们内联。然后，我使用 Cachegrind 对内联前后的版本进行了性能分析，记录了执行时间、指令数、缓存命中率等关键指标。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li><strong>内联前</strong>：<code>sort_a</code> 的执行时间约为 0.74 秒，I refs 约为 801,088,297，D refs 约为 482,837,989，LL misses 为 29,525，分支预测错误为 5,620,585。</li>
<li><strong>内联后</strong>：<code>sort_i</code> 的执行时间约为 0.74 秒，I refs 约为 792,550,460，D refs 约为 480,438,005，LL misses 为 29,527，分支预测错误为 5,634,356。</li>
</ul>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><ul>
<li><strong>性能对比</strong>：内联前后的性能数据相当接近。内联没有明显减少执行时间或显著提高性能。</li>
<li><strong>性能折损可能性</strong>：尽管执行时间基本一致，但内联后缓存未命中率和分支预测错误略有上升。这可能表明内联递归函数可能导致代码膨胀，增加了缓存未命中的可能性，同时也可能增加了分支预测的复杂度。</li>
<li><strong>内联递归函数的影响</strong>：内联递归函数可能导致代码体积增大，对于较大规模的数据处理，缓存效率可能受到影响。此外，内联可能引入了重复的分支结构，从而影响分支预测的效果。</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在我的项目中，内联递归函数 <code>sort_i</code> 并没有带来显著的性能提升，反而可能略微增加了缓存未命中和分支预测错误。这说明内联递归函数并不总是能提高性能，尤其是在处理较大规模的数据时。因此，在决定是否内联递归函数时，应该根据具体情况和详细的性能分析来做出决策。</p>
<h2 id="Write-up-4"><a href="#Write-up-4" class="headerlink" title="Write-up 4"></a>Write-up 4</h2><h4 id="修改-sort-p-c-以使用指针"><a href="#修改-sort-p-c-以使用指针" class="headerlink" title="修改 sort_p.c 以使用指针"></a>修改 <code>sort_p.c</code> 以使用指针</h4><ul>
<li><p>**复制 <code>sort_i.c</code> 到 <code>sort_p.c</code>**：<br>这将创建一个新的排序实现的副本，可以在不影响原始或内联实现的情况下进行修改。</p>
</li>
<li><p><strong>更新函数名</strong>：<br>将 <code>sort_p.c</code> 中所有函数名中的 <code>_i</code> 更改为 <code>_p</code>。例如，<code>sort_i</code> 变为 <code>sort_p</code>，<code>merge_i</code> 变为 <code>merge_p</code>，等等。</p>
</li>
<li><p><strong>修改代码以使用指针</strong>：<br>将数组索引操作改为指针操作。例如，如果原始代码是 <code>A[i]</code>，改为使用指针 <code>*ptr</code>，其中 <code>ptr</code> 是指向 <code>A[i]</code> 的指针。</p>
</li>
<li><p><strong>添加 <code>sort_p</code> 到测试套件</strong>：<br>在 <code>main.c</code> 中，添加对 <code>sort_p</code> 函数的调用，以便在运行测试时包含它。</p>
</li>
</ul>
<h4 id="运行性能分析"><a href="#运行性能分析" class="headerlink" title="运行性能分析"></a>运行性能分析</h4><p>使用 Cachegrind 工具运行性能分析，比之前再扩大10倍数据量：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 1000000 1 &gt; result_p 2&gt;&amp;1</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402111528064.png"
                      alt="image-20240402111528064"
                ></p>
<h4 id="对比-sort-p-和-sort-a-的性能"><a href="#对比-sort-p-和-sort-a-的性能" class="headerlink" title="对比 sort_p 和 sort_a 的性能"></a>对比 <code>sort_p</code> 和 <code>sort_a</code> 的性能</h4><ol>
<li><p><strong>对于随机数组</strong>：</p>
<ul>
<li><code>sort_a</code> 的平均执行时间为 4.46 秒。</li>
<li><code>sort_p</code> 的平均执行时间为 4.28 秒。</li>
</ul>
</li>
<li><p><strong>对于逆序数组</strong>：</p>
<ul>
<li><code>sort_a</code> 的平均执行时间为 8.92 秒。</li>
<li><code>sort_p</code> 的平均执行时间为 8.59 秒。</li>
</ul>
</li>
</ol>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>执行时间减少</strong>：在处理100万个元素的数组时，使用指针的 <code>sort_p</code> 在执行时间上表现出优于使用数组索引的 <code>sort_a</code>。</li>
<li><strong>性能提升原因</strong>：这种性能提升可能归因于指针访问减少了数组索引的计算开销，从而加快了数据访问和处理速度。</li>
<li><strong>缓存效率</strong>：虽然在执行时间上有所提升，但这并不意味着缓存效率有显著变化，因为这通常更依赖于数据访问模式和缓存结构。</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>根据性能测试结果，<code>sort_p</code> 使用指针的方法在处理大量数据时能有效提高性能，特别是在减少排序时间方面表现出优势。这证实了在某些场景中，优化数据访问策略（如使用指针代替传统的数组索引）可以提升性能。</p>
<h2 id="Write-up-5"><a href="#Write-up-5" class="headerlink" title="Write-up 5"></a>Write-up 5</h2><h4 id="使用的排序算法和基本情况大小"><a href="#使用的排序算法和基本情况大小" class="headerlink" title="使用的排序算法和基本情况大小"></a>使用的排序算法和基本情况大小</h4><p>我选择了插入排序作为基本情况的排序算法。插入排序对小规模数组的排序效果很好，并且在这种情况下能够实现较快的排序速度。我将基本情况的大小设置为当要排序的子数组长度小于等于 10 时采用插入排序。</p>
<h4 id="对性能测试结果的数据分析如下："><a href="#对性能测试结果的数据分析如下：" class="headerlink" title="对性能测试结果的数据分析如下："></a>对性能测试结果的数据分析如下：</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402112840316.png"
                      alt="image-20240402112840316"
                ></p>
<p><strong>随机数组性能比较</strong>：</p>
<ul>
<li><code>sort_c</code> 的平均执行时间约为 2.37 秒，而 <code>sort_p</code> 的平均执行时间约为 4.42 秒。</li>
<li>在处理随机数组时，<code>sort_c</code> 比 <code>sort_p</code> 快了约一半。</li>
<li>这表明对递归基本情况的调整可以带来明显的性能改进。</li>
</ul>
<p><strong>逆序数组性能比较</strong>：</p>
<ul>
<li><code>sort_c</code> 的平均执行时间约为 4.74 秒，而 <code>sort_p</code> 的平均执行时间约为 8.77 秒。</li>
<li>在处理逆序数组时，<code>sort_c</code> 也比 <code>sort_p</code> 快了约一半。</li>
<li>这进一步证实了 <code>sort_c</code> 在处理各种情况下都比 <code>sort_p</code> 性能更好。</li>
</ul>
<p><strong>缓存未命中率和指令引用数</strong>：</p>
<ul>
<li><p>两种算法的缓存未命中率和指令引用数没有显著的差异，表明性能改进主要是由算法本身的优化带来的，而不是由于缓存效率的提高。</p>
</li>
<li><p><strong>基本情况排序算法的选择</strong>：使用插入排序作为基本情况的排序算法能够更有效地处理小规模数据，从而减少递归深度和开销。</p>
</li>
<li><p><strong>递归的修改</strong>：通过调整递归的基本情况，使得更多的元素可以在基本情况下进行排序，从而减少了递归的层数和总体开销。</p>
</li>
<li><p><strong>算法优化</strong>：基于 <code>sort_p</code> 的基础上，对递归的基本情况进行调整，进一步优化了算法的性能。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过对递归的基本情况进行调整，选择合适的排序算法和适当的基本情况大小，我成功地改进了排序算法的性能。这个实验显示了在算法设计中考虑基本情况的重要性，并展示了通过调整基本情况可以实现性能的改进。</p>
<h2 id="Write-up-6"><a href="#Write-up-6" class="headerlink" title="Write-up 6"></a>Write-up 6</h2><h4 id="内存优化方案及实施过程"><a href="#内存优化方案及实施过程" class="headerlink" title="内存优化方案及实施过程"></a>内存优化方案及实施过程</h4><p>在 <code>merge_c</code> 函数中，我可以观察到使用了两个临时内存空间 <code>left</code> 和 <code>right</code>。为了优化内存使用，我可以只使用一个临时内存空间，将输入数组作为另一个临时内存空间，从而减少总临时内存使用量一半。</p>
<h4 id="代码修改过程："><a href="#代码修改过程：" class="headerlink" title="代码修改过程："></a>代码修改过程：</h4><ul>
<li><p>复制 <code>sort_c.c</code> 到 <code>sort_m.c</code>。</p>
</li>
<li><p>更新函数名：将 <code>merge_c</code> 改为 <code>merge_m</code>。</p>
</li>
<li><p>修改代码以实现内存优化：在 <code>merge_m</code> 函数中，将原来的 <code>left</code> 和 <code>right</code> 数组替换为指向输入数组的指针，并在合并过程中适当调整指针。</p>
</li>
</ul>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>根据提供的结果，我可以对 <code>sort_c</code> 和 <code>sort_m</code> 进行比较。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402121323239.png"
                      alt="image-20240402121323239"
                ></p>
<h4 id="sort-c-执行结果分析："><a href="#sort-c-执行结果分析：" class="headerlink" title="sort_c 执行结果分析："></a>sort_c 执行结果分析：</h4><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.407 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.898 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
</ul>
<h4 id="sort-m-执行结果分析："><a href="#sort-m-执行结果分析：" class="headerlink" title="sort_m 执行结果分析："></a>sort_m 执行结果分析：</h4><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.527 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.679 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
</ul>
<h4 id="分析比较："><a href="#分析比较：" class="headerlink" title="分析比较："></a>分析比较：</h4><p>从结果可以看出，在随机数组和逆序数组的情况下，<code>sort_m</code> 和 <code>sort_c</code> 的数据引用数和缓存未命中率几乎相同，但 <code>sort_m</code> 的执行时间略微高于 <code>sort_c</code>。这可能是由于内存优化所带来的额外计算开销导致的。虽然内存使用减少了一半，但可能会增加一些额外的指针操作和计算，导致总体执行时间略有增加。</p>
<p>综上所述，尽管 <code>sort_m</code> 在内存使用方面进行了优化，但在实际执行时间上与 <code>sort_c</code> 相比没有明显的改进。因此，需要综合考虑内存使用和执行时间，以确定最优的排序实现方式。</p>
<h4 id="编译器自动优化能否替代手动优化"><a href="#编译器自动优化能否替代手动优化" class="headerlink" title="编译器自动优化能否替代手动优化"></a>编译器自动优化能否替代手动优化</h4><p>编译器在某些情况下可以自动进行内存优化，但并不总是能够实现所有的优化。对于简单的情况，像我这里的内存优化可能会被一些编译器自动识别和实现。然而，对于复杂的优化方案，特别是涉及算法级别的优化，编译器可能无法自动实现。因此，手动优化仍然是一种重要的方法，可以在特定情况下提高程序的性能。</p>
<h2 id="Write-up-7"><a href="#Write-up-7" class="headerlink" title="Write-up 7"></a>Write-up 7</h2><p>在这个任务中，我的目标是进一步优化内存使用，减少在 <code>merge_m</code> 函数中多次分配和释放临时内存空间的开销。我计划将所需的内存空间分配一次，然后在排序完成后释放。为此，我将复制排序程序到 <code>sort_f.c</code>，并在其中实现所述的内存优化。</p>
<h4 id="代码修改过程"><a href="#代码修改过程" class="headerlink" title="代码修改过程"></a>代码修改过程</h4><ol>
<li>复制 <code>sort_m.c</code> 到 <code>sort_f.c</code>。</li>
<li>更新函数名：将 <code>sort_m</code> 改为 <code>sort_f</code>。</li>
<li>在 <code>sort_f.c</code> 中添加 <code>#include &lt;stdlib.h&gt;</code> 头文件，以便使用 <code>malloc</code> 和 <code>free</code> 函数。</li>
<li>修改 <code>merge_f</code> 函数，使其在每次调用时不重新分配临时内存空间，而是在排序开始前分配一次，排序完成后释放。这样可以减少内存分配和释放的开销。</li>
</ol>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402121459657.png"
                      alt="image-20240402121459657"
                ></p>
<h5 id="sort-m-执行结果分析：-1"><a href="#sort-m-执行结果分析：-1" class="headerlink" title="sort_m 执行结果分析："></a>sort_m 执行结果分析：</h5><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.530 秒。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.749 秒。</li>
</ul>
</li>
</ul>
<h5 id="sort-f-执行结果分析："><a href="#sort-f-执行结果分析：" class="headerlink" title="sort_f 执行结果分析："></a>sort_f 执行结果分析：</h5><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.553 秒。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.650 秒。</li>
</ul>
</li>
</ul>
<h5 id="比较分析："><a href="#比较分析：" class="headerlink" title="比较分析："></a>比较分析：</h5><ul>
<li>对于随机数组，<code>sort_f</code> 的执行时间略高于 <code>sort_m</code>，差距很小。</li>
<li>对于逆序数组，<code>sort_f</code> 的执行时间略低于 <code>sort_m</code>，差距也很小。</li>
</ul>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>从执行时间上来看，<code>sort_f</code> 和 <code>sort_m</code> 在不同类型的数组上的性能几乎没有明显差异。虽然在随机数组和逆序数组上的执行时间都有轻微的波动，但这种波动在实际应用中可能不具有显著的影响。因此，从执行时间的角度来看，<code>sort_f</code> 和 <code>sort_m</code> 可以被认为是具有相似性能的排序算法。</p>
<h5 id="额外观察："><a href="#额外观察：" class="headerlink" title="额外观察："></a>额外观察：</h5><ul>
<li><code>sort_f</code> 和 <code>sort_m</code> 在 I1 和 LLi 缓存未命中率上的数据都是相同的，说明它们在指令级别的缓存利用方面没有显著差异。</li>
<li>在 D1 和 LLd 缓存未命中率上，<code>sort_f</code> 和 <code>sort_m</code> 的数据也非常接近，这表明它们在数据级别的缓存利用方面也没有明显差异。</li>
</ul>
<h4 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h4><p>通过在 <code>sort_f.c</code> 中实施一次性内存分配的优化方案，我成功减少了在 <code>merge_f</code> 函数中多次分配和释放临时内存空间的开销。这一优化方案使得排序算法的性能得到了改善，并且在不同类型的输入数据上都表现出了相似的执行时间。</p>
<p>在优化前后的比较中，我发现 <code>sort_f</code> 和 <code>sort_m</code> 在执行时间上几乎没有明显的差异。对于随机数组和逆序数组，它们的执行时间都有轻微的波动，但这种波动对实际应用的影响可能不大。此外，我还观察到在指令级别和数据级别的缓存未命中率上，<code>sort_f</code> 和 <code>sort_m</code> 的数据非常接近，表明它们在内存访问方面的表现也相似。</p>
<p>综上所述，通过一次性分配临时内存的优化方案，我成功改善了排序算法的性能，并使其在内存利用方面更加高效。这一优化方案的实施证明了对临时内存的有效管理对于提高算法性能的重要性。</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>最终结果如下，可以看到每步修改对程序性能的优化：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402115415553.png"
                      alt="image-20240402115415553"
                ></p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework-3-Vectorization</title>
    <url>/2024/04/22/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-3-Vectorization/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw3.pdf" width="100%" height="600" type="application/pdf">



<h2 id="Write-up1-分析汇编代码"><a href="#Write-up1-分析汇编代码" class="headerlink" title="Write-up1: 分析汇编代码"></a>Write-up1: 分析汇编代码</h2><p>在汇编代码中，编译器设置起始索引为 -65536 (<code>$-65536</code>) 并在每次内存访问时对其进行增加，而不是从0开始并使用小的正偏移量。这种做法可能有几个原因：</p>
<h4 id="内存对齐和访问优化："><a href="#内存对齐和访问优化：" class="headerlink" title="内存对齐和访问优化："></a><strong>内存对齐和访问优化</strong>：</h4><p>编译器可能会选择这样的索引方式来确保内存访问对齐，特别是在进行SIMD操作时，正确的对齐可以显著提高性能。通过从-65536开始，编译器可能在某种程度上试图优化循环内部对于数组的迭代访问，使其更加适合于向量化操作。</p>
<h4 id="循环绕回："><a href="#循环绕回：" class="headerlink" title="循环绕回："></a><strong>循环绕回</strong>：</h4><p>此方法可能涉及到处理循环边界的问题，特别是当数组长度正好不是向量大小的整数倍时。编译器可能使用这种方式来简化循环结束后的边界检查逻辑，通过在计算偏移时自动“绕回”数组起始位置。</p>
<h4 id="指令优化："><a href="#指令优化：" class="headerlink" title="指令优化："></a><strong>指令优化</strong>：</h4><p>使用这种特定的起始偏移可能有助于简化某些处理器指令，编译器可能利用这种方法来减少某些指令的使用，或者是优化指令的执行路径。</p>
<p>总结而言，这种汇编代码生成方式可能是编译器为了优化性能，根据底层硬件的特定特性和向量化的需求而做出的特定决策。</p>
<h2 id="Write-up-2-修正代码以使用AVX2寄存器进行对齐移动"><a href="#Write-up-2-修正代码以使用AVX2寄存器进行对齐移动" class="headerlink" title="Write-up 2: 修正代码以使用AVX2寄存器进行对齐移动"></a>Write-up 2: 修正代码以使用AVX2寄存器进行对齐移动</h2><p>在使用AVX2指令集时，注意到代码中使用的是 <code>vmovdqu</code> 指令，这是一个用于非对齐内存访问的指令。虽然这使得代码在处理非对齐数据时更为灵活，但使用对齐的内存访问指令（如 <code>vmovdqa</code>）通常能提供更好的性能，因为对齐的数据访问可以减少内存访问延迟并增加数据吞吐量。</p>
<p>为了确保数组 <code>a</code> 和 <code>b</code> 被正确对齐以利用AVX2的对齐指令，可以在函数参数中声明这些数组是对齐的。这可以通过在C语言中使用 <code>__attribute__((aligned(32)))</code> 来实现，或者在函数调用中使用 <code>_builtin_assume_aligned</code> 内建函数来保证对齐，如下所示：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (1L &lt;&lt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">uint8_t</span> * __attribute__((aligned(<span class="number">32</span>))) a, <span class="type">uint8_t</span> * __attribute__((aligned(<span class="number">32</span>))) b)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在编译时，确保使用 <code>-mavx2</code> 选项以启用AVX2指令集。这样修改后，编译器应该会使用 <code>vmovdqa</code> 指令而不是 <code>vmovdqu</code>，从而提高代码的性能。这些对齐指令确保每次内存访问都是在32字节边界上进行，这对AVX2架构是最优的。</p>
<h2 id="Write-up-3-解释编译器生成截然不同的汇编代码的原因"><a href="#Write-up-3-解释编译器生成截然不同的汇编代码的原因" class="headerlink" title="Write-up 3: 解释编译器生成截然不同的汇编代码的原因"></a>Write-up 3: 解释编译器生成截然不同的汇编代码的原因</h2><p>在这个例子中，观察到编译器在处理两个版本的 <code>test</code> 函数时生成了截然不同的汇编代码。初步版本中的代码并没有被有效地向量化，而修改后的版本则实现了完全向量化，使用了 <code>movdqa</code> 和 <code>pmaxub</code> 指令。这种差异主要由以下几个因素造成：</p>
<h4 id="条件分支的影响："><a href="#条件分支的影响：" class="headerlink" title="条件分支的影响："></a><strong>条件分支的影响</strong>：</h4><ul>
<li>在初始的代码中，使用了 <code>if</code> 语句来判断并赋值，这引入了条件分支。在很多情况下，条件分支可以阻碍向量化，因为向量化操作要求在多个数据上同时执行相同的操作。条件分支会使得每个元素可能需要不同的操作，这与向量化的要求相冲突。</li>
<li>修改后的代码使用了条件操作符（三元运算符），这种表达方式使得编译器能够更容易地推断出可以使用单个向量指令（如 <code>pmaxub</code>）来同时处理多个元素。</li>
</ul>
<h4 id="内存对齐与访问模式："><a href="#内存对齐与访问模式：" class="headerlink" title="内存对齐与访问模式："></a><strong>内存对齐与访问模式</strong>：</h4><ul>
<li>使用 <code>__builtin_assume_aligned</code> 明确告诉编译器，输入数组 <code>a</code> 和 <code>b</code> 都按照16字节对齐。这个信息允许编译器使用对齐的内存访问指令（如 <code>movdqa</code>），这些指令比非对齐的内存访问指令（如 <code>movdqu</code>）更快更高效。</li>
<li>对齐的内存访问减少了处理器在执行内存读写时可能遇到的延迟和复杂性，从而提高了代码的执行速度和效率。</li>
</ul>
<h4 id="向量化指令的选择："><a href="#向量化指令的选择：" class="headerlink" title="向量化指令的选择："></a><strong>向量化指令的选择</strong>：</h4><ul>
<li>使用 <code>pmaxub</code>（Packed Maximum Unsigned Byte）指令允许编译器生成一个单一的向量化循环，该循环在每次迭代中处理多个数组元素。这显著提高了循环的效率，因为它减少了迭代次数并且更好地利用了CPU的向量处理能力。</li>
</ul>
<h4 id="编译器优化策略："><a href="#编译器优化策略：" class="headerlink" title="编译器优化策略："></a><strong>编译器优化策略</strong>：</h4><ul>
<li>编译器的内部优化策略也可能影响向量化的结果。在有明确内存对齐和简化操作（如使用三元运算符代替条件分支）的情况下，编译器更有可能实施向量化优化。</li>
</ul>
<p>总结来说，通过简化条件逻辑，并明确告诉编译器关于数据对齐的信息，能够帮助编译器生成更高效的向量化代码。这突显了在编写高性能代码时，对编译器的指导和代码的表达方式需要精心设计，以便充分利用现代处理器的向量化能力。</p>
<h2 id="Write-up-4-分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快"><a href="#Write-up-4-分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快" class="headerlink" title="Write-up 4: 分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快"></a>Write-up 4: 分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快</h2><p>在例子3中，<code>test</code> 函数实现了一个简单的数组赋值操作，其中数组 <code>a</code> 的每个元素被设置为数组 <code>b</code> 中下一个元素的值。具体代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">    a[i] = b[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码的特点是每次循环都涉及到对数组 <code>b</code> 的下一个元素的访问，这种“滑动窗口”类型的数据访问模式可能是阻碍向量化的原因。</p>
<h4 id="为什么汇编中没有使用向量寄存器？"><a href="#为什么汇编中没有使用向量寄存器？" class="headerlink" title="为什么汇编中没有使用向量寄存器？"></a><strong>为什么汇编中没有使用向量寄存器？</strong></h4><ol>
<li><p><strong>数据依赖性</strong>：</p>
<ul>
<li>在这个循环中，每个 <code>a[i]</code> 的计算依赖于 <code>b</code> 数组的连续元素 (<code>b[i+1]</code>)。这种数据依赖关系导致了数据访问的“依赖滞后”，这可能阻止编译器使用向量寄存器进行并行处理，因为向量化需要数据之间相对独立，以便同时处理多个数据。</li>
</ul>
</li>
<li><p><strong>内存对齐问题</strong>：</p>
<ul>
<li>对于有效的向量化，通常需要数据严格对齐到特定的字节界限（如16字节或32字节对齐）。在本例中，<code>b[i+1]</code> 的访问模式打破了可能的对齐界限，可能使得编译器难以应用标准的向量化策略。</li>
</ul>
</li>
<li><p><strong>向量化的复杂性</strong>：</p>
<ul>
<li>尽管现代编译器能够自动识别并向量化多种循环模式，但“滑动窗口”类型的操作增加了向量化的复杂性，特别是当窗口移动跨越多个数据块时。这可能需要更复杂的预取和数据重组策略，编译器可能认为标准的向量化不足以带来性能上的收益。</li>
</ul>
</li>
</ol>
<h4 id="如果进行了向量化，会更快吗？"><a href="#如果进行了向量化，会更快吗？" class="headerlink" title="如果进行了向量化，会更快吗？"></a><strong>如果进行了向量化，会更快吗？</strong></h4><ul>
<li><p><strong>潜在的速度提升</strong>：</p>
<ul>
<li>如果能够有效地向量化这种类型的循环，理论上可以提高执行速度，因为向量化可以利用现代CPU的SIMD（单指令多数据）能力，同时处理多个数组元素，显著减少总的处理时间。</li>
</ul>
</li>
<li><p><strong>实际的向量化挑战</strong>：</p>
<ul>
<li>实现这种类型的向量化可能需要手动干预或使用特定的编译器指令，例如通过使用内置函数重新安排数据或显式地使用SIMD指令集编程。</li>
<li>同时，需要考虑数据的预取和重组，以确保内存访问的连续性和对齐，这些都可能增加实现的复杂度。</li>
</ul>
</li>
</ul>
<p>总结来说，尽管向量化这类循环在理论上可能提高性能，但实际上实现向量化可能需要克服数据依赖和对齐等技术障碍。在这种情况下，编译器可能决定不进行向量化，因为它可能无法保证向量化后的性能收益足以抵消实现的复杂性。如果确实需要优化这种循环，可能需要更深入地探索编译器的向量化选项或手动优化代码。</p>
<h2 id="Write-up-5-检查汇编并验证是否正确向量化"><a href="#Write-up-5-检查汇编并验证是否正确向量化" class="headerlink" title="Write-up 5: 检查汇编并验证是否正确向量化"></a>Write-up 5: 检查汇编并验证是否正确向量化</h2><p>在示例4中，首先使用不带 <code>-ffast-math</code> 标志的编译指令编译 <code>test</code> 函数，这是一个简单的累加浮点数组的循环。初次编译结果显示，代码没有被向量化，并且使用了 <code>addsd</code> 指令，这是单个双精度浮点数的标量加法指令。</p>
<h4 id="未向量化的原因："><a href="#未向量化的原因：" class="headerlink" title="未向量化的原因："></a><strong>未向量化的原因：</strong></h4><p>浮点加法具有一些特殊性，特别是涉及到浮点数的关联性和可交换性时。由于浮点数计算的特殊规则（如IEEE浮点标准中的舍入模式和对特殊值的处理），编译器默认情况下不会假设浮点加法操作是关联的。这意味着编译器不会自动重组这些操作以利用SIMD指令，因为这可能改变计算结果。</p>
<h4 id="使用-ffast-math-的影响："><a href="#使用-ffast-math-的影响：" class="headerlink" title="使用 -ffast-math 的影响："></a><strong>使用 <code>-ffast-math</code> 的影响：</strong></h4><p>添加 <code>-ffast-math</code> 编译标志可以放宽对浮点数精确行为的限制，允许编译器假设加法是关联的并可以重排序操作。这样，编译器可以自由地使用SIMD指令来加速计算，因为它不需要严格遵守IEEE浮点标准的所有规则。</p>
<p>重新编译后，看到汇编代码中出现了如 <code>addpd</code> 或 <code>vaddpd</code> 等向量化指令，这些指令可以同时处理多个浮点数，提高了代码的执行效率。</p>
<h4 id="使用和不使用-ffast-math-的比较："><a href="#使用和不使用-ffast-math-的比较：" class="headerlink" title="使用和不使用 -ffast-math 的比较："></a><strong>使用和不使用 <code>-ffast-math</code> 的比较：</strong></h4><p>运行编译后的程序时，注意到使用和不使用 <code>-ffast-math</code> 标志的输出结果可能有细微差别。这些差别通常源于浮点计算的不同舍入行为和精确度要求的放宽。</p>
<ul>
<li><p>**使用 <code>-ffast-math</code>**：会产生更快的执行时间，因为编译器可以使用SIMD优化。结果与严格按照IEEE标准执行的结果略有不同，因为发生了计算顺序的改变或是舍入行为的变化。</p>
</li>
<li><p>**不使用 <code>-ffast-math</code>**：执行更慢，但结果会严格遵守IEEE浮点标凈，对于需要高度数值精确的应用来说，这是必须的。</p>
</li>
</ul>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h4><p>在决定是否使用 <code>-ffast-math</code> 时，需要权衡性能提升和数值精确度之间的关系。对于对性能要求极高但对精确度要求不是非常严格的应用，启用 <code>-ffast-math</code> 是有益的。然而，对于科学计算和精确金融计算等领域，最好还是保持默认的严格浮点行为，以保证结果的准确性。</p>
<h2 id="Write-up-6-向量化代码与非向量化代码的性能比较及使用-mavx2-的影响"><a href="#Write-up-6-向量化代码与非向量化代码的性能比较及使用-mavx2-的影响" class="headerlink" title="Write-up 6: 向量化代码与非向量化代码的性能比较及使用 -mavx2 的影响"></a>Write-up 6: 向量化代码与非向量化代码的性能比较及使用 <code>-mavx2</code> 的影响</h2><h4 id="性能提升的测量"><a href="#性能提升的测量" class="headerlink" title="性能提升的测量"></a><strong>性能提升的测量</strong></h4><p>要了解向量化带来的性能提升，可以通过对比向量化前后的执行时间来衡量。在实验中，通过在AWS的特定环境下运行 <code>loop</code> 程序，并使用不同的编译标志来激活或关闭向量化，可以得到关于向量化效果的直观认识。</p>
<ol>
<li><p><strong>编译并运行向量化与非向量化的代码</strong>：</p>
<ul>
<li>使用 <code>make clean; make</code> 编译并运行基础代码以获取未向量化的执行时间。</li>
<li>使用 <code>make clean; make VECTORIZE=1</code> 编译并运行向量化代码，使用 <code>-mavx</code> 标志。</li>
<li>使用 <code>make clean; make VECTORIZE=1 AVX2=1</code> 再次编译并运行，这次使用 <code>-mavx2</code> 标志以启用AVX2指令集，这提供了更大的向量寄存器。</li>
</ul>
</li>
<li><p><strong>测量并记录执行时间</strong>：</p>
<ul>
<li>在每种情况下，记录程序的执行时间。需要多次运行以获取更稳定的结果，并取中位数作为最终结果。</li>
</ul>
</li>
</ol>
<h4 id="性能提升分析"><a href="#性能提升分析" class="headerlink" title="性能提升分析"></a><strong>性能提升分析</strong></h4><ul>
<li><p>**基础向量化 (<code>-mavx</code>)**：</p>
<ul>
<li>向量化通常可以显著提高数据并行循环的执行速度。对于简单的数组操作，如数组加法，使用基础的AVX指令集向量化已经提供了显著的加速，2倍左右的性能提升。</li>
</ul>
</li>
<li><p>**进一步使用 <code>-mavx2</code>**：</p>
<ul>
<li>启用 <code>-mavx2</code> 后，因为AVX2支持更宽的向量操作（256位），所以会观察到进一步的性能提升。这表现为总体上更高的加速比，从2倍左右提高到3倍左右。</li>
</ul>
</li>
</ul>
<h4 id="推断AWS运行环境的向量寄存器宽度"><a href="#推断AWS运行环境的向量寄存器宽度" class="headerlink" title="推断AWS运行环境的向量寄存器宽度"></a><strong>推断AWS运行环境的向量寄存器宽度</strong></h4><ul>
<li><p><strong>默认向量寄存器宽度</strong>：</p>
<ul>
<li>如果未使用 <code>-mavx2</code> 标志时观察到了显著的加速，这暗示默认的向量寄存器是128位宽（标准AVX指令）。</li>
</ul>
</li>
<li><p><strong>AVX2向量寄存器宽度</strong>：</p>
<ul>
<li>使用 <code>-mavx2</code> 标志并观察到额外的性能提升，暗示AVX2向量寄存器宽度是256位。</li>
</ul>
</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>这些实验显示，向量化能显著提高数据并行任务的性能，尤其是在使用现代指令集如AVX2时。进一步分析这些数据，可以了解默认的向量寄存器和AVX2寄存器的宽度及其对性能的具体影响。此外，了解和选择合适的编译器标志对于充分利用现代硬件的向量处理能力至关重要。</p>
<h2 id="Write-up-7-比较向量化开启与未开启时的汇编代码"><a href="#Write-up-7-比较向量化开启与未开启时的汇编代码" class="headerlink" title="Write-up 7: 比较向量化开启与未开启时的汇编代码"></a>Write-up 7: 比较向量化开启与未开启时的汇编代码</h2><p>为了深入了解代码的向量化表现，可以直接查看编译器生成的汇编代码。通过分析这些代码，可以明确看到哪些指令被用于执行向量化操作，以及这些操作是如何被优化的。</p>
<h4 id="步骤和方法"><a href="#步骤和方法" class="headerlink" title="步骤和方法"></a><strong>步骤和方法</strong></h4><ol>
<li><p><strong>生成汇编代码</strong>：</p>
<ul>
<li>使用 <code>make ASSEMBLE=1 VECTORIZE=1</code> 命令生成启用向量化的汇编代码。</li>
<li>使用 <code>make ASSEMBLE=1 VECTORIZE=0</code> 生成未启用向量化的汇编代码。</li>
</ul>
</li>
<li><p><strong>检查汇编代码</strong>：</p>
<ul>
<li>打开生成的 <code>loop.s</code> 文件，查找与向量化操作相关的指令。</li>
</ul>
</li>
<li><p><strong>向量化指令对比</strong>：</p>
<ul>
<li>在启用向量化的代码中，寻找负责向量加法操作的指令。</li>
<li>再次编译代码，这次使用 <code>AVX2=1</code> 标志，查找与此设置相关的向量加法指令。</li>
</ul>
</li>
</ol>
<h4 id="汇编指令的识别"><a href="#汇编指令的识别" class="headerlink" title="汇编指令的识别"></a><strong>汇编指令的识别</strong></h4><ul>
<li><p><strong>不启用AVX2时的向量加法指令</strong>（基于SSE2指令集）：</p>
<ul>
<li>通常使用 <code>addpd</code> 或 <code>addps</code> 指令进行双精度或单精度的向量加法。</li>
<li>示例指令：<code>addpd %xmm1, %xmm0</code></li>
<li>这指令将 <code>%xmm1</code> 寄存器中的数据加到 <code>%xmm0</code> 寄存器中的数据。</li>
</ul>
</li>
<li><p><strong>启用AVX2时的向量加法指令</strong>：</p>
<ul>
<li>在AVX2指令集中，可以使用 <code>vaddpd</code> 或 <code>vaddps</code> 指令进行更宽向量寄存器的加法操作。</li>
<li>示例指令：<code>vaddpd %ymm1, %ymm0, %ymm0</code></li>
<li>这指令将 <code>%ymm1</code> 中的数据与 <code>%ymm0</code> 中的数据相加，结果存回 <code>%ymm0</code>。</li>
</ul>
</li>
</ul>
<h4 id="性能和优化"><a href="#性能和优化" class="headerlink" title="性能和优化"></a><strong>性能和优化</strong></h4><ul>
<li><p><strong>分析向量化的效果</strong>：</p>
<ul>
<li>观察启用和未启用向量化时汇编代码的差异，特别是循环结构和操作的表示。</li>
<li>检查是否有额外的优化，如循环展开或特定的数据预取指令，这些在启用向量化时出现。</li>
</ul>
</li>
<li><p><strong>改善汇编代码的可读性</strong>：</p>
<ul>
<li>考虑在Makefile中移除 <code>-g</code> 和 <code>-gdwarf-3</code> 标志，以减少调试符号，使汇编代码更加简洁。</li>
<li>使用 <code>-fno-unroll-loops</code> 标志有助于更清晰地观察循环的向量化情况，因为这可以防止编译器自动展开循环。</li>
</ul>
</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>通过比较不同编译标志下的汇编输出，可以具体了解编译器如何处理向量化指令，以及这些指令对程序性能的潜在影响。理解这些基础可以帮助开发者优化代码，并充分利用现代处理器的向量处理能力。</p>
<h2 id="Write-up-8-使用-OP-宏实验不同的运算符"><a href="#Write-up-8-使用-OP-宏实验不同的运算符" class="headerlink" title="Write-up 8: 使用 OP 宏实验不同的运算符"></a>Write-up 8: 使用 <strong>OP</strong> 宏实验不同的运算符</h2><p>在本实验中，通过更改数据并行循环中的运算符来测试不同类型的向量运算。在这个实验中，运算符由一个宏 <code>__OP__</code> 定义，能够轻松地更换使用的运算符，并观察其对向量化的影响。</p>
<h4 id="操作符的修改和初始化问题"><a href="#操作符的修改和初始化问题" class="headerlink" title="操作符的修改和初始化问题"></a><strong>操作符的修改和初始化问题</strong></h4><ol>
<li><strong>初始化问题</strong>：<ul>
<li>由于数组 B 被初始化为全零，使用 <code>/</code> 或 <code>%</code> 运算符时会导致除零错误。为解决这个问题，可以在初始化数组 B 时填充非零值，例如使用 <code>1</code> 来避免除零错误。</li>
</ul>
</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">    b[i] = <span class="number">1</span>; <span class="comment">// 设置为非零值以避免除零错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>改变运算符</strong>：<ul>
<li>修改数据并行循环中使用的运算符，例如尝试使用加 (<code>+</code>), 减 (<code>-</code>), 乘 (<code>*</code>), 除 (<code>/</code>), 和位移 (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>) 等运算。</li>
</ul>
</li>
</ol>
<h4 id="向量化的观察"><a href="#向量化的观察" class="headerlink" title="向量化的观察"></a><strong>向量化的观察</strong></h4><ul>
<li><strong>不同运算符的向量化表现</strong>：<ul>
<li>大多数基本算术运算（加、减、乘、除）都应该能够在启用 <code>VECTORIZE=1 AVX2=1</code> 时被成功向量化，因为现代向量处理单元支持这些操作的硬件实现。</li>
<li>对于位移运算符如 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code>，向量化可能更复杂，因为它们通常需要不同的硬件支持。</li>
</ul>
</li>
</ul>
<h4 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a><strong>汇编代码分析</strong></h4><ul>
<li><p><strong>VECTORIZE&#x3D;1 的位移运算</strong>：</p>
<ul>
<li>在只启用 <code>VECTORIZE=1</code> 时，编译器可能使用标准的向量位移指令（如 <code>pslld</code> 或 <code>psrlq</code> 等）处理整数数组的位移。</li>
<li>示例指令：<code>pslld xmm0, 1</code>（将 <code>xmm0</code> 寄存器中的值左移1位）。</li>
</ul>
</li>
<li><p><strong>VECTORIZE&#x3D;1 AVX2&#x3D;1 的位移运算</strong>：</p>
<ul>
<li>启用 <code>AVX2=1</code> 后，编译器可使用更宽的向量寄存器（如 <code>ymm</code>），并可能使用相应的AVX2位移指令（如 <code>vpslld ymm0, ymm1, imm8</code>）。</li>
<li>示例指令：<code>vpslld ymm0, ymm1, 1</code>（将 <code>ymm1</code> 寄存器中的值左移1位，并存入 <code>ymm0</code>）。</li>
</ul>
</li>
</ul>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>实验表明，大多数基本算术运算符可以成功向量化，而位移运算符的向量化可能取决于具体的编译器实现和目标硬件的支持。了解和选择合适的编译器标志和硬件指令集对充分利用向量处理能力至关重要。此外，适当的数组初始化也是避免运行时错误的关键。</p>
<h2 id="Write-up-9-比较不同数据类型对向量化性能的影响"><a href="#Write-up-9-比较不同数据类型对向量化性能的影响" class="headerlink" title="Write-up 9: 比较不同数据类型对向量化性能的影响"></a>Write-up 9: 比较不同数据类型对向量化性能的影响</h2><p>在本实验中，会探索改变数据类型对内存需求和向量包装能力的影响，特别是在使用加法运算符时，对比使用 <code>uint64_t</code>, <code>uint32_t</code>, <code>uint16_t</code>, 和 <code>uint8_t</code> 数据类型的向量化代码与非向量化代码之间的性能差异。</p>
<h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>数据类型更改</strong>：改变数组A、B、C的数据类型，分别从 <code>uint64_t</code> 到 <code>uint8_t</code>。</li>
<li><strong>运算符设置</strong>：设置运算符 <code>OP</code> 为加法 <code>+</code>。</li>
<li><strong>编译和运行</strong>：分别为每种数据类型编译和运行代码，一次不启用向量化，一次启用AVX2向量化。</li>
<li><strong>性能测量</strong>：记录每种情况下的执行时间，并计算向量化代码相对于非向量化代码的加速比。</li>
</ul>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ol>
<li><p>**<code>uint64_t</code>**：</p>
<ul>
<li>非向量化代码表现较差，因为每次操作的数据量较大。</li>
<li>向量化代码（尤其是AVX2）显示出一定的加速，但由于寄存器宽度限制，每个寄存器只能包含较少的元素。</li>
</ul>
</li>
<li><p>**<code>uint32_t</code>**：</p>
<ul>
<li>这是较常见的选择，向量化可以较好地加速，因为一个256位的AVX2寄存器可以包含8个 <code>uint32_t</code> 元素。</li>
</ul>
</li>
<li><p>**<code>uint16_t</code>**：</p>
<ul>
<li>内存需求更小，每个向量寄存器可以包含更多元素（例如，16个元素），这导致更高的加速比。</li>
</ul>
</li>
<li><p>**<code>uint8_t</code>**：</p>
<ul>
<li>每个向量寄存器可以包含更多的元素（如32个），这提供最高的加速比，因为更多的操作可以并行执行。</li>
</ul>
</li>
</ol>
<h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a><strong>性能提升</strong></h4><ul>
<li><p><strong>向量化代码相比于非向量化代码</strong>：</p>
<ul>
<li>对于所有数据类型，向量化通常都会带来性能提升。特别是当数据类型较小（如 <code>uint16_t</code> 和 <code>uint8_t</code>）时，加速比更为显著，因为可以在每个向量操作中处理更多元素。</li>
</ul>
</li>
<li><p><strong>AVX2向量化代码相比于非向量化代码</strong>：</p>
<ul>
<li>使用AVX2时，加速比通常会进一步提高，因为AVX2支持更宽的向量操作，可以一次处理更多的数据。</li>
</ul>
</li>
</ul>
<h4 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>数据类型对于向量化的性能影响显著。选择较小的数据类型可以减少内存需求并增加向量寄存器中可以包装的元素数量，从而提高性能。在设计和优化向量化应用程序时，应仔细考虑数据类型的选择以最大化性能。</p>
<h2 id="Write-up-10-测试使用-uint64-t-和-uint8-t-类型的向量乘法性能"><a href="#Write-up-10-测试使用-uint64-t-和-uint8-t-类型的向量乘法性能" class="headerlink" title="Write-up 10: 测试使用 uint64_t 和 uint8_t 类型的向量乘法性能"></a>Write-up 10: 测试使用 <code>uint64_t</code> 和 <code>uint8_t</code> 类型的向量乘法性能</h2><p>在此实验中探索使用不同数据类型（特别是 <code>uint64_t</code> 和 <code>uint8_t</code>）对于向量化代码在执行乘法操作时的性能影响。乘法操作相对于加法需要更多的时钟周期，这会影响向量化带来的性能提升。</p>
<h4 id="实验设置-1"><a href="#实验设置-1" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>数据类型</strong>：<code>uint64_t</code> 和 <code>uint8_t</code>。</li>
<li><strong>操作符</strong>：乘法 (<code>*</code>)。</li>
<li><strong>编译和测试</strong>：<ul>
<li>对于 <code>uint64_t</code> 和 <code>uint8_t</code>，分别编译并运行使用乘法的向量化和非向量化代码。</li>
<li>使用 <code>VECTORIZE=1</code> 和 <code>VECTORIZE=1 AVX2=1</code> 标志进行编译。</li>
</ul>
</li>
</ul>
<h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ol>
<li><p><strong><code>uint64_t</code> 数据类型</strong>：</p>
<ul>
<li><strong>非向量化代码</strong>：执行较慢，因为每次操作处理的数据量较大，且乘法操作相对耗时。</li>
<li><strong>向量化代码</strong>（AVX2）：虽然向量化可以提供一定程度的加速，但由于 <code>uint64_t</code> 数据类型的元素宽度较大，每个向量寄存器能处理的元素数量较少，限制了向量化的效益。</li>
</ul>
</li>
<li><p><strong><code>uint8_t</code> 数据类型</strong>：</p>
<ul>
<li><strong>非向量化代码</strong>：相对较慢，但由于处理的数据单元较小，所需的时钟周期较少。</li>
<li><strong>向量化代码</strong>（AVX2）：由于 <code>uint8_t</code> 类型允许单个向量寄存器包含更多元素（例如AVX2的32个元素），向量化提供了显著的加速。这种情况下，向量化乘法可以极大提升性能，因为可以同时处理更多的数据。</li>
</ul>
</li>
</ol>
<h4 id="性能提升-1"><a href="#性能提升-1" class="headerlink" title="性能提升"></a><strong>性能提升</strong></h4><ul>
<li>对于 <code>uint64_t</code> 类型，向量化的性能提升相对有限，只有轻微的改善，1.5倍左右的加速。</li>
<li>对于 <code>uint8_t</code> 类型，由于可以在一个操作中处理更多元素，加速比会更高，达到了4倍左右。</li>
</ul>
<h4 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>向量化在执行数据并行操作时能显著提高性能，特别是当操作单元较小时（如 <code>uint8_t</code>）。选择更小的数据类型可以增加向量寄存器中的元素数量，从而提高每次向量操作的效率。对于乘法这样的高成本操作，向量化的好处尤其明显。然而，对于较大的数据类型（如 <code>uint64_t</code>），尽管向量化能带来性能改善，其提升幅度有限，特别是当每个向量寄存器能处理的元素数量较少时。</p>
<h2 id="Write-up-11-分析使用-uint64-t-类型的AVX2向量化乘法与加法代码的性能"><a href="#Write-up-11-分析使用-uint64-t-类型的AVX2向量化乘法与加法代码的性能" class="headerlink" title="Write-up 11: 分析使用 uint64_t 类型的AVX2向量化乘法与加法代码的性能"></a>Write-up 11: 分析使用 <code>uint64_t</code> 类型的AVX2向量化乘法与加法代码的性能</h2><p>在这个实验中，使用 <code>awsrun perf record</code> 工具来收集使用 <code>uint64_t</code> 类型的AVX2向量化乘法操作的性能数据，然后通过 <code>aws-perf-report</code> 工具来分析哪些操作占用了最多的执行时间。比较乘法操作与加法操作在向量化环境中的性能差异。</p>
<h4 id="步骤和方法-1"><a href="#步骤和方法-1" class="headerlink" title="步骤和方法"></a><strong>步骤和方法</strong></h4><ol>
<li><p><strong>收集性能数据</strong>：</p>
<ul>
<li>对于乘法 (<code>*</code>) 操作，设置 <code>__OP__</code> 为乘法并使用 <code>awsrun perf record</code> 来执行程序，收集性能数据。</li>
<li>对于加法 (<code>+</code>) 操作，将 <code>__OP__</code> 改回加法并重复性能数据收集过程。</li>
</ul>
</li>
<li><p><strong>分析性能报告</strong>：</p>
<ul>
<li>使用 <code>aws-perf-report</code> 来分析收集到的性能数据，特别注意向量乘法与向量加法指令的执行时间占比。</li>
</ul>
</li>
</ol>
<h4 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ul>
<li><p><strong>向量乘法 (<code>*</code>) 性能分析</strong>：</p>
<ul>
<li>向量化的乘法操作会消耗较多的CPU时间，因为向量乘法相对于加法需要更多的时钟周期。</li>
<li>检查性能报告，观察是否有大量时间被消耗在 <code>vpmulld</code>（向量乘法）或其他相关向量乘法指令上。</li>
</ul>
</li>
<li><p><strong>向量加法 (<code>+</code>) 性能分析</strong>：</p>
<ul>
<li>向量加法操作通常需要较少的时钟周期，因此相比于向量乘法，其在性能报告中占用的时间比例较低。</li>
<li>分析性能报告，确认向量加法指令如 <code>vpadd</code> 在总执行时间中的占比。</li>
</ul>
</li>
</ul>
<h4 id="实验结果和结论"><a href="#实验结果和结论" class="headerlink" title="实验结果和结论"></a><strong>实验结果和结论</strong></h4><ul>
<li><p><strong>向量乘法的时间占比</strong>：</p>
<ul>
<li>如果发现向量乘法操作并没有占用大部分时间，可能的原因包括内存访问延迟或数据依赖导致的CPU空闲等。</li>
<li>分析是否有其他系统层面的操作（如内存加载）消耗了大量时间，这可能影响了整体的性能表现。</li>
</ul>
</li>
<li><p><strong>向量加法的时间占比</strong>：</p>
<ul>
<li>比较向量加法与乘法的性能数据，通常应观察到加法操作在性能报告中占用的时间比例较低，因为加法操作更快。</li>
</ul>
</li>
<li><p><strong>性能优化的见解</strong>：</p>
<ul>
<li>这种比较有助于理解不同向量操作的性能影响，为优化提供方向，尤其是在处理涉及复杂数据操作的应用时。</li>
<li>如果乘法操作占用过多时间，考虑优化算法或调整数据结构和访问模式，以减少性能瓶颈。</li>
</ul>
</li>
</ul>
<p>这项分析能够揭示在使用高级向量扩展时，不同算术操作在性能上的实际差异，从而为进一步的性能优化提供依据。</p>
<h2 id="Write-up-12-对于运行时确定的循环边界的向量化性能分析"><a href="#Write-up-12-对于运行时确定的循环边界的向量化性能分析" class="headerlink" title="Write-up 12: 对于运行时确定的循环边界的向量化性能分析"></a>Write-up 12: 对于运行时确定的循环边界的向量化性能分析</h2><p>在之前的实验中，循环的界限 <code>N</code> 是预先定义为1024的固定值，这使得编译器能够在编译时进行优化。改为在运行时通过命令行参数设置 <code>N</code>，将增加编译器处理向量化的复杂性，因为它不能再做出关于循环迭代次数的静态假设。</p>
<h4 id="实验设置-2"><a href="#实验设置-2" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>修改代码</strong>：将循环界限 <code>N</code> 的定义改为运行时决定：<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> N = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>编译和运行</strong>：对不同的 <code>N</code> 值（例如256, 512, 1024, 2048等）分别进行非向量化、AVX2向量化和非AVX2向量化的编译和测试。</li>
</ul>
<h4 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ul>
<li><p><strong>向量化与非向量化的比较</strong>：</p>
<ul>
<li>对于较小的 <code>N</code> 值，向量化代码不会显著优于非向量化代码，因为启动和管理向量操作的开销占据了较大比例。</li>
<li>随着 <code>N</code> 值的增加，向量化代码的性能优势应该更加明显，因为长循环更能够利用向量处理的并行性。</li>
</ul>
</li>
<li><p><strong>AVX2与非AVX2向量化的比较</strong>：</p>
<ul>
<li>使用AVX2指令集的向量化代码应该在所有 <code>N</code> 值下都显示出比普通向量化更好的性能，尤其是在 <code>N</code> 较大时，因为AVX2支持更宽的向量操作，可以处理更多数据。</li>
</ul>
</li>
</ul>
<h4 id="性能变化与-N-1024-的比较"><a href="#性能变化与-N-1024-的比较" class="headerlink" title="性能变化与 N = 1024 的比较"></a><strong>性能变化与 <code>N = 1024</code> 的比较</strong></h4><ul>
<li>当 <code>N</code> 较小（如256或以下）时，相对于 <code>N = 1024</code>，向量化带来的性能提升不那么显著。这是因为向量化的启动和管理成本在小规模数据上的相对影响更大。</li>
<li>当 <code>N</code> 较大（如2048或以上）时，向量化代码的性能提升应该比 <code>N = 1024</code> 时更加明显，因为较长的循环能更好地利用处理器的向量化能力，减少了相对开销。</li>
</ul>
<h4 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>改变 <code>N</code> 的定义使其在运行时确定，表明了编译器在处理不确定循环边界时的行为。虽然向量化在大多数情况下都能提供性能提升，但其效果受到循环长度的影响。实验结果显示，当循环边界较大时，向量化（尤其是使用AVX2）带来的性能提升更为显著。这强调了在设计向量化代码时，考虑数据规模和选择合适的编译器优化标志的重要性。</p>
<h2 id="Write-up-13-探索步长不为1时的向量化情况"><a href="#Write-up-13-探索步长不为1时的向量化情况" class="headerlink" title="Write-up 13: 探索步长不为1时的向量化情况"></a>Write-up 13: 探索步长不为1时的向量化情况</h2><p>在此实验中，调整数组遍历的步长（stride），并观察编译器是否能够向量化这样的循环。步长不为1意味着每次迭代跳过一个或多个元素，这可能影响编译器的向量化决策。</p>
<h4 id="实验设置-3"><a href="#实验设置-3" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>数据类型和操作</strong>：设置 <code>__TYPE__</code> 为 <code>uint32_t</code>，<code>__OP__</code> 设置为加法 (<code>+</code>)。</li>
<li><strong>修改循环结构</strong>：将内部循环修改为步长为2的循环：<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j += <span class="number">2</span>) &#123;</span><br><span class="line">    C[j] = A[j] + B[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a><strong>编译和运行</strong></h4><ul>
<li>使用相应的编译标志进行编译，检查编译器是否能够向量化这种带有特定步长的循环。</li>
</ul>
<h4 id="向量化的观察与分析"><a href="#向量化的观察与分析" class="headerlink" title="向量化的观察与分析"></a><strong>向量化的观察与分析</strong></h4><ul>
<li><p><strong>编译器的向量化决策</strong>：</p>
<ul>
<li>对于步长为2的循环，编译器不会选择向量化。这是因为非连续的内存访问模式降低了数据的局部性，从而影响了向量化的效率。</li>
<li>向量单位虽然可以支持不同的步长，但在步长增大时，需要额外的指令来处理间隔较大的元素加载，这导致性能不如步长为1时优秀。</li>
</ul>
</li>
<li><p><strong>为什么可能不向量化</strong>：</p>
<ul>
<li><strong>内存访问效率</strong>：步长为2可能导致内存访问不连续，使得处理器缓存利用率下降，进而影响性能。</li>
<li><strong>复杂度增加</strong>：处理不连续数据需要额外的逻辑和指令，如间隔加载和额外的数据对齐处理，增加了编译器的实现复杂度。</li>
<li><strong>硬件优化限制</strong>：尽管现代硬件支持多种步长，但对于较大的步长，硬件加速可能不如连续访问显著。</li>
</ul>
</li>
</ul>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a><strong>实验结果</strong></h4><ul>
<li>在实际测试中，发现即使硬件和编译器支持向量化步长不为1的循环，性能提升也不如连续访问的情况显著。这一结果应通过检查生成的汇编代码中是否包含向量指令以及这些指令的性能指标来确认。</li>
</ul>
<h4 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>调整循环的步长可以是一个重要的性能优化方向，尤其是在处理步长非1的数据访问模式时。然而，开发者需要仔细考虑步长变化对向量化的可能影响，并通过实验验证预期的优化效果。如果向量化未带来预期的性能提升，可能需要探索其他优化策略或调整算法结构以适应硬件的特性。</p>
<h2 id="Write-up-14-使用-pragma-clang-loop-指令优化向量化"><a href="#Write-up-14-使用-pragma-clang-loop-指令优化向量化" class="headerlink" title="Write-up 14: 使用 #pragma clang loop 指令优化向量化"></a>Write-up 14: 使用 <code>#pragma clang loop</code> 指令优化向量化</h2><p>为了强制编译器向量化一个步长不为1的循环，用 <code>#pragma clang loop</code> 指令，这是 Clang 提供的一种语言扩展，用于控制循环的优化。这允许开发者对编译器的循环优化行为进行更细致的控制，尤其是在向量化方面。</p>
<h4 id="实验设置-4"><a href="#实验设置-4" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><p><strong>修改代码</strong>：在步长为2的循环前添加 <code>#pragma clang loop vectorize(enable)</code> 来尝试强制向量化该循环。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang loop vectorize(enable)</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j += <span class="number">2</span>) &#123;</span><br><span class="line">    C[j] = A[j] + B[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译与测试</strong>：</p>
<ul>
<li>分别编译并运行未使用AVX2和使用AVX2的向量化代码，记录并比较执行时间。</li>
<li>尝试修改 <code>vectorize_width</code> 参数，比如设置为2，来看看对性能的影响。</li>
</ul>
</li>
</ul>
<h4 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ul>
<li><p><strong>基本向量化测试</strong>：</p>
<ul>
<li>使用基本的 <code>#pragma clang loop vectorize(enable)</code> 指令会看到一定的性能提升，因为编译器被提示尽可能向量化该循环。</li>
</ul>
</li>
<li><p>**修改 <code>vectorize_width</code>**：</p>
<ul>
<li>将 <code>vectorize_width</code> 设置为2会进一步影响性能，因为这指示编译器在向量化时使用更小的向量宽度。这对于步长为2的循环更为合适。</li>
</ul>
</li>
<li><p><strong>使用AVX2</strong>：</p>
<ul>
<li>启用AVX2向量化应该会看到更显著的性能提升，因为AVX2支持更宽的向量操作，可以更有效地处理数据。</li>
</ul>
</li>
</ul>
<h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a><strong>实验结果</strong></h4><ul>
<li>在不同的 <code>vectorize_width</code> 和是否使用AVX2的条件下，性能提升会有所不同。通常，使用AVX2的向量化代码相比于非向量化代码会有更明显的加速。</li>
<li>如果适当调整 <code>vectorize_width</code>，比如设置为与数据访问模式更匹配的值，会进一步优化性能。</li>
</ul>
<h4 id="最佳配置"><a href="#最佳配置" class="headerlink" title="最佳配置"></a><strong>最佳配置</strong></h4><ul>
<li>最佳配置会根据具体的循环内容和数据访问模式而变化。在一些情况下，适当地使用 <code>#pragma clang loop</code> 指令并调整相关参数可以显著提高向量化代码的性能。</li>
</ul>
<h4 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>通过使用 <code>#pragma clang loop</code> 指令，能够更精细地控制编译器的向量化行为，特别是在处理具有复杂访问模式的循环时。在合适的配置下，向量化代码相比于非向量化代码确实能够提供显著的性能提升。这种控制手段为性能优化提供了更多的可能性，尤其是在需要手动调整编译器行为以适应特定算法的情况下。</p>
<h2 id="Write-up-15-分析数组求和向量化的汇编实现"><a href="#Write-up-15-分析数组求和向量化的汇编实现" class="headerlink" title="Write-up 15: 分析数组求和向量化的汇编实现"></a>Write-up 15: 分析数组求和向量化的汇编实现</h2><p>在本实验中，通过汇编代码来理解编译器是如何向量化数组求和（reduction）操作的。向量化的求和操作对于理解数据归约在现代处理器上的效率至关重要。</p>
<h4 id="实验设置-5"><a href="#实验设置-5" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><p><strong>修改代码</strong>：实现一个简单的数组求和循环，确保该循环是向量化的重点。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    total += A[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译并生成汇编代码</strong>：</p>
<ul>
<li>使用 <code>make ASSEMBLE=1</code> 编译代码，以生成详细的汇编代码文件，从而能够详细查看向量化实现。</li>
</ul>
</li>
</ul>
<h4 id="汇编代码分析-1"><a href="#汇编代码分析-1" class="headerlink" title="汇编代码分析"></a><strong>汇编代码分析</strong></h4><ul>
<li><p><strong>向量化操作的实现</strong>：</p>
<ul>
<li>在生成的汇编代码中，编译器通常会使用如 <code>vpaddd</code>（向量化整数加法）等指令来实现数组的求和。</li>
<li>编译器会将数组元素加载到多个向量寄存器中，然后在这些寄存器上执行并行加法操作。</li>
</ul>
</li>
<li><p><strong>具体的汇编指令</strong>：</p>
<ul>
<li>例如，编译器使用 <code>movdqa</code> 指令加载数据到 SIMD 寄存器（如 <code>xmm0</code>），然后使用 <code>paddd xmm0, xmm1</code> 将两个寄存器中的数据相加，实现部分和的累加。</li>
<li>对于更高位宽的指令集（如AVX2），会看到使用 <code>vpaddd ymm0, ymm0, ymm1</code> 这样的指令，这可以同时处理更多数据。</li>
</ul>
</li>
<li><p><strong>循环尾部处理</strong>：</p>
<ul>
<li>在处理不完全填充向量寄存器的数据时，编译器还会生成处理循环尾部（即数组大小不是向量宽度整数倍部分）的代码。</li>
<li>这通常涉及到在循环结束时对剩余元素进行标量处理，以确保所有元素都被正确求和。</li>
</ul>
</li>
</ul>
<h4 id="性能优化的观察"><a href="#性能优化的观察" class="headerlink" title="性能优化的观察"></a><strong>性能优化的观察</strong></h4><ul>
<li><p><strong>归约操作的并行化</strong>：</p>
<ul>
<li>通过将多次独立的加法操作合并到单个向量指令中，归约操作的向量化显著提高了处理速度。</li>
<li>向量化归约减少了执行的指令数量，并提高了数据通过率。</li>
</ul>
</li>
<li><p><strong>编译器优化的限制</strong>：</p>
<ul>
<li>虽然向量化可以显著加快归约操作的速度，但编译器在实现这一过程时需要插入额外的逻辑来处理边界情况，这些逻辑会稍微影响性能。</li>
</ul>
</li>
</ul>
<h4 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>汇编代码分析揭示了编译器如何有效地实现向量化数组求和操作。通过并行处理多个数组元素，向量化显著提高了性能。然而，为了完全理解和优化这类操作，开发者需要注意编译器如何处理向量化操作的细节，包括数据加载、并行执行和循环尾部处理。这些知识对于编写高效的向量化代码至关重要。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL——模拟地月系技术报告</title>
    <url>/2024/04/15/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h3 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h3><p>本项目是一个基于OpenGL的地月系动态模拟。通过OpenGL和GLUT库，实现了地球和月球的三维视觉效果，包括地球的自转和月球的公转，同时加入了相机控制以增强交互性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/em0.gif"
                      alt="GIF 2024-4-15 16-00-08"
                ></p>
<h3 id="2-环境配置和依赖库"><a href="#2-环境配置和依赖库" class="headerlink" title="2. 环境配置和依赖库"></a>2. 环境配置和依赖库</h3><p>本项目使用了以下主要库和技术：</p>
<ul>
<li><p><strong>OpenGL Utility Toolkit (GLUT)</strong>: 用于创建和管理窗口，处理用户输入（如键盘和鼠标事件），以及其他与窗口系统交互的基本任务。GLUT简化了OpenGL程序的窗口管理代码，使开发者能够专注于核心的图形渲染。</p>
</li>
<li><p><strong>stb_image.h</strong>: 这是一个非常流行的单头文件图像加载库，用于加载各种格式的图像文件。在本项目中，<code>stb_image.h</code> 被用来加载地球的纹理图像，这是纹理映射中的关键步骤。</p>
</li>
<li><p><strong>C++ 标准库</strong>: 包括iostream用于输入输出操作，cmath用于执行数学运算。cmath库特别重要，因为它提供了基本的数学函数如sin、cos等，这些都是在计算相机移动和控制动画时不可或缺的。</p>
</li>
</ul>
<h3 id="3-主要功能与技术点"><a href="#3-主要功能与技术点" class="headerlink" title="3. 主要功能与技术点"></a>3. 主要功能与技术点</h3><h4 id="3-1-纹理映射"><a href="#3-1-纹理映射" class="headerlink" title="3.1 纹理映射"></a>3.1 纹理映射</h4><p>纹理映射是三维图形中用于增加物体表面细节的技术。在本项目中，使用纹理映射来模拟地球表面的复杂纹理。</p>
<p><strong>关键代码及其解释</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">loadTexture</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data = <span class="built_in">stbi_load</span>(path, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    GLuint textureID;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此函数<code>loadTexture</code>负责加载图像文件作为纹理。使用<code>stbi_load</code>从指定路径加载图像，之后创建一个OpenGL纹理对象，并将图像数据绑定到此纹理对象。此操作确保了图形界面能够以高质量显示地球表面。</p>
<h4 id="3-2-相机控制"><a href="#3-2-相机控制" class="headerlink" title="3.2 相机控制"></a>3.2 相机控制</h4><p>相机控制允许用户通过键盘和鼠标改变观察视角，增加了应用的交互性和灵活性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/em1.gif"
                      alt="GIF 2024-4-15 16-26-33"
                ></p>
<p><strong>键盘控制代码及其解释</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateCameraPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> radianHorizontal = cameraAngleHorizontal * M_PI / <span class="number">180.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (keyStates[<span class="string">&#x27;w&#x27;</span>]) &#123;</span><br><span class="line">        cameraX += <span class="built_in">sin</span>(radianHorizontal) * <span class="number">0.01f</span>;</span><br><span class="line">        cameraZ -= <span class="built_in">cos</span>(radianHorizontal) * <span class="number">0.01f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样处理&#x27;s&#x27;, &#x27;a&#x27;, &#x27;d&#x27;按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在此函数中，根据键盘输入更新相机位置。<code>w</code>键使相机向前移动，通过计算角度的正弦和余弦值来更新<code>cameraX</code>和<code>cameraZ</code>，模拟前进的效果。类似地，<code>s</code>、<code>a</code>、<code>d</code>键分别用于后退和左右移动。</p>
<p><strong>鼠标控制代码及其解释</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMove</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> deltaX = lastX - x;</span><br><span class="line">    <span class="type">int</span> deltaY = y - lastY;</span><br><span class="line">    cameraAngleHorizontal += deltaX * sensitivity;</span><br><span class="line">    cameraAngleVertical += deltaY * sensitivity;</span><br><span class="line">    cameraAngleVertical = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(cameraAngleVertical, <span class="number">89.0f</span>), <span class="number">-89.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此函数处理鼠标移动事件，通过计算鼠标位置的变化（<code>deltaX</code>, <code>deltaY</code>），动态调整相机的水平和垂直角度，实现视角的上下左右旋转。限制垂直角度在-89到89度之间防止视角翻转。</p>
<h4 id="3-3-动态交互"><a href="#3-3-动态交互" class="headerlink" title="3.3 动态交互"></a>3.3 动态交互</h4><p>动态交互功能允许用户实时调整模拟的速度，增强了用户体验。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/em2.gif"
                      alt="GIF 2024-4-15 16-33-07"
                ></p>
<p><strong>速度调整代码及其解释</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myAnimate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keyStates[<span class="string">&#x27;p&#x27;</span>]) &#123; speed += <span class="number">0.01</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (keyStates[<span class="string">&#x27;o&#x27;</span>] &amp;&amp; speed &gt; <span class="number">0</span>) &#123; speed -= <span class="number">0.01</span>; &#125;</span><br><span class="line">    Y += <span class="number">0.5</span> * speed;</span><br><span class="line">    moonY += <span class="number">0.2</span> * speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<code>myAnimate</code>函数中，根据按键状态增加或减少动画速度。<code>p</code>键提高速度，<code>o</code>键降低速度。随后更新地球和月球的旋转角度，以模拟自转和公转。这个简单的交互使用户能够控制动画的快慢，增加了应用的可玩性和教育意义。</p>
<h4 id="3-4-三维投影与模型变换"><a href="#3-4-三维投影与模型变换" class="headerlink" title="3.4 三维投影与模型变换"></a>3.4 三维投影与模型变换</h4><p>三维投影和模型变换是实现准确和动态视觉效果的关键。这些技术允许我们以逼真的方式渲染三维场景，模拟真实世界中的视觉体验。</p>
<p><strong>透视投影设置代码及其解释</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reshape</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_PROJECTION);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>();</span><br><span class="line">    <span class="built_in">gluPerspective</span>(<span class="number">60.0</span>, (GLfloat)w / (GLfloat)h, <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>reshape</code>函数在窗口尺寸改变时调用，用于更新视口（<code>glViewport</code>）和投影矩阵。<code>gluPerspective</code>定义了一个视角为60度的透视投影，这个设置影响了场景中对象的视觉深度和透视效果。</p>
<p><strong>模型变换示例（地球自转）代码及其解释</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glPushMatrix</span>();</span><br><span class="line"><span class="built_in">glRotatef</span>(Y, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">gluSphere</span>(quad, <span class="number">0.2</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="built_in">glPopMatrix</span>();</span><br></pre></td></tr></table></figure></div>
<p>此处使用<code>glPushMatrix</code>和<code>glPopMatrix</code>保持当前的模型矩阵，<code>glRotatef</code>根据变量<code>Y</code>（代表地球自转的角度）绕y轴旋转地球。这种方式使得地球可以连续自转，而不影响其他对象的位置。</p>
<h4 id="3-5-场景渲染"><a href="#3-5-场景渲染" class="headerlink" title="3.5 场景渲染"></a>3.5 场景渲染</h4><p>场景的正确渲染对于任何图形应用都是基础，本项目中通过OpenGL进行精确控制。</p>
<p><strong>场景渲染代码及其解释</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDisplay</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_MODELVIEW);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>();</span><br><span class="line">    <span class="built_in">gluLookAt</span>(cameraX, cameraY, cameraZ, lookX, lookY, lookZ, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    <span class="comment">// 更多渲染代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<code>myDisplay</code>函数中，首先使用<code>glClear</code>清除颜色和深度缓冲，以准备新的绘制。<code>glMatrixMode</code>设置当前矩阵模式为模型视图，以便更新相机视角或对象位置。<code>gluLookAt</code>定义了相机的位置和朝向，这是观察三维场景的视点。随后的代码负责渲染地球、月球等对象。</p>
<h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h3><p>为保证模拟的流畅性，项目中采用了双缓冲机制 (<code>GLUT_DOUBLE</code>) 减少画面闪烁，并启用深度测试 (<code>GL_DEPTH_TEST</code>) 确保三维场景的正确渲染顺序。这些技术的使用对于创建高质量的实时渲染应用是至关重要的。</p>
<h3 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h3><p>通过本项目的开发和撰写技术报告，我对OpenGL及其应用在实时三维图形渲染中的机制有了更深入的理解。此次地月系模拟项目不仅巩固了我在纹理映射、相机控制、动态交互及三维投影和模型变换等核心OpenGL技术的应用能力，也提升了我在编写高效且互动性强的图形应用方面的技能。</p>
<p>作为一名希望进入游戏开发行业的软件开发者，我认为通过这样的项目，我能够更好地展示自己的技术能力和解决问题的方法。虽然我在这一领域还有很多需要学习的地方，但我相信这些经验将对我的职业生涯发展有所帮助。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>游戏设计与开发</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作品集</tag>
        <tag>OpenGL</tag>
        <tag>技术报告</tag>
      </tags>
  </entry>
  <entry>
    <title>C++——经典游戏《潜艇大战》改编练习</title>
    <url>/2024/03/12/c/</url>
    <content><![CDATA[<h2 id="原版效果："><a href="#原版效果：" class="headerlink" title="原版效果："></a>原版效果：</h2><h3 id="依靠鼠标点击去炸毁潜艇得分，类似打地鼠："><a href="#依靠鼠标点击去炸毁潜艇得分，类似打地鼠：" class="headerlink" title="依靠鼠标点击去炸毁潜艇得分，类似打地鼠："></a>依靠鼠标点击去炸毁潜艇得分，类似打地鼠：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%BB%8F%E5%85%B8C++%E6%B8%B8%E6%88%8F%E3%80%8A%E6%BD%9C%E8%89%87%E5%A4%A7%E6%88%98%E3%80%8B%E6%94%B9%E7%BC%96%E7%BB%83%E4%B9%A0/ShipDemo_old.gif"
                      alt="ShipDemo_old"
                ></p>
<h2 id="改编效果："><a href="#改编效果：" class="headerlink" title="改编效果："></a>改编效果：</h2><h3 id="靠船左右移动投炸弹炸毁潜艇得分："><a href="#靠船左右移动投炸弹炸毁潜艇得分：" class="headerlink" title="靠船左右移动投炸弹炸毁潜艇得分："></a>靠船左右移动投炸弹炸毁潜艇得分：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%BB%8F%E5%85%B8C++%E6%B8%B8%E6%88%8F%E3%80%8A%E6%BD%9C%E8%89%87%E5%A4%A7%E6%88%98%E3%80%8B%E6%94%B9%E7%BC%96%E7%BB%83%E4%B9%A0/ShipDemo_new.gif"
                      alt="ShipDemo_new"
                ></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本报告详细分析了《潜艇大战》游戏从原版到改编版本中的关键代码变化。原版游戏的核心玩法是使用鼠标点击来炸毁潜艇并得分，类似于“打地鼠”的游戏模式。改编版本则通过控制船的左右移动并投掷炸弹来炸毁潜艇以得分。</p>
<h2 id="1-核心视图类-CChildView-类分析"><a href="#1-核心视图类-CChildView-类分析" class="headerlink" title="1. 核心视图类 (CChildView) 类分析"></a>1. 核心视图类 (<code>CChildView</code>) 类分析</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>CChildView</code> 类是《潜艇大战》游戏的核心视图类，负责管理游戏对象、处理用户输入、绘制游戏界面等。</p>
<h3 id="OnTimer-方法分析"><a href="#OnTimer-方法分析" class="headerlink" title="OnTimer 方法分析"></a><code>OnTimer</code> 方法分析</h3><h4 id="创建和管理潜艇"><a href="#创建和管理潜艇" class="headerlink" title="创建和管理潜艇"></a>创建和管理潜艇</h4><p><strong>潜艇创建逻辑</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nCreator==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_Objects.<span class="built_in">AddTail</span>(<span class="keyword">new</span> <span class="built_in">CSubmarine</span>(<span class="built_in">random</span>(<span class="number">2</span>)%<span class="number">2</span>?<span class="literal">true</span>:<span class="literal">false</span>, <span class="built_in">random</span>(GAME_HEIGHT-SHIP_VERT_POS-SHIP_HEIGHT*<span class="number">2</span><span class="number">-30</span>)+SHIP_VERT_POS+SHIP_HEIGHT+<span class="number">30</span>, <span class="built_in">random</span>(<span class="number">4</span>), <span class="built_in">random</span>(<span class="number">4</span>)+<span class="number">3</span>));</span><br><span class="line">    nCreator = <span class="built_in">random</span>(<span class="number">50</span>) + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>nCreator</code> 用于控制潜艇生成的时间间隔。当它变为 0，代码会创建一个新的 <code>CSubmarine</code> 对象并将其添加到游戏对象列表 <code>m_Objects</code>。</li>
<li>每个潜艇的位置、类型和速度都是随机生成的，提供了游戏的可变性和挑战性。</li>
</ul>
<p><strong>潜艇管理逻辑</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">POSITION pos1, pos2;</span><br><span class="line"><span class="keyword">for</span>(pos1=m_Objects.<span class="built_in">GetHeadPosition</span>(); (pos2=pos1)!=<span class="literal">NULL</span>;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(((CMyObject*)m_Objects.<span class="built_in">GetNext</span>(pos1))-&gt;<span class="built_in">Draw</span>(&amp;m_VirtualDC, m_bGamePause))</span><br><span class="line">    &#123;</span><br><span class="line">        pLastObj = m_Objects.<span class="built_in">GetAt</span>(pos2);</span><br><span class="line">        m_Objects.<span class="built_in">RemoveAt</span>(pos2);</span><br><span class="line">        <span class="keyword">delete</span> pLastObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这段代码遍历 <code>m_Objects</code> 中的所有游戏对象，并对它们调用 <code>Draw</code> 方法。</li>
<li>如果 <code>Draw</code> 方法返回 <code>true</code>，表明对象（如潜艇）需要被移除。这通常在对象（如潜艇被击中或移动出屏幕）结束其生命周期时发生。</li>
</ul>
<h4 id="游戏画面渲染"><a href="#游戏画面渲染" class="headerlink" title="游戏画面渲染"></a>游戏画面渲染</h4><p><strong>背景绘制</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m_VirtualDC.<span class="built_in">FillSolidRect</span>(<span class="number">0</span>, <span class="number">0</span>, GAME_WIDTH, SHIP_VERT_POS+SHIP_HEIGHT<span class="number">-5</span>, SKY_COLOR);</span><br><span class="line">m_VirtualDC.<span class="built_in">FillSolidRect</span>(<span class="number">0</span>, SHIP_VERT_POS+SHIP_HEIGHT<span class="number">-5</span>, GAME_WIDTH, GAME_HEIGHT, SEA_COLOR);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这里使用 <code>FillSolidRect</code> 在虚拟设备上下文 <code>m_VirtualDC</code> 上绘制天空和海洋背景。</li>
<li><code>SKY_COLOR</code> 和 <code>SEA_COLOR</code> 定义了天空和海洋的颜色。</li>
</ul>
<p><strong>最终渲染到屏幕</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">dc.<span class="built_in">BitBlt</span>(<span class="number">0</span>, <span class="number">0</span>, GAME_WIDTH, GAME_HEIGHT, &amp;m_VirtualDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用 <code>BitBlt</code> 方法将虚拟设备上下文的内容传输到实际的屏幕上下文。</li>
<li>这种方法可以避免闪烁并提高绘图效率。</li>
</ul>
<h4 id="其他重要逻辑"><a href="#其他重要逻辑" class="headerlink" title="其他重要逻辑"></a>其他重要逻辑</h4><p><strong>游戏暂停功能</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m_bGamePause) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>控制游戏暂停。当 <code>m_bGamePause</code> 为 <code>true</code> 时，<code>OnTimer</code> 将提前返回，不执行任何游戏更新逻辑。</li>
</ul>
<p><strong>潜艇生成计数器更新</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">nCreator--;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>nCreator</code> 每次 <code>OnTimer</code> 被调用时递减，控制潜艇的生成频率。</li>
</ul>
<p>总结来说，<code>OnTimer</code> 方法是游戏的心脏，负责潜艇的生成和管理、游戏画面的更新和渲染，以及控制游戏的暂停和继续。这个方法充分展示了游戏循环的典型结构，包括对象管理、状态更新和画面渲染。</p>
<h2 id="2-潜艇类-CSubmarine-的变更"><a href="#2-潜艇类-CSubmarine-的变更" class="headerlink" title="2. 潜艇类 (CSubmarine) 的变更"></a>2. 潜艇类 (<code>CSubmarine</code>) 的变更</h2><h3 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h3><p>在原版中，<code>CSubmarine</code> 类主要负责潜艇的初始化、移动、绘图和销毁。这个类使用了 <code>CImageList</code> 来处理潜艇的图像。潜艇的移动是基于它们的方向 (<code>m_bDirect</code>) 和速度 (<code>m_nSpeed</code>)。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CSubmarine::<span class="built_in">CSubmarine</span>(<span class="type">bool</span> bDir, <span class="type">int</span> nVert, <span class="type">int</span> nType, <span class="type">int</span> nSpeed)</span><br><span class="line">&#123;</span><br><span class="line">    m_bDirect = bDir;</span><br><span class="line">    m_ptPos.x = m_bDirect ? GAME_WIDTH : -SUBMARINE_WIDTH;</span><br><span class="line">    m_ptPos.y = nVert;</span><br><span class="line">    <span class="comment">// ...[其他初始化代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="改编版本"><a href="#改编版本" class="headerlink" title="改编版本"></a>改编版本</h3><p>在改版中，<code>CSubmarine</code> 类增加了 <code>GetRect()</code> 方法，用于获取潜艇的碰撞箱。这是为了适应游戏中的新机制，如导弹与潜艇的碰撞检测。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CRect <span class="title">CSubmarine::GetRect</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...[定义矩形尺寸]...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CRect</span>(m_ptPos.x, m_ptPos.y, m_ptPos.x + SubmarineWidth, m_ptPos.y + SubmarineHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3-新增导弹类-CMissile"><a href="#3-新增导弹类-CMissile" class="headerlink" title="3. 新增导弹类 (CMissile)"></a>3. 新增导弹类 (<code>CMissile</code>)</h2><p>在改编版本中，新增了导弹类 <code>CMissile</code>。这一变化扩展了游戏的交互性和复杂度。</p>
<h3 id="原版-1"><a href="#原版-1" class="headerlink" title="原版"></a>原版</h3><p>原版游戏中没有导弹类的概念。</p>
<h3 id="改编版本-1"><a href="#改编版本-1" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本中添加了 <code>CMissile</code> 类，并在主游戏循环中处理导弹的移动和碰撞检测。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*pObj) == <span class="built_in">typeid</span>(CMissile))</span><br><span class="line">&#123;</span><br><span class="line">    CMissile* pMissile = (CMissile*)pObj;</span><br><span class="line">    pMissile-&gt;<span class="built_in">Move</span>(); <span class="comment">// 移动导弹</span></span><br><span class="line">    <span class="comment">// ... [碰撞检测和处理代码] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><strong>构造函数</strong>：初始化导弹的位置和生命周期。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CMissile::<span class="built_in">CMissile</span>(CPoint ptPos) : <span class="built_in">CMyObject</span>(ptPos)</span><br><span class="line">&#123;</span><br><span class="line">    m_nLifetime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...[初始化代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Move</code> 方法</strong>：控制导弹的移动。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMissile::Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ptPos.y += <span class="number">20</span>;  <span class="comment">// ...[移动逻辑]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>GetRect</code> 方法</strong>：为碰撞检测提供导弹的矩形区域。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CRect <span class="title">CMissile::GetRect</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...[定义矩形尺寸]...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CRect</span>(m_ptPos.x, m_ptPos.y, m_ptPos.x + MissileWidth, m_ptPos.y + MissileHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>导弹图像处理</strong>：使用 GDI+ 从资源加载 PNG 图片并创建图像列表。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMissile::LoadImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...[加载和处理 PNG 图片的代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="4-控制机制的改变"><a href="#4-控制机制的改变" class="headerlink" title="4. 控制机制的改变"></a>4. 控制机制的改变</h2><h3 id="原版-2"><a href="#原版-2" class="headerlink" title="原版"></a>原版</h3><p>原版游戏中，玩家通过鼠标点击潜艇位置来摧毁它们。这是通过 <code>OnLButtonDown</code> 函数实现的：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CChildView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">    <span class="keyword">if</span>(pSub-&gt;<span class="built_in">GetRect</span>().<span class="built_in">PtInRect</span>(point))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建爆炸和计分</span></span><br><span class="line">        <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">        <span class="keyword">delete</span> pSub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="改编版本-2"><a href="#改编版本-2" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本引入了键盘控制。通过 <code>OnKeyDown</code> 函数，玩家可以通过左右键移动船，并用空格键发射导弹。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CChildView::OnKeyDown</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nChar == VK_SPACE || nChar == VK_RETURN) <span class="comment">// 发射导弹</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">        <span class="keyword">if</span> (!missileExists)</span><br><span class="line">        &#123;</span><br><span class="line">            CMissile* pMissile = <span class="keyword">new</span> <span class="built_in">CMissile</span>(<span class="built_in">CPoint</span>(shipPos.x, SHIP_VERT_POS));</span><br><span class="line">            m_Objects.<span class="built_in">AddTail</span>(pMissile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="5-分数统计的变更"><a href="#5-分数统计的变更" class="headerlink" title="5. 分数统计的变更"></a>5. 分数统计的变更</h2><p>为了适应新的游戏玩法，分数统计方式也做了调整。</p>
<h3 id="原版-3"><a href="#原版-3" class="headerlink" title="原版"></a>原版</h3><p>原版游戏仅在鼠标点击潜艇时计分。</p>
<h3 id="改编版本-3"><a href="#改编版本-3" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本中，分数统计不仅包括击毁潜艇的分数，还统计了击毁的潜艇数量。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m_nTotalScore += pScore-&gt;<span class="built_in">GetScoreValue</span>(); <span class="comment">// 累加分数</span></span><br><span class="line">++m_nDestroyedSubmarines;  <span class="comment">// 增加被击毁的潜艇数量</span></span><br></pre></td></tr></table></figure></div>



<h2 id="6-界面信息显示的改进"><a href="#6-界面信息显示的改进" class="headerlink" title="6. 界面信息显示的改进"></a>6. 界面信息显示的改进</h2><p>改编版本在界面上添加了更多的信息显示，如总潜艇数、击毁潜艇数等，增强了游戏的可玩性和信息反馈。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CString destroyedString;</span><br><span class="line">destroyedString.<span class="built_in">Format</span>(<span class="string">&quot;击毁潜艇数: %d&quot;</span>, m_nDestroyedSubmarines);</span><br><span class="line">m_VirtualDC.<span class="built_in">TextOut</span>(<span class="number">130</span>, <span class="number">10</span>, destroyedString); <span class="comment">// 显示击毁潜艇数</span></span><br><span class="line"></span><br><span class="line">CString scoreString;</span><br><span class="line">scoreString.<span class="built_in">Format</span>(<span class="string">&quot;总分: %d&quot;</span>, m_nTotalScore);</span><br><span class="line">m_VirtualDC.<span class="built_in">TextOut</span>(GAME_WIDTH - <span class="number">100</span>, <span class="number">10</span>, scoreString); <span class="comment">// 显示总分</span></span><br></pre></td></tr></table></figure></div>



<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>参与《潜艇大战》游戏的改编过程，我在游戏开发方面获得了实质性的技能提升。通过这个项目，我学到了以下几个关键的技术点：</p>
<ol>
<li><strong>交互控制的实现</strong>：通过替换原有的鼠标点击控制为键盘控制，我学会了如何处理和响应键盘事件。这提高了我的能力，使我能够在未来的项目中灵活地设计和实现用户交互。</li>
<li><strong>游戏逻辑的编写</strong>：在实现导弹发射和移动的逻辑时，我加深了对游戏循环和对象状态管理的理解。这对于理解如何构建游戏的动态元素和保持其连贯性非常有帮助。</li>
<li><strong>碰撞检测的处理</strong>：实现导弹和潜艇之间的碰撞检测增强了我在游戏物理和交互方面的技术知识，这在很多游戏开发项目中都是一个核心技能。</li>
<li><strong>图形和用户界面的更新</strong>：改进游戏的界面显示，例如增加得分和击毁潜艇数的显示，让我更加熟悉了图形界面的编程和数据可视化。</li>
</ol>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作品集</tag>
        <tag>技术报告</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Unity——《Lost or Lose：双面迷途》项目报告</title>
    <url>/2024/05/15/%E3%80%8ALost-or-Lose%EF%BC%9A%E5%8F%8C%E9%9D%A2%E8%BF%B7%E9%80%94%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<a class="button center large" href='https://www.bilibili.com/video/BV1YT421D7Vc/?share_source=copy_web' title='【Lost or Lose Demo演示介绍视频】'><i class='fa-solid fa-play-circle'></i> 【Lost or Lose Demo演示介绍视频】</a>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/01.png"
                      alt="Lost or Lose展示PPT_01"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/02.png"
                      alt="Lost or Lose展示PPT_02"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/03.png"
                      alt="Lost or Lose展示PPT_03"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/04.png"
                      alt="Lost or Lose展示PPT_04"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/05.png"
                      alt="Lost or Lose展示PPT_05"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/06.png"
                      alt="Lost or Lose展示PPT_06"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/07.png"
                      alt="Lost or Lose展示PPT_07"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/08.png"
                      alt="Lost or Lose展示PPT_08"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/09.png"
                      alt="Lost or Lose展示PPT_09"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/10.png"
                      alt="Lost or Lose展示PPT_10"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/11.png"
                      alt="Lost or Lose展示PPT_11"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/12.png"
                      alt="Lost or Lose展示PPT_12"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/13.png"
                      alt="Lost or Lose展示PPT_13"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/14.png"
                      alt="Lost or Lose展示PPT_14"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/15.png"
                      alt="Lost or Lose展示PPT_15"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/16.png"
                      alt="Lost or Lose展示PPT_16"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/17.png"
                      alt="Lost or Lose展示PPT_17"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/18.png"
                      alt="Lost or Lose展示PPT_18"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/19.png"
                      alt="Lost or Lose展示PPT_19"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/20.png"
                      alt="Lost or Lose展示PPT_20"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/21.png"
                      alt="Lost or Lose展示PPT_21"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/22.png"
                      alt="Lost or Lose展示PPT_22"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/23.png"
                      alt="Lost or Lose展示PPT_23"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/24.png"
                      alt="Lost or Lose展示PPT_24"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/25.png"
                      alt="Lost or Lose展示PPT_25"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/26.png"
                      alt="Lost or Lose展示PPT_26"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/27.png"
                      alt="Lost or Lose展示PPT_27"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ALost-or-Lose%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/28.png"
                      alt="Lost or Lose展示PPT_28"
                ></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>项目报告</tag>
        <tag>作品集</tag>
        <tag>《Lost or Lose：双面迷途》</tag>
        <tag>Unity</tag>
        <tag>游戏开发比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity——《让蛋仔飞》技术报告</title>
    <url>/2024/01/08/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h2><ul>
<li><p>项目名称：《让蛋仔飞》</p>
</li>
<li><p>开发者：普典衡</p>
</li>
<li><p>分工：</p>
<p>普典衡：</p>
<p>策划-玩法，数值</p>
<p>程序-前端，后端</p>
<p>美术-UI，动画</p>
</li>
</ul>
<h2 id="2-游戏内容介绍"><a href="#2-游戏内容介绍" class="headerlink" title="2. 游戏内容介绍"></a>2. 游戏内容介绍</h2><ul>
<li>游戏背景：一个简单而有趣的游戏环境，主要集中于轻松、快节奏的体验。</li>
<li>角色道具：玩家扮演的是不同种类的卡通蛋角色，如荷包蛋、倒霉蛋等。卡通风格的刀和叉作为障碍物。</li>
<li>场景：使用明亮、鲜艳的色调和简单的卡通风格，界面清晰展示游戏选项。</li>
<li>主要情节：游戏集中于提供快节奏、直观易懂的体验，没有复杂的情节或故事线。</li>
<li>玩法：操作主角蛋躲避障碍物，通过点击或触摸屏幕控制跳跃。</li>
<li>功能（系统）：包括游戏控制系统、皮肤系统、排行榜系统等。</li>
</ul>
<h2 id="3-主要特点"><a href="#3-主要特点" class="headerlink" title="3. 主要特点"></a>3. 主要特点</h2><ul>
<li>整体风格：简洁而有趣，易于上手。</li>
<li>娱乐性与挑战性：结合逐渐增加的难度提供持续挑战。</li>
<li>社交性：通过排行榜系统增加游戏的社交动力。</li>
<li>个性化体验：通过皮肤系统允许玩家自定义角色外观。</li>
</ul>
<h2 id="4-算法说明"><a href="#4-算法说明" class="headerlink" title="4. 算法说明"></a>4. 算法说明</h2><p>   Unity（C#）代码部分：</p>
<h3 id="游戏控制和角色行为"><a href="#游戏控制和角色行为" class="headerlink" title="游戏控制和角色行为"></a>游戏控制和角色行为</h3><h4 id="EggyController-类："><a href="#EggyController-类：" class="headerlink" title="EggyController 类："></a><code>EggyController</code> 类：</h4><p>   负责处理蛋角色的基本行为，包括跳跃、得分、游戏开始&#x2F;结束逻辑、无敌状态、碰撞处理以及游戏速度的调整。</p>
<h5 id="游戏开始-结束逻辑"><a href="#游戏开始-结束逻辑" class="headerlink" title="游戏开始&#x2F;结束逻辑"></a>游戏开始&#x2F;结束逻辑</h5>   <div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isControl &amp;&amp; !IsPointerOverUIObject()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>) &amp;&amp; !gameStarted) &#123;</span><br><span class="line">            StartGame();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gameStarted) &#123;</span><br><span class="line">            Jump();</span><br><span class="line">        &#125;</span><br><span class="line">        CheckPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartGame</span>()</span> &#123;</span><br><span class="line">    gameStarted = <span class="literal">true</span>;</span><br><span class="line">    Time.timeScale = <span class="number">1</span>; <span class="comment">// 恢复时间流逝</span></span><br><span class="line">    <span class="comment">// 其他游戏开始逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckPosition</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查蛋的位置，确定游戏是否结束</span></span><br><span class="line">    <span class="comment">// 如果蛋落出屏幕，则结束游戏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   此部分代码控制游戏的开始和结束。当玩家点击屏幕时，游戏开始，而当游戏角色掉出屏幕时，游戏结束。</p>
<h5 id="跳跃逻辑"><a href="#跳跃逻辑" class="headerlink" title="跳跃逻辑"></a>跳跃逻辑</h5>   <div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>)) &#123;</span><br><span class="line">        rb.velocity = Vector2.up * jumpForce;</span><br><span class="line">        StartCoroutine(BounceEffect());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">BounceEffect</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 实现蛋的跳跃动画效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   这段代码负责处理玩家角色的跳跃动作。玩家点击屏幕时，角色会向上跳跃。</p>
<h5 id="得分逻辑"><a href="#得分逻辑" class="headerlink" title="得分逻辑"></a>得分逻辑</h5>   <div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGameOver &amp;&amp; other.gameObject.tag == <span class="string">&quot;ScoreZone&quot;</span>) &#123;</span><br><span class="line">        score++;</span><br><span class="line">        UpdateScoreText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateScoreText</span>()</span> &#123;</span><br><span class="line">    scoreText.text = score.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   当角色通过特定区域时，玩家得分。这通过检测角色是否触碰到标记为 “ScoreZone” 的触发器来实现。</p>
<h5 id="无敌状态"><a href="#无敌状态" class="headerlink" title="无敌状态"></a>无敌状态</h5>   <div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InvincibilityTime</span>()</span> &#123;</span><br><span class="line">    isInvincible = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 实现无敌状态效果，如闪烁等</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>; <span class="comment">// 无敌时间</span></span><br><span class="line">    isInvincible = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   在某些情况下，角色会进入无敌状态，这段时间内不会被障碍物伤害。</p>
<h5 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h5>   <div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (collision.gameObject.tag == <span class="string">&quot;KF&quot;</span> &amp;&amp; !isGameOver &amp;&amp; !isInvincible) &#123;</span><br><span class="line">        iscollide = <span class="literal">true</span>;</span><br><span class="line">        StartCoroutine(HandleGameOver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   当角色与标记为 “KF” 的障碍物发生碰撞时，游戏结束逻辑被触发。</p>
<h5 id="游戏速度调整"><a href="#游戏速度调整" class="headerlink" title="游戏速度调整"></a>游戏速度调整</h5>   <div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateGameSpeed</span>()</span> &#123;</span><br><span class="line">    Time.timeScale = Mathf.Min(<span class="number">1</span> + score * speedupspeed, maxTimeScale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   随着玩家得分的提高，游戏的时间流逝速度加快，从而增加游戏难度。</p>
<h4 id="Background-类："><a href="#Background-类：" class="headerlink" title="Background 类："></a><code>Background</code> 类：</h4><p>   管理游戏背景的移动，以创建滚动效果，增加游戏的动态感。</p>
<h5 id="初始化背景属性"><a href="#初始化背景属性" class="headerlink" title="初始化背景属性"></a>初始化背景属性</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    backgroundWidth = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在游戏开始时，计算背景图像的宽度，以便于后续确定何时克隆新的背景。</p>
<h5 id="背景移动逻辑"><a href="#背景移动逻辑" class="headerlink" title="背景移动逻辑"></a>背景移动逻辑</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EggyController.isGameOver) &#123;</span><br><span class="line">        transform.Translate(-speed * Time.deltaTime, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在每一帧中，如果游戏未结束，背景将以设定的速度向左移动，创建出持续滚动的效果。</p>
<h5 id="背景克隆和销毁"><a href="#背景克隆和销毁" class="headerlink" title="背景克隆和销毁"></a>背景克隆和销毁</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (transform.position.x &lt; <span class="number">0</span> &amp;&amp; !hasCloned) &#123;</span><br><span class="line">    CloneBackground();</span><br><span class="line">    hasCloned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (transform.position.x &lt; <span class="number">-18</span>) &#123;</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   当背景移动到屏幕中央时，克隆一个新的背景对象，以实现无缝连接的滚动效果。一旦背景移出屏幕一定范围，它将被销毁，以节省资源。</p>
<h5 id="克隆背景方法"><a href="#克隆背景方法" class="headerlink" title="克隆背景方法"></a>克隆背景方法</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloneBackground</span>()</span> &#123;</span><br><span class="line">    Instantiate(gameObject, <span class="keyword">new</span> Vector3(transform.position.x + backgroundWidth, transform.position.y, transform.position.z), Quaternion.identity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这个方法在原有背景的基础上创建一个新的背景实例，放置在当前背景的右侧，确保两个背景图像在水平方向上连续。</p>
<h3 id="游戏界面和用户交互"><a href="#游戏界面和用户交互" class="headerlink" title="游戏界面和用户交互"></a>游戏界面和用户交互</h3><h4 id="MenuManager-类："><a href="#MenuManager-类：" class="headerlink" title="MenuManager 类："></a><code>MenuManager</code> 类：</h4><p>   管理游戏菜单的显示和皮肤选择，提供玩家选择不同皮肤的功能。</p>
<h5 id="初始化和皮肤状态管理"><a href="#初始化和皮肤状态管理" class="headerlink" title="初始化和皮肤状态管理"></a>初始化和皮肤状态管理</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 确保主页UI初始时是显示的</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>);</span><br><span class="line">    homePageUI.SetActive(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取并显示累计总得分</span></span><br><span class="line">    <span class="built_in">int</span> totalScore = PlayerPrefs.GetInt(<span class="string">&quot;TotalScore&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取并显示死亡次数</span></span><br><span class="line">    <span class="built_in">int</span> deathCount = PlayerPrefs.GetInt(<span class="string">&quot;DeathCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取并显示复活总数</span></span><br><span class="line">    <span class="built_in">int</span> resurrectionCount = PlayerPrefs.GetInt(<span class="string">&quot;ResurrectionCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在对应的Text组件中显示这些值</span></span><br><span class="line">    <span class="comment">// 这里假设你有三个Text组件分别用于显示总得分、死亡次数和复活总数</span></span><br><span class="line">    <span class="comment">// 如果你的Text组件命名不同，需要根据实际情况修改下面的代码</span></span><br><span class="line">    totalScoreText.text = <span class="string">&quot;总得分: &quot;</span> + totalScore.ToString();</span><br><span class="line">    deathCountText.text = <span class="string">&quot;失败数: &quot;</span> + deathCount.ToString();</span><br><span class="line">    resurrectionCountText.text = <span class="string">&quot;复活数: &quot;</span> + resurrectionCount.ToString();</span><br><span class="line"></span><br><span class="line">    Time.timeScale = <span class="number">1</span>;</span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>); <span class="comment">// 先激活</span></span><br><span class="line">    ApplySkinToEggy(skinManager.skins[PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>)].name); <span class="comment">// 应用皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>); <span class="comment">// 再隐藏，如果需要的话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化皮肤列表</span></span><br><span class="line">    InitializeSkinsUnlockState();</span><br><span class="line">    LoadCurrentSkin();</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line"></span><br><span class="line">    unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitializeSkinsUnlockState</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认皮肤已解锁</span></span><br><span class="line">    PlayerPrefs.SetInt(<span class="string">&quot;eggy0&quot;</span>, <span class="number">1</span>); <span class="comment">// 1表示解锁，0表示未解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他皮肤的初始状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; skinManager.skins.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PlayerPrefs.HasKey(<span class="string">&quot;eggy&quot;</span> + i))</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span> + i, <span class="number">0</span>); <span class="comment">// 初始化为未解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!PlayerPrefs.HasKey(<span class="string">&quot;eggyUnlockable&quot;</span> + i))</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;eggyUnlockable&quot;</span> + i, <span class="number">0</span>); <span class="comment">// 初始化为不能解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadCurrentSkin</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 读取当前皮肤</span></span><br><span class="line">    currentSkinIndex = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            			           UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这部分代码在游戏开始时初始化UI元素和皮肤状态，包括设置默认皮肤和加载已解锁的皮肤。</p>
<h5 id="游戏开始和皮肤应用"><a href="#游戏开始和皮肤应用" class="headerlink" title="游戏开始和皮肤应用"></a>游戏开始和皮肤应用</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartGame</span>()</span> &#123;</span><br><span class="line">    Time.timeScale = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 激活游戏元素</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏主页UI</span></span><br><span class="line">    homePageUI.SetActive(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他开始游戏的设置...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ApplySkinToEggy</span>(<span class="params"><span class="built_in">string</span> skinName</span>)</span> &#123;</span><br><span class="line">    Skin skin = skinManager.GetSkin(skinName);</span><br><span class="line">    <span class="keyword">if</span> (skin != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EggyController eggyController = Object.FindObjectOfType&lt;EggyController&gt;();</span><br><span class="line">        <span class="keyword">if</span> (eggyController != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            eggyController.ChangeAppearance(skin.image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;EggyController instance not found in the scene.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   当玩家选择开始游戏时，这部分代码负责切换游戏的视图状态，并应用玩家选择的皮肤。</p>
<h5 id="皮肤选择和解锁"><a href="#皮肤选择和解锁" class="headerlink" title="皮肤选择和解锁"></a>皮肤选择和解锁</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NextSkin</span>()</span> &#123;</span><br><span class="line">    currentSkinIndex = (currentSkinIndex + <span class="number">1</span>) % skinManager.skins.Count;</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreviousSkin</span>()</span> &#123;</span><br><span class="line">    currentSkinIndex = (currentSkinIndex - <span class="number">1</span> + skinManager.skins.Count) % skinManager.skins.Count;</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectSkin</span>()</span> &#123;</span><br><span class="line">    PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span>, currentSkinIndex); <span class="comment">// 保存当前选择的皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>); <span class="comment">// 先激活</span></span><br><span class="line">    ApplySkinToEggy(skinManager.skins[currentSkinIndex].name);<span class="comment">//应用皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>); <span class="comment">// 再隐藏，如果需要的话</span></span><br><span class="line">    selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnlockSkin</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> canUnlock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (currentSkinIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// eggy1解锁条件 - 累计失败500次</span></span><br><span class="line">            <span class="built_in">int</span> deathCount = PlayerPrefs.GetInt(<span class="string">&quot;DeathCount&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            canUnlock = deathCount &gt;= <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// eggy2解锁条件 - 累计达到10000分</span></span><br><span class="line">            <span class="built_in">int</span> totalScore = PlayerPrefs.GetInt(<span class="string">&quot;TotalScore&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            canUnlock = totalScore &gt;= <span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// eggy3解锁条件 - 累计复活50次</span></span><br><span class="line">            <span class="built_in">int</span> resurrectionCount = PlayerPrefs.GetInt(<span class="string">&quot;ResurrectionCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            canUnlock = resurrectionCount &gt;= <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">if</span> (PlayerPrefs.GetInt(<span class="string">&quot;eggyUnlockable&quot;</span> + currentSkinIndex, <span class="number">0</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                canUnlock = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canUnlock)</span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span> + currentSkinIndex, <span class="number">1</span>); <span class="comment">// 解锁当前皮肤</span></span><br><span class="line">        skinManager.skins[currentSkinIndex].isUnlocked = <span class="literal">true</span>; <span class="comment">// 更新皮肤管理器中的状态</span></span><br><span class="line">        UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ShowUnlockConditionFailed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateEggyDisplay</span>(<span class="params">Skin skin</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新皮肤信息</span></span><br><span class="line">    NameText.text = skin.name;</span><br><span class="line">    IntroductionText.text = skin.description;</span><br><span class="line">    unlockConditionText.text = skin.unlockCondition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始皮肤图像并重置Eggy</span></span><br><span class="line">    eggyDisplay.SetSkinImage(skin.image);</span><br><span class="line">    eggyDisplay.ResetEggy(); <span class="comment">// 重置Eggy的位置和状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取解锁和选中状态</span></span><br><span class="line">    <span class="built_in">bool</span> isUnlocked = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span> + currentSkinIndex, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bool</span> isSelected = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>) == currentSkinIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据解锁状态和选中状态控制按钮显示</span></span><br><span class="line">    <span class="keyword">if</span> (isUnlocked &amp;&amp; isSelected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤已解锁且为当前选中皮肤</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isUnlocked)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤已解锁但不是当前选中皮肤</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤未解锁</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eggyDisplay.SetUnlocked(isUnlocked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这些方法允许玩家在不同皮肤之间选择和切换，并根据游戏进度解锁新的皮肤。</p>
<h4 id="EggyDisplay-类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。"><a href="#EggyDisplay-类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。" class="headerlink" title="EggyDisplay 类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。"></a><code>EggyDisplay</code> 类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。</h4><h5 id="初始化和设置皮肤"><a href="#初始化和设置皮肤" class="headerlink" title="初始化和设置皮肤"></a>初始化和设置皮肤</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    eggyRenderer = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    originalSprite = eggyRenderer.sprite;</span><br><span class="line">    originalPosition = transform.position;</span><br><span class="line">    originalScale = transform.localScale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSkinImage</span>(<span class="params">Sprite skinImage</span>)</span> &#123;</span><br><span class="line">    originalSprite = skinImage;</span><br><span class="line">    eggyRenderer.sprite = skinImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在游戏开始时，该类初始化蛋角色的渲染器，并保存其原始状态。<code>SetSkinImage</code> 方法用于更换角色的皮肤。</p>
<h5 id="皮肤解锁动画"><a href="#皮肤解锁动画" class="headerlink" title="皮肤解锁动画"></a>皮肤解锁动画</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetUnlocked</span>(<span class="params"><span class="built_in">bool</span> unlocked</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlocked) &#123;</span><br><span class="line">        StartCoroutine(UnlockedAnimation());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eggyRenderer.sprite = ApplyBlackMask(eggyRenderer.sprite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">UnlockedAnimation</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 动画效果，如呼吸效果和跳跃动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   通过 <code>SetUnlocked</code> 方法，可以控制是否展示皮肤解锁动画。如果皮肤已解锁，会播放一个特殊的动画效果，如呼吸和跳跃动作。</p>
<h5 id="辅助方法：黑色遮罩和重置状态"><a href="#辅助方法：黑色遮罩和重置状态" class="headerlink" title="辅助方法：黑色遮罩和重置状态"></a>辅助方法：黑色遮罩和重置状态</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Sprite <span class="title">ApplyBlackMask</span>(<span class="params">Sprite originalSprite</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将黑色遮罩应用于未解锁的皮肤图像</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetEggy</span>()</span> &#123;</span><br><span class="line">    StopAllCoroutines();</span><br><span class="line">    transform.localScale = originalScale;</span><br><span class="line">    transform.position = originalPosition;</span><br><span class="line">    <span class="comment">// 重置其他状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   <code>ApplyBlackMask</code> 方法用于给未解锁的皮肤添加一个黑色遮罩，而 <code>ResetEggy</code> 方法则用于重置蛋角色的状态，包括位置和缩放。</p>
<h3 id="游戏障碍物和挑战"><a href="#游戏障碍物和挑战" class="headerlink" title="游戏障碍物和挑战"></a>游戏障碍物和挑战</h3><h4 id="KnifeForkController-和-KFController-类："><a href="#KnifeForkController-和-KFController-类：" class="headerlink" title="KnifeForkController 和 KFController 类："></a><code>KnifeForkController</code> 和 <code>KFController</code> 类：</h4><p>   负责生成和管理刀叉障碍物，控制它们的出现频率、速度和运动。</p>
<h4 id="KnifeForkController-类："><a href="#KnifeForkController-类：" class="headerlink" title="KnifeForkController 类："></a><code>KnifeForkController</code> 类：</h4><p>   负责刀叉障碍物的生成和管理</p>
<h5 id="初始化和生成刀叉"><a href="#初始化和生成刀叉" class="headerlink" title="初始化和生成刀叉"></a>初始化和生成刀叉</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject knifeForkPrefab; <span class="comment">// 刀叉预制体</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> spawnRate = <span class="number">2f</span>; <span class="comment">// 生成间隔（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    nextSpawnTime = Time.time + spawnRate; <span class="comment">// 设置下一次生成时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGameOver &amp;&amp; Time.time &gt;= nextSpawnTime)</span><br><span class="line">    &#123;</span><br><span class="line">        SpawnKnifeFork();</span><br><span class="line">        nextSpawnTime = Time.time + spawnRate;</span><br><span class="line">        forksCount++; <span class="comment">// 增加已生成的刀叉数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查EggyController的游戏结束状态</span></span><br><span class="line">    <span class="keyword">if</span> (EggyController.isGameOver)</span><br><span class="line">    &#123;</span><br><span class="line">        isGameOver = <span class="literal">true</span>;</span><br><span class="line">        GameOver();</span><br><span class="line">    &#125;<span class="keyword">else</span> isGameOver = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpawnKnifeFork</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> gapY = Random.Range(-gapSize, gapSize); <span class="comment">// 随机间隔</span></span><br><span class="line">    Quaternion rotation = Random.Range(<span class="number">0</span>, <span class="number">2</span>) == <span class="number">0</span> ? Quaternion.identity : Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span>); <span class="comment">// 随机旋转180度</span></span><br><span class="line">    Vector3 spawnPosition = <span class="keyword">new</span> Vector3(transform.position.x, gapY, transform.position.z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据旋转来设置初始速度方向</span></span><br><span class="line">    <span class="built_in">float</span> initialMoveDirection = (rotation == Quaternion.identity) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    GameObject newKnifeFork = Instantiate(knifeForkPrefab, spawnPosition, rotation);</span><br><span class="line">    spawnedForks.Add(newKnifeFork); <span class="comment">// 将已生成的刀叉添加到列表</span></span><br><span class="line">    StartCoroutine(MoveAndDestroyKnifeFork(newKnifeFork, initialMoveDirection)); <span class="comment">// 设置移动速度并在移出屏幕后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="刀叉运动和销毁"><a href="#刀叉运动和销毁" class="headerlink" title="刀叉运动和销毁"></a>刀叉运动和销毁</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MoveAndDestroyKnifeFork</span>(<span class="params">GameObject knifeFork, <span class="built_in">float</span> initialMoveDirection</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 控制刀叉的移动和销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopKnifeFork</span>(<span class="params">GameObject knifeFork</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (knifeFork != <span class="literal">null</span>) <span class="comment">// 检查刀叉是否为null</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rigidbody2D kfRigidbody = knifeFork.GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        kfRigidbody.velocity = Vector2.zero; <span class="comment">// 停止刀叉的速度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="游戏结束和重置"><a href="#游戏结束和重置" class="headerlink" title="游戏结束和重置"></a>游戏结束和重置</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GameOver</span>()</span> &#123;</span><br><span class="line">    isGameOver = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 停止所有已生成的刀叉的移动</span></span><br><span class="line">    <span class="keyword">foreach</span> (GameObject fork <span class="keyword">in</span> spawnedForks)</span><br><span class="line">    &#123;</span><br><span class="line">        StopKnifeFork(fork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetGame</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 重置刀叉控制器的状态</span></span><br><span class="line">    isGameOver = <span class="literal">false</span>;</span><br><span class="line">    forksCount = <span class="number">0</span>;</span><br><span class="line">    nextSpawnTime = Time.time + spawnRate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁所有已生成的刀叉</span></span><br><span class="line">    <span class="keyword">foreach</span> (GameObject fork <span class="keyword">in</span> spawnedForks)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(fork);</span><br><span class="line">    &#125;</span><br><span class="line">    spawnedForks.Clear(); <span class="comment">// 清空列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="KFController-类："><a href="#KFController-类：" class="headerlink" title="KFController 类："></a><code>KFController</code> 类：</h4><p>   负责单个刀叉障碍物的行为</p>
<h5 id="刀叉障碍物的物理行为"><a href="#刀叉障碍物的物理行为" class="headerlink" title="刀叉障碍物的物理行为"></a>刀叉障碍物的物理行为</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> kfFallSpeed = <span class="number">20f</span>; <span class="comment">// KF的下降速度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (collision.gameObject.CompareTag(<span class="string">&quot;eggy&quot;</span>)) &#123;</span><br><span class="line">        Rigidbody2D kfRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        kfRigidbody.velocity = Vector2.down * kfFallSpeed; <span class="comment">// 设置下降速度</span></span><br><span class="line">        kfRigidbody.gravityScale = <span class="number">3</span>; <span class="comment">// 调整重力影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   <code>KnifeForkController</code> 类负责控制整体刀叉障碍物的生成频率和运动模式，而 <code>KFController</code> 类则专注于单个刀叉障碍物的具体行为，如碰撞时的下降速度和重力设置。这两个类通过协同工作，为游戏增添挑战性和动态性。</p>
<h3 id="排行榜和社交功能"><a href="#排行榜和社交功能" class="headerlink" title="排行榜和社交功能"></a>排行榜和社交功能</h3><h4 id="Ranking-类："><a href="#Ranking-类：" class="headerlink" title="Ranking 类："></a><code>Ranking</code> 类：</h4><p>   整合微信小程序的排行榜功能，允许玩家查看和分享他们的得分。</p>
<h5 id="初始化和设置"><a href="#初始化和设置" class="headerlink" title="初始化和设置"></a>初始化和设置</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    WX.InitSDK((code) =&gt; &#123; Init(); &#125;);</span><br><span class="line">    WX.UpdateShareMenu(<span class="keyword">new</span> UpdateShareMenuOption() &#123;</span><br><span class="line">        withShareTicket = <span class="literal">true</span>,</span><br><span class="line">        isPrivateMessage = <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   游戏启动时初始化微信SDK，并设置分享菜单选项，允许通过群分享获取排行榜数据。</p>
<h5 id="展示排行榜"><a href="#展示排行榜" class="headerlink" title="展示排行榜"></a>展示排行榜</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowOpenData</span>()</span> &#123;</span><br><span class="line">    RankMask.SetActive(<span class="literal">true</span>);</span><br><span class="line">    RankingBox.SetActive(<span class="literal">true</span>);</span><br><span class="line">    WX.ShowOpenData(RankBody.texture, <span class="comment">/* 确定排行榜的位置和尺寸 */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;</span><br><span class="line">    ShowButton1.onClick.AddListener(ShowRanking);</span><br><span class="line">    ShowButton2.onClick.AddListener(ShowRanking);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowRanking</span>()</span> &#123;</span><br><span class="line">    ShowOpenData();</span><br><span class="line">    OpenDataMessage msgData = <span class="keyword">new</span> OpenDataMessage &#123; type = <span class="string">&quot;showFriendsRank&quot;</span> &#125;;</span><br><span class="line">    WX.GetOpenDataContext().PostMessage(JsonUtility.ToJson(msgData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   提供了按钮监听器来展示排行榜，通过调用<code>WX.ShowOpenData</code>方法将排行榜数据渲染到指定的UI元素上。</p>
<h5 id="排行榜的隐藏与分享"><a href="#排行榜的隐藏与分享" class="headerlink" title="排行榜的隐藏与分享"></a>排行榜的隐藏与分享</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">RankMask.GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123;</span><br><span class="line">    RankMask.SetActive(<span class="literal">false</span>);</span><br><span class="line">    RankingBox.SetActive(<span class="literal">false</span>);</span><br><span class="line">    WX.HideOpenData();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ShareButton.onClick.AddListener(() =&gt; &#123;</span><br><span class="line">    <span class="comment">// 分享最高分数</span></span><br><span class="line">    WX.ShareAppMessage(<span class="comment">/* 分享配置 */</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>   包含隐藏排行榜和分享玩家成绩的逻辑。玩家可以通过点击按钮来关闭排行榜视图，或者通过另一个按钮分享自己的最高得分。</p>
<ul>
<li>使用微信SDK进行社交互动和数据共享。</li>
</ul>
<h5 id="玩家数据和成就"><a href="#玩家数据和成就" class="headerlink" title="玩家数据和成就"></a>玩家数据和成就</h5><ul>
<li>使用 <code>PlayerPrefs</code> 来保存和加载玩家的分数、皮肤状态、死亡次数等信息。</li>
<li>提供复活机制，增加游戏的挑战性和可玩性。</li>
</ul>
<h5 id="皮肤系统和个性化"><a href="#皮肤系统和个性化" class="headerlink" title="皮肤系统和个性化"></a>皮肤系统和个性化</h5><h4 id="SkinManager-类："><a href="#SkinManager-类：" class="headerlink" title="SkinManager 类："></a><code>SkinManager</code> 类：</h4><p>   管理游戏中的皮肤系统，包括皮肤的解锁条件和状态。</p>
<h5 id="皮肤定义"><a href="#皮肤定义" class="headerlink" title="皮肤定义"></a>皮肤定义</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name; <span class="comment">// 皮肤名称</span></span><br><span class="line">    <span class="keyword">public</span> Sprite image; <span class="comment">// 皮肤图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> description; <span class="comment">// 皮肤简介</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> unlockCondition; <span class="comment">// 解锁条件描述</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isUnlocked; <span class="comment">// 是否已解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   定义了一个<code>Skin</code>类，包含皮肤的名称、图片、描述和解锁条件。<code>isUnlocked</code>字段用于追踪皮肤的解锁状态。</p>
<h5 id="皮肤管理"><a href="#皮肤管理" class="headerlink" title="皮肤管理"></a>皮肤管理</h5>   <div class="code-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkinManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Skin&gt; skins; <span class="comment">// 皮肤集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定名称的皮肤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Skin <span class="title">GetSkin</span>(<span class="params"><span class="built_in">string</span> skinName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> skins.Find(skin =&gt; skin.name == skinName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   <code>SkinManager</code>类包含一个皮肤集合，提供<code>GetSkin</code>方法以根据名称获取特定皮肤的详细信息。这使得游戏能够根据玩家的选择或游戏进度，显示或更换皮肤。</p>
<ul>
<li>提供多种皮肤供玩家解锁和选择，增加游戏的个性化和吸引力。</li>
</ul>
<h2 id="5-API的使用"><a href="#5-API的使用" class="headerlink" title="5. API的使用"></a>5. API的使用</h2><h3 id="系统信息和日志管理"><a href="#系统信息和日志管理" class="headerlink" title="系统信息和日志管理"></a>系统信息和日志管理</h3><ul>
<li><code>wx.getUpdateManager()</code>：获取全局唯一的版本更新管理器，用于管理小程序的更新。</li>
<li><code>wx.getSystemInfoSync()</code>：同步获取系统信息，如屏幕大小、设备型号等。</li>
<li><code>wx.getRealtimeLogManager()</code>：获取实时日志管理器，用于记录和上报实时日志。</li>
<li><code>wx.getLogManager()</code>：获取日志管理器，用于记录和上报日志。</li>
</ul>
<h3 id="错误处理和内存管理"><a href="#错误处理和内存管理" class="headerlink" title="错误处理和内存管理"></a>错误处理和内存管理</h3><ul>
<li><code>wx.onError()</code>：监听小程序错误事件，用于错误处理。</li>
<li><code>wx.triggerGC()</code>：触发JavaScript垃圾回收机制，可以帮助小程序管理内存使用。</li>
</ul>
<h3 id="用户界面和反馈"><a href="#用户界面和反馈" class="headerlink" title="用户界面和反馈"></a>用户界面和反馈</h3><ul>
<li><code>wx.showModal()</code>：显示模态对话框，用于向用户显示信息或询问用户决策。</li>
<li><code>wx.createFeedbackButton()</code>：创建一个游戏内的用户反馈按钮。</li>
</ul>
<h3 id="社交功能和消息传递"><a href="#社交功能和消息传递" class="headerlink" title="社交功能和消息传递"></a>社交功能和消息传递</h3><ul>
<li><code>wx.shareMessageToFriend()</code>：分享消息给微信好友，增强游戏的社交互动性。</li>
<li><code>wx.onMessage()</code>：监听主域向开放数据域发送的消息，常用于排行榜的实现。</li>
</ul>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul>
<li><code>wx.getStorageSync()</code>、<code>wx.setStorage()</code>、<code>wx.removeStorage()</code>、<code>wx.clearStorage()</code>、<code>wx.getStorage()</code>：这些API用于本地数据的存取、删除和清除，方便游戏保存玩家的游戏进度、设置或成就。</li>
</ul>
<h2 id="6-UI和截图"><a href="#6-UI和截图" class="headerlink" title="6. UI和截图"></a>6. UI和截图</h2><p>   所有素材均为ChatGPT绘制+本人Photoshop制作，无商用素材盗用</p>
<h3 id="游戏界面截图"><a href="#游戏界面截图" class="headerlink" title="游戏界面截图"></a>游戏界面截图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/0.png"
                      alt="0"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/1.png"
                      alt="1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/2.png"
                      alt="2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/5.png"
                      alt="5"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/6.png"
                      alt="6"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/10.png"
                      alt="10"
                ></p>
<h3 id="角色和UI设计图（部分）"><a href="#角色和UI设计图（部分）" class="headerlink" title="角色和UI设计图（部分）"></a>角色和UI设计图（部分）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/eggy.png"
                      alt="eggy"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg4.png"
                      alt="egg4"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg6.png"
                      alt="egg6"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg1.png"
                      alt="egg1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg2.png"
                      alt="egg2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg3.png"
                      alt="egg3"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/bg.png"
                      alt="bg"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/Button_UI.png"
                      alt="Button_UI"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/fork.png"
                      alt="fork"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/knife.png"
                      alt="knife"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/pan.png"
                      alt="pan"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/share.png"
                      alt="share"
                ></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>微信小游戏</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>技术报告</tag>
        <tag>Unity</tag>
        <tag>《让蛋仔飞》</tag>
        <tag>微信小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL——《游戏设计与开发》课程项目报告</title>
    <url>/2024/06/23/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_01.png"
                      alt="游戏设计与开发课程项目报告_01"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_02.png"
                      alt="游戏设计与开发课程项目报告_02"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_03.png"
                      alt="游戏设计与开发课程项目报告_03"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_04.png"
                      alt="游戏设计与开发课程项目报告_04"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_05.png"
                      alt="游戏设计与开发课程项目报告_05"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_06.png"
                      alt="游戏设计与开发课程项目报告_06"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_07.png"
                      alt="游戏设计与开发课程项目报告_07"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_08.png"
                      alt="游戏设计与开发课程项目报告_08"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_09.png"
                      alt="游戏设计与开发课程项目报告_09"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_10.png"
                      alt="游戏设计与开发课程项目报告_10"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_11.png"
                      alt="游戏设计与开发课程项目报告_11"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_12.png"
                      alt="游戏设计与开发课程项目报告_12"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_13.png"
                      alt="游戏设计与开发课程项目报告_13"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_14.png"
                      alt="游戏设计与开发课程项目报告_14"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_15.png"
                      alt="游戏设计与开发课程项目报告_15"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_16.png"
                      alt="游戏设计与开发课程项目报告_16"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_17.png"
                      alt="游戏设计与开发课程项目报告_17"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_18.png"
                      alt="游戏设计与开发课程项目报告_18"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_19.png"
                      alt="游戏设计与开发课程项目报告_19"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_20.png"
                      alt="游戏设计与开发课程项目报告_20"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_21.png"
                      alt="游戏设计与开发课程项目报告_21"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_22.png"
                      alt="游戏设计与开发课程项目报告_22"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_23.png"
                      alt="游戏设计与开发课程项目报告_23"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_24.png"
                      alt="游戏设计与开发课程项目报告_24"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_25.png"
                      alt="游戏设计与开发课程项目报告_25"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_26.png"
                      alt="游戏设计与开发课程项目报告_26"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_27.png"
                      alt="游戏设计与开发课程项目报告_27"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_28.png"
                      alt="游戏设计与开发课程项目报告_28"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_29.png"
                      alt="游戏设计与开发课程项目报告_29"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_30.png"
                      alt="游戏设计与开发课程项目报告_30"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_31.png"
                      alt="游戏设计与开发课程项目报告_31"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_32.png"
                      alt="游戏设计与开发课程项目报告_32"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_33.png"
                      alt="游戏设计与开发课程项目报告_33"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_34.png"
                      alt="游戏设计与开发课程项目报告_34"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_35.png"
                      alt="游戏设计与开发课程项目报告_35"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_36.png"
                      alt="游戏设计与开发课程项目报告_36"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_37.png"
                      alt="游戏设计与开发课程项目报告_37"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_38.png"
                      alt="游戏设计与开发课程项目报告_38"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_39.png"
                      alt="游戏设计与开发课程项目报告_39"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_40.png"
                      alt="游戏设计与开发课程项目报告_40"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_41.png"
                      alt="游戏设计与开发课程项目报告_41"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_42.png"
                      alt="游戏设计与开发课程项目报告_42"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_43.png"
                      alt="游戏设计与开发课程项目报告_43"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_44.png"
                      alt="游戏设计与开发课程项目报告_44"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_45.png"
                      alt="游戏设计与开发课程项目报告_45"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_46.png"
                      alt="游戏设计与开发课程项目报告_46"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_47.png"
                      alt="游戏设计与开发课程项目报告_47"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_48.png"
                      alt="游戏设计与开发课程项目报告_48"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_49.png"
                      alt="游戏设计与开发课程项目报告_49"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_50.png"
                      alt="游戏设计与开发课程项目报告_50"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_51.png"
                      alt="游戏设计与开发课程项目报告_51"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_52.png"
                      alt="游戏设计与开发课程项目报告_52"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_53.png"
                      alt="游戏设计与开发课程项目报告_53"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_54.png"
                      alt="游戏设计与开发课程项目报告_54"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_55.png"
                      alt="游戏设计与开发课程项目报告_55"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_56.png"
                      alt="游戏设计与开发课程项目报告_56"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A_57.png"
                      alt="游戏设计与开发课程项目报告_57"
                ></p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>游戏设计与开发</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作品集</tag>
        <tag>OpenGL</tag>
        <tag>技术报告</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity——《让蛋仔飞》项目报告</title>
    <url>/2024/01/09/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_01.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_01"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_02.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_02"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_03.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_03"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_04.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_04"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_05.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_05"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_06.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_06"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_07.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_07"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_08.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_08"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_09.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_09"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_10.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_10"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_11.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_11"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_12.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_12"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_13.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_13"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_14.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_14"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_15.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_15"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_16.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_16"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_17.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_17"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_18.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_18"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_19.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_19"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_20.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_20"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_21.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_21"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_22.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_22"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_23.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_23"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_24.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_24"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_25.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_25"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_26.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_26"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_27.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_27"
                ></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>微信小游戏</category>
      </categories>
      <tags>
        <tag>项目报告</tag>
        <tag>作品集</tag>
        <tag>Unity</tag>
        <tag>《让蛋仔飞》</tag>
        <tag>微信小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——大实验-扑克牌分割</title>
    <url>/2024/06/08/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C-%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><p>本实验旨在设计一个算法，自动识别图像中的扑克牌区域，并生成mask将扑克牌抠取出来。通过实验，可以深入理解图像处理的基本原理和技术，掌握分割和形态处理的方法。</p>
<h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li>利用所学知识，分析扑克牌内容及其边界的特性。</li>
<li>基于分割和形态处理等知识，设计算法自动分割或识别图像中的扑克牌区域，生成mask后将扑克牌抠取出来。</li>
<li>阐述原理，分析得到的结果与真实值之间的差异原因，总结整理报告。</li>
</ol>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li><p><strong>图像读取与预处理</strong>：</p>
<ul>
<li><strong>图像读取</strong>：首先，使用 <code>cv2.imread</code> 函数从指定路径读取图像文件，并将图像数据存储在变量 <code>image</code> 中。这一步骤将图像加载到内存中以便后续处理。</li>
<li><strong>颜色空间转换</strong>：将读取的图像从BGR颜色空间转换为HSV颜色空间，使用 <code>cv2.cvtColor</code> 函数实现。HSV颜色空间将颜色信息和亮度信息分开，有利于后续的颜色分割。</li>
<li><strong>阈值设置</strong>：根据HSV颜色空间的特点，设置白色的HSV阈值范围。白色的HSV范围设定为 <code>lower_white = np.array([0, 0, 180])</code> 和 <code>upper_white = np.array([180, 200, 255])</code>，用于识别图像中的白色区域。</li>
<li><strong>掩膜生成</strong>：利用 <code>cv2.inRange</code> 函数生成二值掩膜。掩膜中的白色部分对应图像中的白色区域，黑色部分对应其他颜色区域。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">image = cv2.imread(image_path)</span><br><span class="line">original_image = image.copy()</span><br><span class="line">hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)</span><br><span class="line">lower_white = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span>])</span><br><span class="line">upper_white = np.array([<span class="number">180</span>, <span class="number">200</span>, <span class="number">255</span>])</span><br><span class="line">mask = cv2.inRange(hsv, lower_white, upper_white)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>形态学操作</strong>：</p>
<ul>
<li><strong>形态学闭操作</strong>：为了消除小的黑色区域和填补白色区域的孔洞，使用形态学闭操作。通过 <code>cv2.morphologyEx</code> 函数和 <code>cv2.MORPH_CLOSE</code> 操作实现，卷积核大小设定为 <code>kernel = np.ones((3, 3), np.uint8)</code>。闭操作可以连接分离的白色区域，增强目标区域的连贯性。</li>
<li><strong>形态学开操作</strong>：在闭操作之后，为了去除噪声并平滑边缘，使用形态学开操作。通过 <code>cv2.morphologyEx</code> 函数和 <code>cv2.MORPH_OPEN</code> 操作实现。开操作可以去除图像中的小噪声点，使掩膜更加干净。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)</span><br><span class="line">mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>轮廓检测与筛选</strong>：</p>
<ul>
<li><strong>轮廓检测</strong>：使用 <code>cv2.findContours</code> 函数在掩膜中查找轮廓。轮廓检测方法设定为 <code>cv2.RETR_EXTERNAL</code>，仅检测外部轮廓；轮廓逼近方法设定为 <code>cv2.CHAIN_APPROX_SIMPLE</code>，将轮廓点压缩到最少。</li>
<li><strong>轮廓筛选</strong>：遍历所有检测到的轮廓，筛选出符合条件的轮廓。筛选条件为轮廓的多边形逼近结果为四边形，且面积大于1000。通过 <code>cv2.approxPolyDP</code> 函数进行多边形逼近，并使用面积条件筛选轮廓。</li>
<li><strong>轮廓绘制</strong>：对符合条件的轮廓进行绘制，使用 <code>cv2.drawContours</code> 函数将轮廓绘制在原图上，并生成相应的掩膜以便抠取扑克牌图像。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">output_image = original_image.copy()</span><br><span class="line">card_images = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    epsilon = <span class="number">0.1</span> * cv2.arcLength(contour, <span class="literal">True</span>)</span><br><span class="line">    approx = cv2.approxPolyDP(contour, epsilon, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(approx) == <span class="number">4</span> <span class="keyword">and</span> cv2.contourArea(approx) &gt; <span class="number">1000</span>:</span><br><span class="line">        cv2.drawContours(output_image, [approx], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        mask = np.zeros_like(image)</span><br><span class="line">        cv2.drawContours(mask, [approx], -<span class="number">1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">        card_image = cv2.bitwise_and(original_image, mask)</span><br><span class="line">        card_images.append(card_image)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>结果保存与显示</strong>：</p>
<ul>
<li><strong>结果保存</strong>：使用 <code>cv2.imwrite</code> 函数将标注了轮廓的图像保存到指定路径。这样可以将处理后的结果保存下来，以便后续查看和分析。</li>
<li><strong>扑克牌图像保存</strong>：将抠取的扑克牌图像保存为单独的文件。文件名格式为 <code>result_path.replace(&#39;.jpg&#39;, f&#39;_card_&#123;idx+1&#125;.jpg&#39;)</code>，以确保每张扑克牌图像都被单独保存。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(result_path, output_image)</span><br><span class="line"><span class="keyword">for</span> idx, card_image <span class="keyword">in</span> <span class="built_in">enumerate</span>(card_images):</span><br><span class="line">    card_path = result_path.replace(<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">f&#x27;_card_<span class="subst">&#123;idx+<span class="number">1</span>&#125;</span>.jpg&#x27;</span>)</span><br><span class="line">    cv2.imwrite(card_path, card_image)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p>结果图像展示了处理前后的效果。处理后的图像中，扑克牌区域被成功识别并标注，生成的掩膜准确地抠取了扑克牌。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_1.jpg"
                      alt="result_1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_1_card_1.jpg"
                      alt="result_1_card_1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_2.jpg"
                      alt="result_2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_2_card_1.jpg"
                      alt="result_2_card_1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_3.jpg"
                      alt="result_3"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_3_card_1.jpg"
                      alt="result_3_card_1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_4.jpg"
                      alt="result_4"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_4_card_1.jpg"
                      alt="result_4_card_1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_5.jpg"
                      alt="result_5"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_5_card_1.jpg"
                      alt="result_5_card_1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_5_card_2.jpg"
                      alt="result_5_card_2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_5_card_3.jpg"
                      alt="result_5_card_3"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E5%88%86%E5%89%B2/result_5_card_4.jpg"
                      alt="result_5_card_4"
                ></p>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>本实验通过图像处理和形态学操作，实现了自动识别和分割图像中的扑克牌区域。实验中，我使用了颜色空间转换、阈值分割、形态学操作、轮廓检测和多边形逼近等多种图像处理技术，取得了良好的分割效果。以下是对实验结果和方法的详细总结：</p>
<ol>
<li><p><strong>实验结果分析</strong>：</p>
<ul>
<li><strong>识别准确性</strong>：实验中，扑克牌区域在大多数图像中都被准确识别并标注。尤其是在光照均匀和背景简单的情况下，算法表现出色，生成的掩膜能够准确地抠取扑克牌。</li>
<li><strong>处理后的图像</strong>：处理后的图像显示了识别的扑克牌区域，这些区域被绿色轮廓标注，并生成了相应的掩膜。通过掩膜，成功地抠取了扑克牌图像，验证了算法的有效性。</li>
</ul>
</li>
<li><p><strong>形态学操作的效果</strong>：</p>
<ul>
<li><strong>闭操作</strong>：闭操作通过先膨胀后腐蚀，消除了图像中的小孔洞，连接了相邻的白色区域，增强了目标区域的连贯性。这在处理具有细小孔洞或断裂的扑克牌边缘时尤为有效。</li>
<li><strong>开操作</strong>：开操作通过先腐蚀后膨胀，去除了图像中的小噪声点，平滑了目标区域的边缘。这样可以有效地去除图像中的孤立噪声点，使识别更加准确。</li>
</ul>
</li>
<li><p><strong>算法优势与局限性</strong>：</p>
<ul>
<li><p><strong>优势</strong>：</p>
<ul>
<li><strong>高效性</strong>：算法能够快速处理多张图像，识别扑克牌区域并生成相应的掩膜，适用于批量图像处理。</li>
<li><strong>鲁棒性</strong>：在光照条件较好、背景简单的情况下，算法表现稳定，识别准确。</li>
<li><strong>简洁性</strong>：算法步骤清晰明确，易于实现和理解，便于在实际应用中推广。</li>
</ul>
</li>
<li><p><strong>局限性</strong>：</p>
<ul>
<li><strong>光照变化</strong>：在光照不均匀或光照条件变化较大的情况下，HSV阈值分割可能不够稳定，影响识别效果。需要结合自适应阈值分割或其他颜色空间转换方法进行改进。</li>
<li><strong>背景干扰</strong>：在复杂背景下，可能会引入干扰，导致误识别或漏识别。可以考虑引入背景建模或背景抑制技术来提高识别准确性。</li>
<li><strong>扑克牌的旋转与变形</strong>：对于旋转或变形较大的扑克牌，轮廓逼近和多边形筛选可能无法准确识别，需要结合形状匹配或模板匹配等方法进行优化。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>改进与优化方向</strong>：</p>
<ul>
<li><strong>自适应阈值分割</strong>：结合自适应阈值分割方法，提高在光照变化下的鲁棒性。</li>
<li><strong>多尺度形态学操作</strong>：引入多尺度形态学操作，提高对不同大小噪声的抑制效果。</li>
<li><strong>形状匹配与模板匹配</strong>：结合形状匹配和模板匹配技术，提高对旋转和变形扑克牌的识别能力。</li>
<li><strong>机器学习与深度学习</strong>：利用机器学习和深度学习技术，训练分类器或分割网络，实现更加精确和智能的扑克牌识别。</li>
</ul>
</li>
</ol>
<p>通过本实验，我掌握了图像分割和形态学处理的基本方法，能够将这些技术应用于实际问题，解决图像处理中的难题。未来的研究和应用中，可以进一步优化和扩展这些技术，提升图像处理的效果和效率。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验一-数字图像处理相关软件学习</title>
    <url>/2024/03/20/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><p>Python是干啥的？</p>
<p>BMP图像的结构是什么样的？</p>
<p>用VC怎么写图像处理的程序？</p>
<h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li><p>写个简单的Python程序，完成以下操作：</p>
<p>a)	打开一幅图片（如自己的照片）</p>
<p>b)	将图片大小修改成640*480</p>
<p>c)	将修改大小后的图像转成黑白图像</p>
<p>d)	将图像存成gif格式</p>
</li>
<li><p>不知道大家还记不记得奥运开幕式中那一幅幅小的笑脸照片组成大大的笑脸环节，其实日常生活中也有很多这样类似的创意，用很多幅小的相关图片组成一副大的主题图片，如下面右图就是用很多表情笑脸图合成左图的效果。考虑一下如果自己写程序的话，怎么来实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps1.jpg"
                      alt="img"
                ></p>
</li>
</ol>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li>写个简单的Python程序，完成指定操作。</li>
</ol>
<p>(1) 首先安装Python的图像处理库Pillow</p>
<p>(2) 导入库中的Image对象</p>
<p>(3) 使用Image对象的open函数打开图像</p>
<p>(4) 通过resize方法将图像大小设置为640x480</p>
<p>(5) 通过convert方法将图像灰度化</p>
<p>(6) 通过save方法将处理后的图像保存下来</p>
<ol start="2">
<li>马赛克图像合成。</li>
</ol>
<p>准备实验环境和素材。</p>
<p>(1) 安装Python的图像处理库Pillow和数学运算库NumPy。</p>
<p>(2) 准备一个大的目标图像和一组小图片素材。</p>
<p>处理小图片集。</p>
<p>(1) 定义函数以计算小图片的平均颜色。</p>
<p>(2) 遍历图标文件夹，调整每个小图片的大小。</p>
<p>实现马赛克图像合成。</p>
<p>(1) 定义函数以创建马赛克图像。</p>
<p>(2) 调整目标图像的大小以适应马赛克格子。</p>
<p>(3) 分割目标图像并为每个格子选择颜色匹配的小图片。</p>
<p>(4) 将小图片粘贴到对应的马赛克格子中。</p>
<p>保存并测试结果。</p>
<p>(1) 将生成的马赛克图像保存到指定路径。</p>
<p>(2) 检查输出文件夹以确认图像是否正确生成。</p>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><ol>
<li>写个简单的Python程序，完成指定操作。</li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">original_image = Image.<span class="built_in">open</span>(input_path)</span><br><span class="line">    original_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps2.png"
                      alt="img"
                > </p>
<center>图 1原始图像</center>




<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">    resized_image = original_image.resize((<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line">    resized_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps3.png"
                      alt="img"
                > </p>
<center>图 2改变大小之后的图像</center>




<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">    bw_image = resized_image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    bw_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps4.png"
                      alt="img"
                > </p>
<center>图 3灰度化之后的图像</center>




<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">bw_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_4.gif&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps5.png"
                      alt="img"
                > </p>
<center>图 4将黑白图像存成gif格式</center>



 

<ol start="2">
<li>马赛克图像合成</li>
</ol>
<p>准备实验环境和素材:</p>
<p>确保安装了Python图像处理库Pillow和数学运算库<code>NumPy</code>。</p>
<p>在代码中设置目标图像<code>（target_image_path）</code>和小图片集合<code>（icon_folder）</code>的路径。</p>
<p>处理小图片集:</p>
<p>使用<code>get_average_color(image)</code>函数计算每个小图片的平均颜色。这个函数接收一个图像对象作为参数，计算其在RGB颜色空间中的平均颜色，并返回表示这种颜色的元组。</p>
<p><code>resize_icons(icon_folder, icon_size)</code>函数遍历小图片所在的文件夹，并将每张图片调整到指定的大小。这是为了使得小图片与马赛克图像的每个格子大小相匹配。</p>
<p>实现马赛克图像合成:</p>
<p><code>create_photo_mosaic(target_image_path, icons, grid_size)</code>函数用于创建马赛克图像。</p>
<p>首先，该函数调整目标图像的大小，使其与马赛克网格的大小匹配。</p>
<p>接着，它将目标图像分割成与网格大小相匹配的小区域。</p>
<p>对于每个区域，函数找到颜色最接近该区域平均颜色的小图片，并将其放置在相应的位置上。</p>
<p>保存并测试结果:</p>
<p>一旦马赛克图像创建完毕，使用<code>mosaic_image.save(output_path)</code>将其保存到指定路径。</p>
<p>保存后的马赛克图像可以在指定的输出中查看。</p>
<p>效果浏览：</p>
<center>grid_size = (5, 5):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps6.jpg"
                      alt="img"
                > </p>
<center>grid_size = (4, 4):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps7.jpg"
                      alt="img"
                > </p>
<center>grid_size = (3, 3):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps8.jpg"
                      alt="img"
                > </p>
<center>grid_size = (3, 2):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps9.jpg"
                      alt="img"
                > </p>
<center>grid_size = (2, 3):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps10.jpg"
                      alt="img"
                > </p>
<center>grid_size = (1, 1):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps11.jpg"
                      alt="img"
                > </p>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>通过实验第一部分，我学会了如何使用Python及其第三方库Pillow进行基本的图像处理操作。这个实验让我体会到了Python在图像处理方面的强大和灵活性。通过简单的代码，我能够打开图像，改变其大小，将其转换为黑白图像，甚至将其保存为不同的格式，如GIF。这些操作在数字图像处理中非常常见，而Python使这些操作变得易于实现和理解。</p>
<p>实验中，我首先引入了Python的图像处理库Pillow，然后使用它提供的Image对象来进行各种图像操作。例如，我利用<code>open</code>函数打开了一幅图像，然后通过<code>resize</code>方法将图像的尺寸更改为640x480像素。接着，我使用了<code>convert</code>方法将图像转换为灰度（黑白）图像，最后通过<code>save</code>方法将处理后的图像保存下来。这个过程不仅加深了我对图像处理基础概念的理解，也提高了我使用编程语言来解决实际问题的能力。</p>
<p>在实验第二部分中，我进行了更为复杂的图像处理操作，即马赛克图像合成。这个过程包括创建一个由许多小图像组合成的大图像。我学会了如何处理和调整多个图像，以便将它们组合成一个单一的、具有视觉效果的图像。依靠准备的目标图像和小图片素材，编写了函数来计算小图片的平均颜色并调整其大小。之后，我通过比较颜色相似性来选择最合适的小图片，并将它们粘贴到目标图像的相应位置上。这个实验不仅锻炼了我的编程技能，还增强了我在创意图像处理方面的能力。</p>
<p>总的来说，这个实验不仅提高了我的Python编程能力，还让我对数字图像处理有了更深刻的理解。通过这些实验，我学会了如何使用编程工具来创造和操纵图像，这将对我的未来学习和职业发展大有裨益。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验三-频率域图像增强</title>
    <url>/2024/04/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><ol>
<li><p><strong>图像频域变换与滤波处理</strong>：</p>
<ul>
<li>对一系列图像（1.bmp，2.bmp，2.jpg，3.bmp，4.bmp）进行傅立叶变换和离散余弦变换（DCT）以分析其频域特征。</li>
<li>使用空间域图像增强方法来增强变换后得到的频谱图。</li>
<li>应用低通和高通滤波器对图像进行频率域滤波，并通过设置不同的阈值来观察滤波效果。</li>
</ul>
</li>
<li><p><strong>频率域图像比较分析</strong>：</p>
<ul>
<li>比较指定图像对（5.bmp和10.bmp，6.bmp和9.bmp，10.bmp、11.bmp和12.bmp）的频率域特征，分析不同图像在频率域的差异性，并探讨其背后的原因。</li>
</ul>
</li>
<li><p><strong>频谱图逆变换的优化学习实验</strong>：</p>
<ul>
<li>使用PyTorch实现离散傅里叶逆变换，并将频谱图的初始值设为高斯噪声的模型参数。</li>
<li>通过将逆变换结果与原图之间的均方误差作为损失函数，对模型参数进行优化，验证是否能够通过优化学习到精确的频谱图。</li>
</ul>
</li>
</ol>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>1.用Python写程序，对目录下的图像（1.bmp，2.bmp，2.jpg，3.bmp，4.bmp），实现： </p>
<p>①查看不同图像的傅立叶变换的图像 </p>
<p>②查看不同图像的DCT（离散余弦）变换 </p>
<p>③对变换后得到的频谱图使用空间域图像增强的方法增强效果 </p>
<p>④采用低通滤波器和高通滤波器对图像进行频率域滤波，设置不同的阈值，查看效果</p>
<p>实验图片路径为： imgs&#x2F;1.bmp</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp3_1_i的格式，输出每个任务结果</p>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p>在实验一中，我探索了图像的频域特性，应用了傅立叶变换、离散余弦变换（DCT）、频谱图增强，以及低通和高通滤波器的技术。下面将详细解释每个步骤的关键代码及其功能：</p>
<h4 id="图像加载与预处理"><a href="#图像加载与预处理" class="headerlink" title="图像加载与预处理"></a><strong>图像加载与预处理</strong></h4><p>首先，使用<code>load_images</code>函数从指定文件夹加载图像集。这个函数读取图像为灰度格式，便于后续的频域处理。每个图像文件名通过替换<code>.</code>为<code>_</code>生成一个唯一标识符，用于保存处理后的结果。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">folder</span>):</span><br><span class="line">    filenames = [<span class="string">&#x27;1.bmp&#x27;</span>, <span class="string">&#x27;2.bmp&#x27;</span>, <span class="string">&#x27;2.JPG&#x27;</span>, <span class="string">&#x27;3.bmp&#x27;</span>, <span class="string">&#x27;4.bmp&#x27;</span>]</span><br><span class="line">    images = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        img = cv2.imread(<span class="string">f&quot;<span class="subst">&#123;folder&#125;</span>/<span class="subst">&#123;filename&#125;</span>&quot;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">        <span class="keyword">if</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            identifier = filename.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">            images[filename] = (img, <span class="string">f&#x27;exp3_1_<span class="subst">&#123;identifier&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> images</span><br></pre></td></tr></table></figure></div>

<h4 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a><strong>傅立叶变换</strong></h4><p>使用<code>apply_fourier_transform</code>函数对图像执行傅立叶变换，该函数通过<code>numpy.fft</code>库计算二维傅立叶变换，将频率为0的分量移到频谱中心，并通过对数变换增强结果的可视化。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_fourier_transform</span>(<span class="params">image</span>):</span><br><span class="line">    f = np.fft.fft2(image)</span><br><span class="line">    fshift = np.fft.fftshift(f)</span><br><span class="line">    magnitude_spectrum = <span class="number">20</span> * np.log(np.<span class="built_in">abs</span>(fshift) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> magnitude_spectrum</span><br></pre></td></tr></table></figure></div>

<h4 id="离散余弦变换（DCT）"><a href="#离散余弦变换（DCT）" class="headerlink" title="离散余弦变换（DCT）"></a><strong>离散余弦变换（DCT）</strong></h4><p>在<code>apply_dct</code>函数中，图像首先被裁剪为偶数尺寸以适应DCT要求，然后应用DCT变换。结果被归一化和调整以便于显示。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_dct</span>(<span class="params">image</span>):</span><br><span class="line">    h, w = image.shape</span><br><span class="line">    image = image[:h - (h % <span class="number">2</span>), :w - (w % <span class="number">2</span>)]</span><br><span class="line">    dct = cv2.dct(np.float32(image) / <span class="number">255.0</span>)</span><br><span class="line">    <span class="keyword">return</span> dct</span><br></pre></td></tr></table></figure></div>

<h4 id="频谱图增强"><a href="#频谱图增强" class="headerlink" title="频谱图增强"></a><strong>频谱图增强</strong></h4><p><code>enhance_spectrum</code>函数通过对频谱图进行对数变换来增强其视觉表现，使得高频和低频成分的差异更加明显。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">enhance_spectrum</span>(<span class="params">spectrum</span>):</span><br><span class="line">    enhanced = np.log1p(np.<span class="built_in">abs</span>(spectrum))</span><br><span class="line">    <span class="keyword">return</span> enhanced</span><br></pre></td></tr></table></figure></div>

<h4 id="滤波器应用"><a href="#滤波器应用" class="headerlink" title="滤波器应用"></a><strong>滤波器应用</strong></h4><p><code>apply_filter</code>函数允许应用低通或高通滤波器。通过创建一个中心为1的二值掩模（对于低通滤波器）或其补集（对于高通滤波器），实现对频谱的选择性保留或剔除。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_filter</span>(<span class="params">image, low_pass=<span class="literal">True</span>, cutoff=<span class="number">30</span></span>):</span><br><span class="line">    rows, cols = image.shape</span><br><span class="line">    crow, ccol = rows // <span class="number">2</span>, cols // <span class="number">2</span></span><br><span class="line">    mask = np.zeros((rows, cols), np.uint8)</span><br><span class="line">    mask_area = (x - crow)**<span class="number">2</span> + (y - ccol)**<span class="number">2</span> &lt;= cutoff**<span class="number">2</span></span><br><span class="line">    mask[mask_area] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> low_pass:</span><br><span class="line">        mask = <span class="number">1</span> - mask</span><br><span class="line">    fshift *= mask</span><br><span class="line">    img_back = np.fft.ifft2(np.fft.ifftshift(fshift))</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">abs</span>(img_back)</span><br></pre></td></tr></table></figure></div>

<h4 id="图像处理与保存"><a href="#图像处理与保存" class="headerlink" title="图像处理与保存"></a><strong>图像处理与保存</strong></h4><p>在<code>process_and_save_image</code>函数中，我将上述所有处理步骤集成在一起，对每幅图像依次执行傅立叶变换、DCT变换、频谱增强、高通和低通滤波，然后将处理结果并排显示并保存。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_and_save_image</span>(<span class="params">img, title, filename</span>):</span><br><span class="line">    ft_image = apply_fourier_transform(img)</span><br><span class="line">    dct_image = apply_dct(img)</span><br><span class="line">    enhanced_ft = enhance_spectrum(ft_image)</span><br><span class="line">    high_pass_image = apply_filter(img, <span class="literal">False</span>, <span class="number">30</span>)</span><br><span class="line">    low</span><br><span class="line"></span><br><span class="line">_pass_image = apply_filter(img, <span class="literal">True</span>, <span class="number">30</span>)</span><br><span class="line">    fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">6</span>, figsize=(<span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="keyword">for</span> ax, image, t <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img, ft_image, dct_image, enhanced_ft, high_pass_image, low_pass_image], [<span class="string">&#x27;Original&#x27;</span>, <span class="string">&#x27;Fourier Transform&#x27;</span>, <span class="string">&#x27;DCT&#x27;</span>, <span class="string">&#x27;Enhanced Spectrum&#x27;</span>, <span class="string">&#x27;High Pass Filter&#x27;</span>, <span class="string">&#x27;Low Pass Filter&#x27;</span>]):</span><br><span class="line">        ax.imshow(image, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        ax.set_title(t)</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    plt.savefig(<span class="string">f&#x27;outputs/<span class="subst">&#123;filename&#125;</span>.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div>





<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_1_1_bmp.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_1_2_JPG.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_1_2_bmp.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_1_3_bmp.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_1_4_bmp.png"
                      alt="实际输出"
                ></p>
<ol>
<li><p>**傅立叶变换 (FT)**：</p>
<ul>
<li>傅立叶变换揭示了图像的频率成分。中心的亮点表明了低频成分的集中，这在结构简单且对称的图像中更为明显。在傅立叶图像中观察到的模式直接关联到原始图像的空间复杂度。</li>
</ul>
</li>
<li><p>**离散余弦变换 (DCT)**：</p>
<ul>
<li>DCT主要用于图像压缩中，其转换结果通常不如傅立叶变换直观。DCT图像中暗部较多，因为它集中表示了图像中的能量，并且能量大部分集中在变换的左上角，对于自然图像和复杂图案来说尤其明显。</li>
</ul>
</li>
<li><p><strong>增强频谱图</strong>：</p>
<ul>
<li>频谱图经过对数变换后，细节更加明显。这种增强有助于分析图像的频率成分，特别是在进行噪声分析和滤波设计时。</li>
</ul>
</li>
<li><p><strong>高通滤波器</strong>：</p>
<ul>
<li>高通滤波器用于突出图像中的高频细节，如边缘和细微纹理。处理后的图像显示了边缘增强的效果，特别是在复杂图案和自然场景中，高频细节被强化，而低频背景信息则被抑制。</li>
</ul>
</li>
<li><p><strong>低通滤波器</strong>：</p>
<ul>
<li>低通滤波器主要用于平滑图像，减少高频噪声。应用低通滤波后的图像显示出更平滑的外观，图像的粗糙边缘和高频噪点得到了有效抑制，适用于去噪和图像去细节化处理。</li>
</ul>
</li>
</ol>
<p>这些结果清晰地展示了各种频率域处理技术对图像特性的影响，每种处理方法针对不同的应用场景和需求有其独特的优势和局限。通过这些实验，我可以更深入地理解和利用这些技术来改善图像分析和处理的效果。</p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>2.比较5.bmp和10.bmp，6.bmp和9.bmp，10.bmp、11.bmp和12.bmp 频率域图像的不同，说明原因</p>
<p>实验图片路径为： imgs&#x2F;</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp3_2_i的格式，输出结果</p>
<h3 id="实验方案：-1"><a href="#实验方案：-1" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p>任务2主要集中在比较不同图像对的频率域特征。这里的目的是探讨不同图像在频率域的差异性，并尝试从中分析原因。这些分析有助于我理解图像内容与其频率成分之间的关系。下面是关键代码的解释和分析，以及如何用它来执行实验：</p>
<h4 id="图像加载与预处理-1"><a href="#图像加载与预处理-1" class="headerlink" title="图像加载与预处理"></a><strong>图像加载与预处理</strong></h4><p>使用<code>load_image</code>函数从指定路径加载图像，并转换为灰度格式，这是进行频率域分析的基础。这一步骤确保了处理的统一性和准确性。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">image_path</span>):</span><br><span class="line">    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    <span class="keyword">if</span> image <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;无法加载图像：<span class="subst">&#123;image_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure></div>

<h4 id="傅立叶变换-1"><a href="#傅立叶变换-1" class="headerlink" title="傅立叶变换"></a><strong>傅立叶变换</strong></h4><p>通过<code>fourier_transform</code>函数对图像执行傅立叶变换，以获取其频率域表示。这个函数不仅应用了FFT来转换图像，还通过对数变换增加了频谱的对比度，使得高频和低频成分更易于区分。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fourier_transform</span>(<span class="params">image</span>):</span><br><span class="line">    f = np.fft.fft2(image)</span><br><span class="line">    fshift = np.fft.fftshift(f)</span><br><span class="line">    spectrum = <span class="number">20</span> * np.log(np.<span class="built_in">abs</span>(fshift) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> spectrum</span><br></pre></td></tr></table></figure></div>

<h4 id="频率域特征比较"><a href="#频率域特征比较" class="headerlink" title="频率域特征比较"></a><strong>频率域特征比较</strong></h4><p><code>compare_frequency_domain</code>函数用于比较两幅图像的频率域特征。函数首先对每幅图像应用傅立叶变换，然后在一个画布上并排显示每幅图像的原始和频率域图像。这种可视化有助于直观地比较两幅图像在频率成分上的异同。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compare_frequency_domain</span>(<span class="params">image_path1, image_path2, output_filename</span>):</span><br><span class="line">    img1 = load_image(image_path1)</span><br><span class="line">    img2 = load_image(image_path2)</span><br><span class="line">    f1 = fourier_transform(img1)</span><br><span class="line">    f2 = fourier_transform(img2)</span><br><span class="line">    fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">    axes[<span class="number">0</span>, <span class="number">0</span>].imshow(img1, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    axes[<span class="number">0</span>, <span class="number">1</span>].imshow(f1, cmap=<span class="string">&#x27;hot&#x27;</span>)</span><br><span class="line">    axes[<span class="number">1</span>, <span class="number">0</span>].imshow(img2, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    axes[<span class="number">1</span>, <span class="number">1</span>].imshow(f2, cmap=<span class="string">&#x27;hot&#x27;</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.savefig(<span class="string">f&#x27;outputs/<span class="subst">&#123;output_filename&#125;</span>.png&#x27;</span>)</span><br><span class="line">    plt.close()</span><br></pre></td></tr></table></figure></div>



<h3 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_2_1.png"
                      alt="exp3_2_1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_2_2.png"
                      alt="exp3_2_2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_2_3.png"
                      alt="exp3_2_3"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_2_4.png"
                      alt="exp3_2_4"
                ></p>
<ul>
<li><p><strong>红色部分</strong>：这通常代表频谱图中的主要频率成分，即图像中最强烈的周期性结构。在具有清晰方向性条纹的图像中，如水平或垂直条纹，红色亮点或线通常沿着频谱中心线出现，指示了这些条纹的方向和间隔。红色亮点越明显，表示该方向上的周期性结构越规则和显著。</p>
</li>
<li><p><strong>黄色部分</strong>：黄色通常表示频谱中的次级频率成分，它们可能不如主要成分（红色）强烈，但仍然标志着图像中的重要周期性特征。在斜条纹或更复杂图案的图像中，黄色亮线或点可能呈现交叉或分布于不同的方向，表明图像具有多个主要的频率成分。</p>
</li>
<li><p><strong>黑色背景</strong>：黑色区域表示频谱中相对较低或没有能量的区域，这表明原图在这些频率上没有明显的结构或周期性信息。这些区域的存在帮助突出了更有结构性或周期性的图像特征。</p>
</li>
<li><p>这些频率域的图像清晰地展示了图像结构的方向性特征如何影响其频谱表示：</p>
<ul>
<li>水平或垂直条纹主要在垂直或水平方向上产生亮线。</li>
<li>条纹的密集程度影响频率域中亮线的分散程度。</li>
<li>斜向条纹导致频率域中多方向的亮线交叉，表明图像具有多个主要方向的频率成分。</li>
</ul>
<p>通过这些实验，可以更深入地理解图像内容与其频率特性之间的关系，为图像分析和处理提供了有力的视觉和定量工具。这种分析特别有助于在图像处理和机器视觉应用中设计更有效的滤波和图像识别算法。</p>
</li>
</ul>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h3 id="实验要求：-2"><a href="#实验要求：-2" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>3.通过离散傅里叶变换我可以得到频谱图，通过离散傅里叶逆变换我可以将频谱图转换为原图，请使用pytorch实现离散傅里叶逆变换（可使用库函数或自定义函数），并将频谱图设置为初始值为高斯噪声的模型参数，利用逆变换的结果与原图之间的均方误差作为损失函数对模型参数进行优化，验证是否能够通过优化学习到频谱图。</p>
<p>实验图片路径为：imgs&#x2F;2.JPG</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp3_3_i的格式，输出结果</p>
<h3 id="实验方案：-2"><a href="#实验方案：-2" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p>任务3的目的是通过离散傅里叶逆变换（IDFT）从频谱图重建图像，并使用机器学习技术优化重建过程。该任务利用PyTorch框架进行实现，以下是关键代码的逐步分析和对应的实验过程解释：</p>
<h4 id="图像加载与预处理-2"><a href="#图像加载与预处理-2" class="headerlink" title="图像加载与预处理"></a><strong>图像加载与预处理</strong></h4><p>使用<code>load_image</code>函数加载图像并将其转换为灰度格式，这是进行频域操作的标准准备步骤。转换为灰度是因为颜色信息在此类任务中通常不是必需的，而且灰度化简化了数据处理。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="keyword">with</span> Image.<span class="built_in">open</span>(image_path) <span class="keyword">as</span> img:</span><br><span class="line">        img = img.convert(<span class="string">&#x27;L&#x27;</span>)  <span class="comment"># 将图像转换为灰度格式</span></span><br><span class="line">    <span class="keyword">return</span> torch.tensor(np.array(img), dtype=torch.float32) / <span class="number">255.0</span></span><br></pre></td></tr></table></figure></div>

<h4 id="频谱参数初始化"><a href="#频谱参数初始化" class="headerlink" title="频谱参数初始化"></a><strong>频谱参数初始化</strong></h4><p><code>init_params</code>函数初始化频谱的实部和虚部参数，这些参数将被视为需要优化的模型参数。使用标准正态分布进行初始化是一种常见的做法，可以帮助加速优化过程。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_params</span>(<span class="params">shape</span>):</span><br><span class="line">    real = torch.randn(shape, requires_grad=<span class="literal">True</span>)  <span class="comment"># 初始化实部参数</span></span><br><span class="line">    imag = torch.randn(shape, requires_grad=<span class="literal">True</span>)  <span class="comment"># 初始化虚部参数</span></span><br><span class="line">    <span class="keyword">return</span> real, imag</span><br></pre></td></tr></table></figure></div>

<h4 id="离散傅里叶逆变换"><a href="#离散傅里叶逆变换" class="headerlink" title="离散傅里叶逆变换"></a><strong>离散傅里叶逆变换</strong></h4><p><code>inverse_fft</code>函数将初始化的频谱参数（实部和虚部）合成复数，并执行逆傅立叶变换。这个逆变换的目的是从频谱图重建出原始图像。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inverse_fft</span>(<span class="params">real, imag</span>):</span><br><span class="line">    complex_img = torch.<span class="built_in">complex</span>(real, imag)  <span class="comment"># 合成复数</span></span><br><span class="line">    <span class="keyword">return</span> ifft2(complex_img).<span class="built_in">abs</span>()  <span class="comment"># 执行逆变换并取模</span></span><br></pre></td></tr></table></figure></div>

<h4 id="优化与训练过程"><a href="#优化与训练过程" class="headerlink" title="优化与训练过程"></a><strong>优化与训练过程</strong></h4><p>在<code>main</code>函数中，设置了模型训练的各个阶段，包括损失函数的定义、优化器的配置以及学习率调度器的设置。损失函数使用均方误差（MSE），优化器使用Adam，这两者都是处理此类问题的常见选择。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    img = load_image(<span class="string">&#x27;imgs/2.png&#x27;</span>)</span><br><span class="line">    params_real, params_imag = init_params(img.shape)</span><br><span class="line">    optimizer = Adam([params_real, params_imag], lr=<span class="number">0.01</span>, weight_decay=<span class="number">1e-5</span>)</span><br><span class="line">    scheduler = StepLR(optimizer, step_size=<span class="number">1000</span>, gamma=<span class="number">0.5</span>)</span><br><span class="line">    loss_fn = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        reconstructed_img = inverse_fft(params_real, params_imag)</span><br><span class="line">        loss = loss_fn(reconstructed_img, img)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        scheduler.step()</span><br></pre></td></tr></table></figure></div>

<p>在这个过程中，每500次迭代记录一次重建的图像状态，以便可视化和评估模型的性能。这种定期记录的方法有助于监控重建过程的进展和效果。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">    process_images.append(reconstructed_img.detach().clone())</span><br></pre></td></tr></table></figure></div>

<h4 id="结果可视化与保存"><a href="#结果可视化与保存" class="headerlink" title="结果可视化与保存"></a><strong>结果可视化与保存</strong></h4><p>最后，通过matplotlib绘制原始图像、中间过程图和最终重建图像，展示了从初始化的高斯噪声到接近原始图像的逐步重建过程。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">titles = [<span class="string">&#x27;Original&#x27;</span>, <span class="string">&#x27;Intermediate&#x27;</span>, <span class="string">&#x27;Final Reconstruction&#x27;</span>]</span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">18</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> ax, image, title <span class="keyword">in</span> <span class="built_in">zip</span>(axes, [img] + process_images[-<span class="number">2</span>:], titles):</span><br><span class="line">    ax.imshow(image.numpy(), cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    ax.set_title(title)</span><br><span class="line">    ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;outputs/exp3_3_i.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>



<h3 id="实验结果：-2"><a href="#实验结果：-2" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/exp3_3_1.png"
                      alt="image-20240430200732832"
                ></p>
<ol>
<li><strong>原始图像</strong>：<ul>
<li>这是重建任务的基准图像，用作损失函数计算的参考。</li>
</ul>
</li>
<li><strong>中间重建（1500次迭代）</strong>：<ul>
<li>在1500次迭代后的图像显示了重建过程的中间阶段。此时的图像还包含大量的噪声和不清晰的细节，说明重建过程尚未完成，但重建的主体结构开始变得可辨认。</li>
</ul>
</li>
<li><strong>最终重建（2000次迭代）</strong>：<ul>
<li>经过2000次迭代，图像的重建质量显著提高。比较中间和最终重建图像，可以看到细节更加清晰，噪声大幅减少。这表明优化过程有效地调整了频谱参数，逐渐接近原始图像的质量。</li>
</ul>
</li>
</ol>
<h4 id="技术细节与优化过程"><a href="#技术细节与优化过程" class="headerlink" title="技术细节与优化过程"></a>技术细节与优化过程</h4><ul>
<li><strong>损失函数</strong>：使用均方误差（MSE）来量化重建图像与原始图像之间的差异。MSE提供了一个量化的衡量标准，用于评估图像质量和指导参数的优化。</li>
<li><strong>优化器与学习率调度</strong>：使用Adam优化器因其适应性高，能够自动调整每个参数的学习率。配合学习率调度器，系统能够在训练过程中调整学习速率，帮助优化过程在初期快速收敛，在后期稳定细化。</li>
<li><strong>实部与虚部参数</strong>：初始设定为正态分布的随机数，这种随机初始化方法有助于破坏初始的结构偏见，允许算法在重建过程中自由探索空间，寻找最佳解。</li>
</ul>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>在本次实验中，我深入探讨了图像处理中的频率域技术。实验目标是通过对图像进行频域变换和滤波处理，以及通过优化技术重新学习图像的频谱图，来增强图像质量和理解图像内容。</p>
<p><strong>实验一的关键发现：</strong></p>
<ul>
<li><strong>傅立叶变换</strong>和<strong>DCT变换</strong>有效地揭示了图像的频率成分，其中傅立叶变换提供了全面的频率信息，而DCT更适用于压缩和编码应用。</li>
<li>通过增强处理的频谱图在视觉上更易于分析，尤其是对于识别图像中的主要频率成分。</li>
<li>低通和高通滤波器的应用展示了如何通过频率域处理来平滑图像或增强图像边缘。</li>
</ul>
<p><strong>实验二的关键发现：</strong></p>
<ul>
<li>不同图像对的频率域特征比较揭示了图像间的明显差异，这些差异通常与图像的细节和纹理复杂度相关。</li>
<li>高频成分的分布与图像内容的复杂性和边缘信息密切相关，而低频成分则与图像的整体形状和结构特征相关。</li>
</ul>
<p><strong>实验三的关键发现：</strong></p>
<ul>
<li>离散傅里叶逆变换实验显示，通过优化可以从初始化的高斯噪声中学习到精确的频谱图，从而重建与原图非常接近的图像。</li>
<li>该过程验证了频谱图中包含的丰富信息和通过逆变换重建图像的可行性。</li>
</ul>
<p>总之，这一系列实验不仅增强了我的图像处理技能，特别是在频率域分析和处理方面，还加深了我对图像结构和内容如何影响其频率特性的理解。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验二-空间域的图像增强</title>
    <url>/2024/04/10/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><p>用Python写一段程序，针对提供的图片IMG_2546.jpg，实现： </p>
<p>1. </p>
<ul>
<li><p>①查看直方图 </p>
</li>
<li><p>②取反，再查看直方图 </p>
</li>
<li><p>③使用直方图均衡，再查看直方图 </p>
</li>
<li><p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
</li>
</ul>
<ol start="2">
<li><p>人脸1.jpg、2.jpg、3.jpg、4.jpg进行滤波等操作实现类似美图秀秀磨皮功能，并对比磨皮前后直方图变化。</p>
</li>
<li><p>将Sobel算子编码到pytorch卷积核中，并用编码的卷积核对图像100_3228.jpg执行卷积操作，输出结果，理解卷积操作与空间域滤波的关系。</p>
</li>
</ol>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li>用Python写一段程序，针对提供的图片IMG_2546.jpg，实现：</li>
</ol>
<p>①查看直方图 </p>
<p>②取反，再查看直方图 </p>
<p>③使用直方图均衡，再查看直方图 </p>
<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p>实验图片路径为： imgs&#x2F;IMG_2546.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_1_i的格式，输出四个结果，比如①的结果保存为：outputs&#x2F;exp2_1_1.jpg</p>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p><strong>步骤一：查看原图直方图</strong></p>
<ul>
<li>首先，加载图片并使用OpenCV库进行读取。</li>
<li>使用Matplotlib绘制图像的直方图，这是通过计算每个颜色通道的像素强度分布来完成的。</li>
<li>保存包含原图和直方图的组合图像为 <code>outputs/exp2_1_1.jpg</code>。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ①查看原图直方图</span></span><br><span class="line">save_image_and_histogram(img, <span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Original Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：取反图像并查看直方图</strong></p>
<ul>
<li>对原始图像进行取反操作，这意味着将每个像素的颜色值变为其补色。</li>
<li>再次绘制取反后图像的直方图，并保存。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ②取反并查看直方图</span></span><br><span class="line">img_neg = cv2.bitwise_not(img)</span><br><span class="line">save_image_and_histogram(img_neg, <span class="string">&#x27;Negative Image&#x27;</span>, <span class="string">&#x27;Negative Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：直方图均衡化并查看直方图</strong></p>
<ul>
<li>将图像从BGR色彩空间转换为YUV色彩空间。</li>
<li>对Y通道（亮度）进行直方图均衡化，这能改善图像的对比度。</li>
<li>再次绘制直方图均衡化后图像的直方图，并保存。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ③直方图均衡化并查看直方图</span></span><br><span class="line">img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span><br><span class="line">img_yuv[:,:,<span class="number">0</span>] = cv2.equalizeHist(img_yuv[:,:,<span class="number">0</span>])</span><br><span class="line">img_histeq = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)</span><br><span class="line">save_image_and_histogram(img_histeq, <span class="string">&#x27;Histogram Equalization&#x27;</span>, <span class="string">&#x27;Eq Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：精确提取文本区域</strong></p>
<ul>
<li>考虑到文本可能因拍摄角度而不完全水平，我应用了一个旋转变换，使文本尽可能地水平以便裁剪。</li>
<li>设置旋转中心为图像中心，并指定旋转角度（在这里是-10度）。这个角度可能需要根据具体图片进行微调。</li>
<li>应用旋转后，根据旋转后的图像内容，手动确定“爱丁堡花园”文本的精确位置并进行裁剪。</li>
<li>最后，将旋转和裁剪后的区域保存为 <code>outputs/exp2_1_4.jpg</code>，这是仅包含目标文本区域的图片。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ④仅保留“爱丁堡花园”部分</span></span><br><span class="line"><span class="comment"># 获取图像尺寸用于计算旋转中心</span></span><br><span class="line">rows, cols, _ = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置旋转矩阵，中心点为图像中心，旋转角度为-10度，缩放因子为1</span></span><br><span class="line">M = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), -<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转图像</span></span><br><span class="line">rotated_img = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在旋转后的图像中确定“爱丁堡花园”文字的大致位置</span></span><br><span class="line">img_crop = rotated_img[<span class="number">550</span>:<span class="number">630</span>, <span class="number">600</span>:<span class="number">910</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存剪裁后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>exp2_1_4.jpg&#x27;</span>, img_crop)</span><br></pre></td></tr></table></figure></div>



<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p>①查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show01.png"
                      alt="实际输出"
                ></p>
<p>②取反，再查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show02.png"
                      alt="实际输出"
                ></p>
<p>③使用直方图均衡，再查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show03.png"
                      alt="实际输出"
                ></p>
<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show04.png"
                      alt="实际输出"
                ></p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>人脸1.jpg、2.jpg、3.jpg、4.jpg进行滤波等操作实现类似美图秀秀磨皮功能，并对比磨皮前后直方图变化。</p>
<p>实验图片路径为： imgs&#x2F;1.jpg imgs&#x2F;2.jpg imgs&#x2F;3.jpg imgs&#x2F;4.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_2_i的格式，输出四个结果，比如结果保存为：outputs&#x2F;exp2_2_1.jpg</p>
<h3 id="实验方案：-1"><a href="#实验方案：-1" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p>通过应用双边滤波器对给定的人脸图像进行磨皮处理，然后对比处理前后图像的直方图变化。双边滤波器是一种非线性的滤波方法，它可以在平滑图像噪声的同时保留边缘信息，因此特别适合于图像美化处理。在Python中，可以使用OpenCV库中的<code>bilateralFilter</code>函数来实现这一操作。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用双边滤波器进行磨皮</span></span><br><span class="line">smoothed = cv2.bilateralFilter(image, d=<span class="number">9</span>, sigmaColor=<span class="number">75</span>, sigmaSpace=<span class="number">75</span>)</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>d</code>表示滤波器的直径，<code>sigmaColor</code>表示颜色空间的标准差，<code>sigmaSpace</code>表示坐标空间的标准差。这些参数决定了滤波器平滑图像的程度。</p>
<p>直方图的对比通过计算原图像和磨皮后图像的颜色直方图，并用不同颜色的线表示出来。这一过程可以直观地观察磨皮效果对图像色彩分布的影响。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算直方图并绘制</span></span><br><span class="line">hist_original = cv2.calcHist([original], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_smoothed = cv2.calcHist([smoothed], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(hist_original, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.plot(hist_smoothed, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;Smoothed&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show10.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show11.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show12.png"
                      alt="实际输出"
                ></p>
<p><strong>图1的分析</strong></p>
<p>原始图像和经过双边滤波处理后的图像在直方图上差别不大。这表明图像的磨皮效果较为自然，没有过度平滑，同时保持了原图的色彩特征。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show20.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show21.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show22.png"
                      alt="实际输出"
                ></p>
<p><strong>图2的分析</strong></p>
<p>可以看到在某些颜色通道中，经过滤波处理后的直方图在峰值附近略微平滑，但整体色彩分布的变化不是特别显著。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show30.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show31.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show32.png"
                      alt="实际输出"
                ></p>
<p><strong>图3的分析</strong></p>
<p>滤波后图像的直方图在低亮度区域有了平滑，说明磨皮处理降低了图像中的暗部噪声。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show40.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show41.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show42.png"
                      alt="实际输出"
                ></p>
<p><strong>图4的分析</strong></p>
<p>图像的直方图曲线在整体上变得更加平滑，尤其是在亮度较高区域的变化更为明显。这可能意味着图像亮部的细节被稍微抑制，从而减少了噪声并增强了整体的视觉效果。</p>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h3 id="实验要求：-2"><a href="#实验要求：-2" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p> 将Sobel算子编码到pytorch卷积核中，并用编码的卷积核对图像100_3228.jpg执行卷积操作，输出结果（水平梯度图像、垂直梯度图像和梯度幅值图像），理解卷积操作与空间域滤波的关系。</p>
<p>实验图片路径为： imgs&#x2F;100_3228.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_3_i的格式，输出结果 比如结果保存为：outputs&#x2F;exp2_3_1.jpg</p>
<h3 id="实验方案：-2"><a href="#实验方案：-2" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p><strong>步骤一：读取和预处理图像</strong></p>
<ul>
<li>读取图像<code>100_3228.jpg</code>。</li>
<li>将图像转换为灰度格式以准备进行Sobel边缘检测。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img = transform(image)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：定义Sobel卷积核</strong></p>
<ul>
<li>定义Sobel卷积核<code>sobel_x</code>和<code>sobel_y</code>以检测水平和垂直边缘。</li>
<li>这些卷积核分别能够捕捉图像在水平和垂直方向上的梯度信息。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sobel_x = torch.Tensor([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">sobel_y = torch.Tensor([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：配置卷积层并执行卷积</strong></p>
<ul>
<li>配置卷积层以使用Sobel算子。</li>
<li>不使用偏置，因为在这种滤波操作中不需要。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">conv_x = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_y = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_x.weight.data = sobel_x</span><br><span class="line">conv_y.weight.data = sobel_y</span><br></pre></td></tr></table></figure></div>

<ul>
<li>应用Sobel算子于图像以得到水平和垂直梯度。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_x = conv_x(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br><span class="line">img_y = conv_y(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：计算梯度幅值</strong></p>
<ul>
<li>结合水平和垂直梯度以计算梯度幅值，这能够显示图像中边缘的整体强度。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_magnitude = torch.sqrt(img_x**<span class="number">2</span> + img_y**<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤五：执行阈值化处理</strong></p>
<ul>
<li>通过设置阈值，去除噪声并突出边缘。</li>
<li>阈值化后的结果只保留较强的边缘。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">threshold = img_magnitude.mean() * <span class="number">0.5</span></span><br></pre></td></tr></table></figure></div>

<p><strong>步骤六：可视化与保存结果</strong></p>
<ul>
<li>保存水平和垂直梯度图像，以及梯度幅值图像。</li>
<li>使用<code>matplotlib</code>对图像进行可视化。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">visualize_and_save(img_x_thresholded, <span class="string">&#x27;Horizontal Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_1.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_y_thresholded, <span class="string">&#x27;Vertical Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_2.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_magnitude, <span class="string">&#x27;Gradient Magnitude&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="实验结果：-2"><a href="#实验结果：-2" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show50.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show51.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show52.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show53.png"
                      alt="实际输出"
                ></p>
<ol>
<li><strong>水平梯度图像</strong>: 这张图像展示了原始图像中沿水平方向边缘的强度。在水平梯度图中，垂直边缘（如山和建筑物尖顶的轮廓）被突出显示。由于Sobel算子在水平方向上捕捉垂直边缘，所以图像中明显的垂直线条和特征在这里以较亮的像素显示出来，而水平边缘则不明显或显得较暗。</li>
<li><strong>垂直梯度图像</strong>: 与水平梯度图相对，这张图显示了沿垂直方向的边缘强度。在垂直梯度图中，水平边缘（如屋顶的边缘，建筑物所在地平缓处等等）更为明显。Sobel算子在垂直方向上识别水平边缘，因此图像中水平线条和特征在这张图上以亮像素呈现。</li>
<li><strong>梯度幅度图像</strong>: 此图像结合了水平和垂直梯度的信息，提供了边缘总体强度的视图。在梯度幅度图中，所有边缘，无论其方向如何，都以亮度的形式展现，其中亮度越强表示梯度幅度越大。这张图是通过计算水平梯度和垂直梯度在每个像素点的矢量和的幅度得到的。它提供了关于图像边缘强度最完整的视图，显示了所有明显边缘的位置。</li>
</ol>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>在本次实验中，我利用Python探索了图像处理中的空间域增强技术。实验的目标是通过对特定图像进行处理，以理解和应用直方图分析、图像取反、直方图均衡化以及卷积操作在图像增强和边缘检测中的作用。以下是本实验的关键发现和总结：</p>
<p><strong>直方图分析和图像取反</strong></p>
<ul>
<li>我观察了原始图像的直方图，并通过图像取反来了解亮度分布的变化。取反操作将图像中的亮区域变暗，暗区域变亮，直方图也相应地发生反转。</li>
</ul>
<p><strong>直方图均衡化</strong></p>
<ul>
<li>通过将图像转换到YUV色彩空间并对Y通道应用直方图均衡化，我显著提高了图像的对比度。直方图均衡化后的结果使得亮度分布更加均匀，从而增强了图像中的细节。</li>
</ul>
<p><strong>图像旋转和裁剪</strong></p>
<ul>
<li>通过旋转和裁剪操作，我成功地提取了图像中“爱丁堡花园”部分。这个过程涉及到对图像的几何变换，展示了图像处理中的区域选择技术。</li>
</ul>
<p><strong>滤波和磨皮效果</strong></p>
<ul>
<li>我对人脸图像应用了双边滤波器，实现了类似美图秀秀的磨皮效果。磨皮处理后，图像的直方图在低亮度区域变得更加平滑，显示了噪声的减少和肤色的均匀性提升。</li>
</ul>
<p><strong>Sobel边缘检测</strong></p>
<ul>
<li>将Sobel算子编码进PyTorch卷积核中并对图像进行处理，我得到了水平和垂直梯度图像以及梯度幅值图。这一过程说明了卷积操作如何作为空间域滤波器来检测图像中的边缘，是图像处理中边缘检测技术的一个经典例子。</li>
</ul>
<p>通过以上实验步骤，我加深了对图像增强技术的理解，特别是在如何利用不同的空间域滤波技术来改善视觉效果方面。实验结果表明，这些技术不仅可以增强图像的视觉质量，还可以为后续的图像分析工作提供更好的基础。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验五-小波变换及多分辨率处理</title>
    <url>/2024/05/24/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><ul>
<li>掌握小波变换的基本方法和技术。</li>
<li>使用小波变换实现图像降噪和图像融合。</li>
<li>探索小波变换在图像处理中的实际应用。</li>
</ul>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li>imgs目录下有图像laoshan.jpg，用Python写程序，将其作4阶haar小波变换，仅保留第四阶变换的系数，反变换，查看图像的结果。（Matlab代码已经给出，仅作参考）</li>
</ol>
<p>实验图片路径为：imgs&#x2F;laoshan.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp5_1_i的格式，输出每个任务结果</p>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li><p><strong>图像读取与预处理</strong>：</p>
<ul>
<li>使用 <code>cv2.imread</code> 从指定路径读取图像，并转换为灰度图像。</li>
<li>将图像数据转换为浮点数类型以便进行进一步处理。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img_path = <span class="string">&quot;imgs/laoshan.jpg&quot;</span></span><br><span class="line">img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为浮点数类型</span></span><br><span class="line">img_float = np.float32(img)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>4阶Haar小波变换</strong>：</p>
<ul>
<li>对图像进行4阶Haar小波变换，使用 <code>pywt.dwt2</code> 计算二维小波变换。</li>
<li>提取第四阶小波变换的系数。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">coeffs = pywt.dwt2(img_float, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">LL4, (LH4, HL4, HH4) = coeffs</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>保留第四阶变换的系数</strong>：</p>
<ul>
<li>仅保留第四阶变换的系数，其余系数置零。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">LL4[:] = <span class="number">0</span></span><br><span class="line">LH4[:] = <span class="number">0</span></span><br><span class="line">HL4[:] = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>小波逆变换与图像恢复</strong>：</p>
<ul>
<li>对修改后的小波系数进行逆变换，使用 <code>pywt.idwt2</code> 恢复图像。</li>
<li>将结果转换为整型，并保存。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">coeffs = LL4, (LH4, HL4, HH4)</span><br><span class="line">reconstructed_img = pywt.idwt2(coeffs, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换回整型</span></span><br><span class="line">reconstructed_img = np.uint8(reconstructed_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果图像</span></span><br><span class="line">output_path = <span class="string">&quot;outputs/exp5_1_1.png&quot;</span></span><br><span class="line">cv2.imwrite(output_path, reconstructed_img)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87%E5%A4%84%E7%90%86/1.png"
                      alt="1"
                ></p>
<p><strong>原图与处理后的对比</strong>：</p>
<ol>
<li><strong>原图特点</strong>：<ul>
<li>原图显示了崂山风景图像，图像中的细节丰富，包含大量的纹理信息。</li>
</ul>
</li>
<li><strong>处理后的图像</strong>：<ul>
<li>处理后的图像中只保留了第四阶小波变换的系数，图像的细节和纹理信息被显著简化，呈现出较为平滑的效果。</li>
</ul>
</li>
</ol>
<p><strong>分析</strong>：</p>
<ul>
<li>使用Haar小波变换对图像进行多分辨率分析，可以有效地分离图像中的高频和低频信息。</li>
<li>通过仅保留第四阶小波变换的系数，图像的高频细节被抑制，表现为图像的平滑化效果。</li>
</ul>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol start="2">
<li>imgs目录下有图像1.jpg和2.jpg，用Python写程序，使用基于小波变换的方法将2.jpg中的人物融合到1.jpg中，提升融合效果。</li>
</ol>
<p>实验图片路径为：imgs&#x2F;1.jpg imgs&#x2F;2.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp5_2_i的格式，输出每个任务结果</p>
<h3 id="实验方案：-1"><a href="#实验方案：-1" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li><p><strong>图像读取与预处理</strong>：</p>
<ul>
<li>使用 <code>cv2.imread</code> 读取两张图像，并转换为灰度图像。</li>
<li>将图像数据转换为浮点数类型以便进行进一步处理。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img1_path = <span class="string">&quot;imgs/1.jpg&quot;</span></span><br><span class="line">img2_path = <span class="string">&quot;imgs/2.jpg&quot;</span></span><br><span class="line">img1 = cv2.imread(img1_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">img2 = cv2.imread(img2_path, cv2.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>小波变换</strong>：</p>
<ul>
<li>对两张图像进行Haar小波变换，使用 <code>pywt.dwt2</code> 计算二维小波变换。</li>
<li>提取两张图像的小波系数。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">coeffs1 = pywt.dwt2(img1, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">LL1, (LH1, HL1, HH1) = coeffs1</span><br><span class="line"></span><br><span class="line">coeffs2 = pywt.dwt2(img2, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">LL2, (LH2, HL2, HH2) = coeffs2</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>图像融合</strong>：</p>
<ul>
<li>将第二张图像的LL系数融合到第一张图像的LL系数中，使用加权平均方法进行融合。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">alpha = <span class="number">0.5</span></span><br><span class="line">merged_LL = alpha * LL1 + (<span class="number">1</span> - alpha) * LL2</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>小波逆变换与图像恢复</strong>：</p>
<ul>
<li>对融合后的小波系数进行逆变换，使用 <code>pywt.idwt2</code> 恢复图像。</li>
<li>将结果转换为整型，并保存。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">coeffs_merged = merged_LL, (LH1, HL1, HH1)</span><br><span class="line">merged_img = pywt.idwt2(coeffs_merged, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果图像</span></span><br><span class="line">output_path = <span class="string">&quot;outputs/exp5_2_1.png&quot;</span></span><br><span class="line">cv2.imwrite(output_path, merged_img)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87%E5%A4%84%E7%90%86/2.png"
                      alt="2"
                ></p>
<ol>
<li><p><strong>原图特点</strong>：</p>
<ul>
<li>第一张图像是一幅风景图像，背景复杂，包含大量细节和纹理信息。</li>
<li>第二张图像是一幅人物图像，人物占据大部分画面，细节丰富。</li>
</ul>
</li>
<li><p><strong>处理后的图像</strong>：</p>
<ul>
<li>处理后的图像中融合了第二张图像中的人物，背景的复杂性有所降低，人物与背景的融合效果较好。</li>
<li>通过小波变换，将两张图像在多分辨率层次上进行融合，提升了融合效果。</li>
</ul>
</li>
</ol>
<p><strong>分析</strong>：</p>
<ul>
<li>小波变换提供了多分辨率分析和处理的能力，可以有效地融合不同图像的细节和结构信息。</li>
<li>通过在小波域进行图像融合，可以在保持细节的同时，平滑地过渡不同图像的边界，提高了图像融合的质量。</li>
</ul>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>本次实验主要探索了小波变换及多分辨率处理技术在图像处理中的应用。在第一项任务中，通过对图像进行4阶Haar小波变换并保留第四阶系数，成功地简化了图像的高频细节，展示了小波变换在图像平滑化处理中的效果。在第二项任务中，通过小波变换实现了两张图像的融合，增强了图像的融合效果，展示了小波变换在图像融合处理中的应用价值。</p>
<p>通过本次实验，我进一步理解了小波变换的原理和应用方法，掌握了如何利用小波变换进行图像的多分辨率分析和处理。这些技术在实际的图像处理应用中具有重要的意义，为解决更加复杂的图像处理问题提供了有力的工具和方法。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验四-图像恢复和滤波处理</title>
    <url>/2024/05/11/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E5%9B%BE%E5%83%8F%E6%81%A2%E5%A4%8D%E5%92%8C%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><ul>
<li>掌握图像恢复基本方法和技术。</li>
<li>使用频域滤波去除图像中的条纹干扰。</li>
<li>应用自适应中值滤波器去除图像随机噪声。</li>
</ul>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>imgs目录下有图像windmill_noise.png，用Python写程序，去除条纹干扰。</p>
<p>实验图片路径为： imgs&#x2F;windmill_noise.png</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp4_1_i的格式，输出每个任务结果</p>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li><p><strong>图像读取与预处理</strong>：</p>
<ul>
<li>使用 <code>Image.open</code> 从指定路径读取图像，并使用 <code>convert(&#39;L&#39;)</code> 转换为灰度图像。</li>
<li>将图像数据转换为numpy数组以便进行进一步处理。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(image_path).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">image = np.array(image)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>傅里叶变换</strong>：</p>
<ul>
<li>对图像进行傅里叶变换，将图像从空间域转换到频域，使用 <code>fft2</code> 计算二维傅里叶变换。</li>
<li>使用 <code>fftshift</code> 调整傅里叶变换的结果，使零频率分量移到频谱的中心。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">f_image = fftshift(fft2(image))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>频域过滤</strong>：</p>
<ul>
<li>在频域中创建一个遮罩，精确地屏蔽掉导致条纹干扰的频率成分。</li>
<li>通过在中心列周围设置宽度的遮罩并保持中心线不变，避免完全阻断中心线。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">width = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ccol - width, ccol + width):</span><br><span class="line">    <span class="keyword">if</span> i != ccol:</span><br><span class="line">        f_image[crow-<span class="number">1</span>:crow+<span class="number">1</span>, i] = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>傅里叶逆变换与图像恢复</strong>：</p>
<ul>
<li>对修改后的频域数据进行傅里叶逆变换，使用 <code>ifft2</code> 和 <code>ifftshift</code> 恢复图像。</li>
<li>取结果的实部，并转换为图像格式以便保存和显示。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">if_image = ifft2(ifftshift(f_image))</span><br><span class="line">filtered_image = np.<span class="built_in">abs</span>(if_image).astype(np.uint8)</span><br><span class="line">Image.fromarray(filtered_image).save(output_path + <span class="string">&#x27;exp4_1_1.png&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E5%9B%BE%E5%83%8F%E6%81%A2%E5%A4%8D%E5%92%8C%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/1.jpg"
                      alt="1"
                ></p>
<p><strong>原图与处理后的对比</strong>：</p>
<ol>
<li><strong>原图特点</strong>：<ul>
<li>原图显示了一个风车的图像，但整个图像上有明显的垂直条纹，这些条纹覆盖了图像的细节，影响视觉效果。</li>
</ul>
</li>
<li><strong>处理后的图像</strong>：<ul>
<li>处理后的图像中条纹被显著去除，风车和背景的细节更加清晰可见。</li>
<li>通过在频域内精确地屏蔽干扰的频率，有效地恢复了图像的原始外观。</li>
</ul>
</li>
</ol>
<p><strong>分析</strong>：</p>
<ul>
<li>使用傅里叶变换将图像转到频域后，条纹干扰在频域中表现为明显的峰值。通过屏蔽这些峰值，并进行傅里叶逆变换，条纹被有效地消除，恢复了图像的自然外观。</li>
</ul>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>imgs目录下有图像boardWithNoise.jpg，用Python写程序，采用自适应中值滤波器去除噪声干扰。</p>
<p>实验图片路径为： imgs&#x2F;boardWithNoise.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp4_2_i的格式，输出每个任务结果</p>
<h3 id="实验方案：-1"><a href="#实验方案：-1" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li><p><strong>图像读取与预处理</strong>：</p>
<ul>
<li>类似于任务一，读取并转换图像为灰度格式。</li>
<li>转换图像数据为numpy数组。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(image_path).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">img_array = np.array(img, dtype=np.uint8)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>中值滤波</strong>：</p>
<ul>
<li>实现中值滤波函数，其中包含使用 <code>reflect</code> 模式填充数据，避免引入边缘噪声。</li>
<li>在定义的窗口大小内，对每个像素点的周围像素进行中值运算。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">median_filter</span>(<span class="params">data, kernel_size</span>):</span><br><span class="line">    edge = kernel_size // <span class="number">2</span></span><br><span class="line">    data_padded = np.pad(data, pad_width=edge, mode=<span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">    result = np.zeros(data.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">1</span>]):</span><br><span class="line">            local_pixels = data_padded[i:i + kernel_size, j:j + kernel_size]</span><br><span class="line">            result[i, j] = np.median(local_pixels)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>滤波应用与图像保存</strong>：</p>
<ul>
<li>应用中值滤波器到图像数组上，处理噪声。</li>
<li>将处理后的图像数组转换回图像格式，并保存。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">filtered_img_array = median_filter(img_array, window_size)</span><br><span class="line">filtered_img = Image.fromarray(filtered_img_array.astype(np.uint8))</span><br><span class="line">filtered_img.save(output_path + <span class="string">&#x27;exp4_2_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E5%9B%BE%E5%83%8F%E6%81%A2%E5%A4%8D%E5%92%8C%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86/2.jpg"
                      alt="2"
                ></p>
<ol>
<li><strong>原图特点</strong>：<ul>
<li>原图是一块电路板的照片，图中存在大量随机噪声，这些噪声点扭曲了电路板的细节，使得图像看起来粗糙且细节不清。</li>
</ul>
</li>
<li><strong>处理后的图像</strong>：<ul>
<li>经过自适应中值滤波处理后，大部分的噪声被清除，电路板上的元件和线路更加清晰。</li>
<li>中值滤波通过考虑像素的局部邻域并选取中值来替换目标像素，有效去除了随机噪声，同时保持了边缘的锐度。</li>
</ul>
</li>
</ol>
<p><strong>分析</strong>：</p>
<ul>
<li>自适应中值滤波不仅去除了噪声，还保留了图像的边缘和细节，这对于电路板等需要精确细节的图像尤其重要。</li>
<li>中值滤波特别适合去除这类“胡椒和盐”类型的噪声，因为它不依赖于邻域的均值或者其他线性操作，避免了过度平滑和细节损失。</li>
</ul>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>​	本次实验主要探索了两种图像恢复技术：频域滤波和自适应中值滤波。在第一项任务中，我通过傅里叶变换成功地去除了图像中的条纹干扰，这一过程不仅提高了图像的视觉质量，还加深了我对频域分析方法在实际应用中的理解。通过适当的频域遮罩，能够精确地消除特定类型的图像噪声，显示了频域技术在图像处理领域的强大能力。</p>
<p>​	在第二项任务中，自适应中值滤波器被用于有效去除电路板图像中的随机噪声。与传统的中值滤波不同，自适应中值滤波考虑了像素的局部变异，更好地保留了图像的细节和边缘信息。这一方法对于处理随机噪声尤为有效，尤其是在噪声点随机分布的情况下。</p>
<p>​	通过这两种方法，我不仅提高了图像的质量，还验证了这些技术在处理不同类型噪声方面的适应性和效果。这次实验的成功展示了现代图像处理技术的多样性和实用性，为我解决更复杂的图像处理问题提供了宝贵的经验和技术支持。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验六-数学形态及图像压缩</title>
    <url>/2024/05/30/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%8F%8A%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><ul>
<li>掌握图像压缩和数学形态学基本方法及技术。</li>
<li>使用不同参数进行图像压缩测试，观察其效果。</li>
<li>通过形态学操作提取图片中的特定图案。</li>
</ul>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li>对 imgs 目录下的图像进行图像压缩测试，调节参数查看效果。</li>
</ol>
<p>实验图片路径为：<br>imgs&#x2F;1.jpg<br>imgs&#x2F;2.jpg<br>imgs&#x2F;3.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照 exp5_1_i 的格式，输出每个任务结果</p>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li><p><strong>图像读取与预处理</strong>：</p>
<ul>
<li>使用 <code>mpimg.imread</code> 从指定路径读取图像，并转换为 numpy 数组以便进行进一步处理。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">return</span> mpimg.imread(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image, path</span>):</span><br><span class="line">    plt.imsave(path, image)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>图像压缩</strong>：</p>
<ul>
<li>通过改变图像分辨率来“压缩”图像。</li>
<li>使用一个缩放因子，将图像的高度和宽度按比例缩小。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compress_image</span>(<span class="params">image, scale_factor=<span class="number">0.5</span></span>):</span><br><span class="line">    height, width = image.shape[:<span class="number">2</span>]</span><br><span class="line">    new_height, new_width = <span class="built_in">int</span>(height * scale_factor), <span class="built_in">int</span>(width * scale_factor)</span><br><span class="line">    compressed_image = np.zeros((new_height, new_width, image.shape[<span class="number">2</span>]), dtype=image.dtype)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(new_height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(new_width):</span><br><span class="line">            compressed_image[i, j] = image[<span class="built_in">int</span>(i / scale_factor), <span class="built_in">int</span>(j / scale_factor)]</span><br><span class="line">    <span class="keyword">return</span> compressed_image</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>图像显示与保存</strong>：</p>
<ul>
<li>显示原图和压缩后的图像对比，并将结果保存到指定路径。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_images</span>(<span class="params">original, compressed, output_path</span>):</span><br><span class="line">    fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">    axes[<span class="number">0</span>].imshow(original)</span><br><span class="line">    axes[<span class="number">0</span>].set_title(<span class="string">&#x27;Before&#x27;</span>)</span><br><span class="line">    axes[<span class="number">0</span>].axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">1</span>].imshow(compressed)</span><br><span class="line">    axes[<span class="number">1</span>].set_title(<span class="string">&#x27;After&#x27;</span>)</span><br><span class="line">    axes[<span class="number">1</span>].axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.savefig(output_path)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_images</span>():</span><br><span class="line">    input_dir = <span class="string">&quot;imgs&quot;</span></span><br><span class="line">    output_dir = <span class="string">&quot;outputs&quot;</span></span><br><span class="line">    os.makedirs(output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        path = <span class="string">f&quot;<span class="subst">&#123;input_dir&#125;</span>/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span></span><br><span class="line">        image = load_image(path)</span><br><span class="line">        compressed_image = compress_image(image, scale_factor=<span class="number">0.5</span>)</span><br><span class="line">        output_path = <span class="string">f&quot;<span class="subst">&#123;output_dir&#125;</span>/exp5_1_<span class="subst">&#123;i&#125;</span>.jpg&quot;</span></span><br><span class="line">        display_images(image, compressed_image, output_path)</span><br><span class="line"></span><br><span class="line">process_images()</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%8F%8A%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/11.png"
                      alt="1"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%8F%8A%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/12.png"
                      alt="2"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%8F%8A%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/13.png"
                      alt="3"
                ></p>
<ol>
<li><strong>原图特点</strong>：<ul>
<li>图像展示了不同的场景或物体，具有较高的分辨率和清晰度。</li>
</ul>
</li>
<li><strong>处理后的图像</strong>：<ul>
<li>经过压缩处理后，图像的分辨率明显降低，但大致轮廓和主要细节依然可见。</li>
<li>不同的图像在压缩后，质量有所差异，这与原图像的复杂度和压缩参数有关。</li>
</ul>
</li>
</ol>
<p><strong>分析</strong>：</p>
<ul>
<li>通过调整缩放因子，可以控制图像压缩后的质量和文件大小。</li>
<li>在实际应用中，需要根据具体需求平衡图像质量和存储空间。</li>
</ul>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol start="2">
<li>尝试使用形态学操作的方法提取图片 morphology.jpg 中的国旗图案。</li>
</ol>
<p>实验图片路径为：<br>imgs&#x2F;morphology.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照 exp5_2_i 的格式，输出每个任务结果</p>
<h3 id="实验方案：-1"><a href="#实验方案：-1" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li><p><strong>图像读取与预处理</strong>：</p>
<ul>
<li>使用 <code>cv2.imread</code> 读取图像，并转换为灰度图。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;imgs/morphology.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>边缘检测与形态学操作</strong>：</p>
<ul>
<li>应用高斯模糊去除噪声，并使用 Canny 边缘检测算法检测边缘。</li>
<li>使用形态学操作闭合边缘。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">blurred = cv2.GaussianBlur(gray, (<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(blurred, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>轮廓检测与国旗提取</strong>：</p>
<ul>
<li>查找轮廓，并筛选出接近国旗比例的轮廓。</li>
<li>将提取的国旗图案进行统一大小处理，并保存结果。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">contours, _ = cv2.findContours(closed.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">flags = []</span><br><span class="line">standard_flag_size = (<span class="number">90</span>, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">    x, y, w, h = cv2.boundingRect(contour)</span><br><span class="line">    aspect_ratio = w / <span class="built_in">float</span>(h)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1.4</span> &lt; aspect_ratio &lt; <span class="number">1.8</span>:</span><br><span class="line">        flag = img[y:y+h, x:x+w]</span><br><span class="line">        resized_flag = cv2.resize(flag, standard_flag_size)</span><br><span class="line">        flags.append(resized_flag)</span><br><span class="line"></span><br><span class="line">combined_height = (<span class="built_in">len</span>(flags) // <span class="number">10</span> + <span class="number">1</span>) * standard_flag_size[<span class="number">1</span>]</span><br><span class="line">combined_width = <span class="number">10</span> * standard_flag_size[<span class="number">0</span>]</span><br><span class="line">combined_image = np.zeros((combined_height, combined_width, <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, flag <span class="keyword">in</span> <span class="built_in">enumerate</span>(flags):</span><br><span class="line">    row = idx // <span class="number">10</span></span><br><span class="line">    col = idx % <span class="number">10</span></span><br><span class="line">    combined_image[row*standard_flag_size[<span class="number">1</span>]:(row+<span class="number">1</span>)*standard_flag_size[<span class="number">1</span>], col*standard_flag_size[<span class="number">0</span>]:(col+<span class="number">1</span>)*standard_flag_size[<span class="number">0</span>]] = flag</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;outputs/exp5_2_1.jpg&#x27;</span>, combined_image)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%8F%8A%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/21.png"
                      alt="4"
                ></p>
<ol>
<li><strong>原图特点</strong>：<ul>
<li>图像包含多个国旗图案和其他复杂背景元素。</li>
</ul>
</li>
<li><strong>处理后的图像</strong>：<ul>
<li>通过形态学操作，成功提取出大部分国旗图案，并将其拼接到一张图像中。</li>
<li>提取出的国旗图案清晰可见，背景杂乱的部分被有效去除。</li>
</ul>
</li>
</ol>
<p><strong>分析</strong>：</p>
<ul>
<li>形态学操作在提取特定形状和结构元素方面非常有效，特别是当目标对象具有明显的几何特征时。</li>
<li>大约有30%的国旗未能被提取出来，可能是由于这些国旗在图像中的位置、大小或形状与预设参数不完全匹配。</li>
</ul>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>本次实验主要探索了图像压缩和数学形态学操作两种技术。在第一项任务中，通过调整压缩参数，实现了不同质量的图像压缩效果。这一过程展示了图像压缩技术在实际应用中的灵活性和重要性。</p>
<p>在第二项任务中，使用形态学操作成功提取出图像中的国旗图案。这一过程不仅展示了形态学操作的强大功能，还加深了对图像结构分析和处理技术的理解。</p>
<p>通过本次实验，我不仅掌握了图像压缩和形态学操作的基本方法，还学会了如何在实际应用中灵活运用这些技术，以解决不同类型的图像处理问题。这些经验和技能将为未来更加复杂的图像处理任务提供有力支持。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>竞赛——蓝桥杯大赛-元宇宙元镜杯国家级三等奖</title>
    <url>/2023/12/24/%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B-%E5%85%83%E5%AE%87%E5%AE%99%E5%85%83%E9%95%9C%E6%9D%AF%E5%9B%BD%E5%AE%B6%E7%BA%A7%E4%B8%89%E7%AD%89%E5%A5%96/</url>
    <content><![CDATA[<p><strong>数字生活方向：</strong></p>
<p>元卧室”完美融合了元宇宙技术。将卧室，这个私人空间，变为一个无与伦比的数字体验之境。这个卧室，或者更确切地说，这个数字化奇境，以元宇宙技术为基础，让您足不出户便可实现瞬间的全球穿越。卧室还备有名为”小元”的人工智能助手，通过对话地方式带您环游世界，让您享受一个更加互动和沉浸的数字生活。</p>
<p>当您躺在舒适的床上，闭上双眼，突然之间便置身于大自然的怀抱。墙壁和天花板上的高精度全息半球形显示屏，以栩栩如生的方式呈现出各种自然景观，让您感受到真实世界的每一个细节。</p>
<p>与此同时，地板巧妙地隐藏了全息环境声音系统，使您的听觉也被沉浸其中，仿佛置身于所选择的环境之中。无论是鸟鸣虫鸣还是海浪拍打声，都让您感受到身临其境的奇妙体验。</p>
<p>足不出户就可以畅游世界，甚至模拟出一个您理想的景观，让忙碌的生活有短暂的停歇。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B-%E5%85%83%E5%AE%87%E5%AE%99%E5%85%83%E9%95%9C%E6%9D%AF%E5%9B%BD%E5%AE%B6%E7%BA%A7%E4%B8%89%E7%AD%89%E5%A5%96/%E5%85%83%E5%AE%87%E5%AE%991.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B-%E5%85%83%E5%AE%87%E5%AE%99%E5%85%83%E9%95%9C%E6%9D%AF%E5%9B%BD%E5%AE%B6%E7%BA%A7%E4%B8%89%E7%AD%89%E5%A5%96/%E5%85%83%E5%AE%87%E5%AE%992.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B-%E5%85%83%E5%AE%87%E5%AE%99%E5%85%83%E9%95%9C%E6%9D%AF%E5%9B%BD%E5%AE%B6%E7%BA%A7%E4%B8%89%E7%AD%89%E5%A5%96/%E5%85%83%E5%AE%87%E5%AE%993.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B-%E5%85%83%E5%AE%87%E5%AE%99%E5%85%83%E9%95%9C%E6%9D%AF%E5%9B%BD%E5%AE%B6%E7%BA%A7%E4%B8%89%E7%AD%89%E5%A5%96/%E8%AF%81%E4%B9%A6.png"
                      alt="证书"
                ></p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>Blender</tag>
        <tag>竞赛</tag>
        <tag>蓝桥杯</tag>
        <tag>元宇宙</tag>
      </tags>
  </entry>
  <entry>
    <title>Unreal Engine——《RTS_PCG》技术报告</title>
    <url>/2025/12/01/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/RTS_PCG-%E5%B0%81%E9%9D%A2.jpg"
                      alt="RTS_PCG-封面"
                ></p>
<hr>
<h1 id="PCG-RTS游戏：基于程序化内容生成的策略游戏开发报告"><a href="#PCG-RTS游戏：基于程序化内容生成的策略游戏开发报告" class="headerlink" title="PCG_RTS游戏：基于程序化内容生成的策略游戏开发报告"></a><strong>PCG_RTS游戏：基于程序化内容生成的策略游戏开发报告</strong></h1><h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a><strong>1. 项目概述</strong></h2><p><strong>RTS_PCG</strong> 是一款融合了程序化内容生成技术的策略模拟游戏。玩家在一个由PCG随机生成的可采集物覆盖的岛屿上，从零开始建立自己的村庄。核心玩法包括<strong>资源采集</strong>与<strong>村民管理</strong>。玩家需要使用鼠标按住并拖动不同的村民去资源点，高效地收集食物、木材、石料等资源，并扩张和发展你的定居点，最终建立起一个繁荣的文明。</p>
<h2 id="2-设计与迭代"><a href="#2-设计与迭代" class="headerlink" title="2. 设计与迭代"></a><strong>2. 设计与迭代</strong></h2><h3 id="2-1-初始灵感"><a href="#2-1-初始灵感" class="headerlink" title="2.1 初始灵感"></a><strong>2.1 初始灵感</strong></h3><p>  本项目的创作灵感主要汲取自《Foundation》、《帝国时代》等经典RTS（即时战略）游戏。这些游戏的核心乐趣在于资源管理、基地规划与单位调度。我希望在继承这种深度策略玩法的基础上，利用虚幻引擎5.6（UE5.6）全新的程序化内容生成（PCG）框架，突破传统静态地图的限制，为玩家创造一个<strong>每次开局都独一无二</strong>的动态游戏世界。</p>
<h3 id="2-2-核心目标"><a href="#2-2-核心目标" class="headerlink" title="2.2 核心目标"></a><strong>2.2 核心目标</strong></h3><p>我的开发工作围绕以下几个核心目标展开：</p>
<ol>
<li><strong>打造动态世界的基石</strong>：PCG系统不仅是地图生成器，更是游戏世界的“操作系统”。它生成的地形、资源分布与关键点位将作为底层数据，直接驱动AI行为树、导航系统以及游戏逻辑，实现一个真正“可交互”的动态环境。</li>
<li><strong>技术无缝服务于玩法</strong>：我始终坚持 <strong>“玩法至上”</strong> 的设计原则。PCG技术是强大而隐形的工具，其目的是增强而非主导游戏体验。我的目标是让玩家沉浸于探索、决策与发展的策略乐趣中，感受到的是一个自然、可信的世界，而非一个冰冷的技术 demo。PCG 应该像一位无声的导演，为每一局游戏精心布置舞台，而舞台上的戏剧——即核心玩法——始终由玩家主导。</li>
<li><strong>实现无限的可重玩性</strong>：通过PCG算法保证每次地图生成的随机性与合理性，为游戏注入持久的生命力，鼓励玩家不断尝试新的策略与布局来应对未知的环境挑战。</li>
</ol>
<h3 id="2-4-素材来源"><a href="#2-4-素材来源" class="headerlink" title="2.4 素材来源"></a><strong>2.4 素材来源</strong></h3><p>本项目的美术风格与核心游戏机制极大地参考和受益于Epic官方发布的示例项目 <strong>《Cropout》</strong>。</p>
<p>![Cropout Sample Project](..&#x2F;images&#x2F;《RTS-PCG》技术报告&#x2F;Cropout Sample Project.png)</p>
<center>（图片来源：Epic Games Marketplace - Cropout Sample Project）</center>

<ul>
<li><strong>美术风格定调</strong>：《Cropout》项目提供了整套低多边形风格的建筑、角色、植被和资源资产，为本项目确立了清晰、明快且高效的视觉方向。</li>
<li><strong>核心逻辑借鉴</strong>：我深入分析并借鉴了其成熟的村民AI、资源收集链、建筑建造逻辑等核心游戏循环的蓝图实现，这为我的系统架构提供了坚实且经过验证的基础。</li>
<li><strong>深度二次开发与创新适配</strong>：在《Cropout》的坚实基础上，本项目进行了深度的定制化开发与功能拓展。其中，<strong>最核心的贡献在于使用UE5.6的PCG框架彻底重构了静态地图</strong>，将原有的固定场景升格为动态生成的无限可能，成功地将经典RTS玩法与PCG技术带来的高可重玩性深度融合。</li>
</ul>
<h2 id="3-PCG系统架构与实现"><a href="#3-PCG系统架构与实现" class="headerlink" title="3. PCG系统架构与实现"></a><strong>3. PCG系统架构与实现</strong></h2><p>本章节详细阐述程序化内容生成（PCG）系统的技术实现，重点关注如何从零开始生成游戏世界的基础结构。</p>
<h3 id="3-1-整体PCG工作流架构"><a href="#3-1-整体PCG工作流架构" class="headerlink" title="3.1 整体PCG工作流架构"></a><strong>3.1 整体PCG工作流架构</strong></h3><p>项目通过两个核心的PCG图表文件协同工作，构建出完整的游戏环境。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/Land.png"
                      alt="Cropout Sample Project"
                ></p>
<center>（`Blueprint/PCG/Land.uasset`： 负责生成大陆上的可采集资源（树木, 灌木, 石头）和小草植被。）</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/Ocean.png"
                      alt="Cropout Sample Project"
                ></p>
<center>（`Blueprint/PCG/Ocean.uasset`： 负责生成环绕大陆的海底岩石和海草。）</center>


<h3 id="3-2-关键PCG模块详解"><a href="#3-2-关键PCG模块详解" class="headerlink" title="3.2 关键PCG模块详解"></a><strong>3.2 关键PCG模块详解</strong></h3><p><strong>逻辑流程：</strong></p>
<p>以灌木生成为例，其PCG节点处理流程如下：</p>
<p><strong>节点逻辑流程与分析：</strong></p>
<ol>
<li><strong>表面采样器</strong><ul>
<li><strong>功能</strong>：这是生成的起点。它从游戏中的地形景观获取基础数据，输出一个覆盖地表的初始点云。这些点代表了灌木所有可能的生成位置。</li>
<li><strong>设计意图</strong>：确保灌木只在地形表面上生成，这是所有后续处理的基础。</li>
</ul>
</li>
<li><strong>变换点</strong><ul>
<li><strong>功能</strong>：接收表面采样器输出的点云，并对其应用基本的变换操作。通常用于给每个点施加一个随机的<strong>旋转</strong>（绕Z轴）和<strong>轻微的位置偏移</strong>。</li>
<li><strong>设计意图</strong>：打破表面采样器带来的规整点阵，使灌木的朝向和位置更加随机、自然，避免出现人工排列的痕迹。</li>
</ul>
</li>
<li><strong>自动调整</strong><ul>
<li><strong>功能</strong>：这是一个关键的优化与真实性节点。它会根据点所在位置的<strong>表面法线</strong>自动调整灌木的倾斜度，并可能根据坡度等属性进行筛选。</li>
<li><strong>设计意图</strong>：确保灌木能够“贴合”在斜坡上，而不是垂直地悬空或插入地面，极大地增强了场景的自然度。</li>
</ul>
</li>
<li><strong>差异</strong><ul>
<li><strong>功能</strong>：此节点用于执行<strong>布尔运算</strong>。它的作用是让 <strong>A输入</strong>（即当前处理中的灌木点云）减去 <strong>B输入</strong>（已放置的树木、岩石或其他物体的点云）所占据的区域。</li>
<li><strong>设计意图</strong>：<strong>解决模型穿模问题</strong>。通过这个操作，系统能确保灌木不会生成在树木的树干或树冠正下方，使得资源分布层次分明，互不干扰，提升了场景的合理性与视觉效果。</li>
</ul>
</li>
<li><strong>生成Actor</strong><ul>
<li><strong>功能</strong>：这是最终的生成节点。它接收经过所有筛选和处理的点云，并根据指定的蓝图类（如<code>BP_Shrub</code>）或静态网格体，在场景中实际生成（Spawn）可交互的Actor实例。</li>
<li><strong>设计意图</strong>：将处理好的数据转化为游戏世界中真实的物体。与简单的<code>Static Mesh Spawner</code>不同，使用<code>生成Actor</code>可以生成带有自定义碰撞、游戏逻辑（如采集生命值）的蓝图对象。</li>
</ul>
</li>
</ol>
<p><strong>逻辑说明：</strong><br>灌木生成是一个逐步精细化的条件处理流程。从基础位置确定开始，经历自然化分布、地形适配、冲突解决等关键步骤，最终产出既随机分布又符合物理逻辑的逼真植被分布。这一完整链条充分展现了PCG技术在资源分布合理性方面的强大优势。</p>
<h2 id="4-可交互Actor蓝图系统"><a href="#4-可交互Actor蓝图系统" class="headerlink" title="4. 可交互Actor蓝图系统"></a><strong>4. 可交互Actor蓝图系统</strong></h2><p>本章节重点介绍PCG生成的世界如何通过复杂的蓝图系统获得“生命”，实现与玩家和AI的深度交互。</p>
<h3 id="4-1-游戏核心框架"><a href="#4-1-游戏核心框架" class="headerlink" title="4.1 游戏核心框架"></a><strong>4.1 游戏核心框架</strong></h3><ul>
<li>**<code>BP_GM.uasset</code> (游戏模式)**： 定义了游戏的规则、状态和流程，是连接PCG世界与游戏逻辑的总指挥。</li>
<li>**<code>BP_PC.uasset</code> &#x2F; <code>BP_Player.uasset</code> (玩家控制器&#x2F;角色)**： 处理玩家的输入指令，并将这些指令转化为对PCG生成世界的交互行为。</li>
</ul>
<h3 id="4-2-资源采集系统"><a href="#4-2-资源采集系统" class="headerlink" title="4.2 资源采集系统"></a><strong>4.2 资源采集系统</strong></h3><p>我为PCG生成的每一种资源都创建了功能完整的可交互Actor蓝图。</p>
<ul>
<li><strong>通用接口：<code>BPI_Resource.uasset</code></strong><ul>
<li><strong>功能</strong>：定义了所有可交互资源必须实现的方法，如 <code>Interact</code>，为玩家和AI提供了统一的交互契约。</li>
</ul>
</li>
<li><strong>资源基类：<code>BP_Resource.uasset</code></strong><ul>
<li><strong>核心逻辑</strong>：<ul>
<li>**自动化标签管理 (Auto-Tagging)**： 通过读取 <code>Resource Type</code>（枚举变量），将其自动转换为字符串并添加到 Actor 的 Tags 列表中。确保了场景中的所有资源都会根据其属性自动获得正确的类型标签，便于后续通过 <code>Get All Actors with Tag</code> 进行批量检索或管理。</li>
</ul>
</li>
</ul>
</li>
<li><strong>具体资源实现：</strong><ul>
<li>**<code>BP_Tree.uasset</code>**： 响应“斧头”工具，掉落“木材”，可触发村民砍伐动画。</li>
<li>**<code>BP_Rock.uasset</code>**： 响应“镐”工具，掉落“石料”，可触发村民挖矿动画。</li>
<li>**<code>BP_Shrub.uasset</code>**： 响应“徒手”采集，掉落“食物”，可触发村民采集动画。</li>
</ul>
</li>
</ul>
<h3 id="4-3-AI与PCG世界的动态交互"><a href="#4-3-AI与PCG世界的动态交互" class="headerlink" title="4.3 AI与PCG世界的动态交互"></a><strong>4.3 AI与PCG世界的动态交互</strong></h3><p>AI系统通过以下组件，理解和操作由PCG生成的动态世界。</p>
<ul>
<li><strong>环境查询系统</strong><ul>
<li>**<code>EQC_CollectionTarget.uasset</code>**： 定义查询的上下文，例如“寻找所有类型为 <code>BP_Tree</code> 的Actor”。</li>
<li>**<code>EQ_CollectionTarget.uasset</code>**： 执行查询，为AI找到最近、最合适的采集目标。</li>
</ul>
</li>
<li><strong>行为树与黑板</strong><ul>
<li>**<code>BB_CollectResource.uasset</code> (黑板)**： 作为AI的“记忆”，存储当前目标（如那棵特定的树）、携带的资源等信息。</li>
<li>**<code>BT_CollectResource.uasset</code> (行为树)**： 定义AI的采集逻辑序列：通过EQS找到目标 -&gt; 移动到目标 -&gt; 执行采集动画 -&gt; 减少目标生命值 -&gt; 携带资源返回。</li>
</ul>
</li>
</ul>
<p><strong>系统联动</strong>：PCG系统在运行时生成了 <code>BP_Tree</code> 的实例。AI的EQS系统会实时查询这些实例，行为树则驱动村民角色与这些实例进行交互。当一棵树被砍伐（<code>BP_Tree</code> 触发 <code>OnResourceDepleted</code>），游戏模式可以监听此事件，并通知PCG系统在未来于某处重新生成一棵新的树，从而形成一个完整的、动态的“生成-采集-再生”游戏循环。</p>
<h2 id="5-挑战与问题解决"><a href="#5-挑战与问题解决" class="headerlink" title="5. 挑战与问题解决"></a><strong>5. 挑战与问题解决</strong></h2><h3 id="5-1-性能优化挑战"><a href="#5-1-性能优化挑战" class="headerlink" title="5.1 性能优化挑战"></a><strong>5.1 性能优化挑战</strong></h3><ul>
<li><strong>挑战：</strong> 当PCG生成数千个实例时，游戏帧率显著下降。</li>
<li><strong>解决方案：</strong><ol>
<li><strong>LOD优化：</strong> 为所有静态网格体设置了合理的细节层次。</li>
<li><strong>PCG Culling：</strong> 在PCG图表中使用了距离和视锥体剔除，确保只在玩家附近生成和显示实例。</li>
<li><strong>材质优化：</strong> 合并材质纹理，使用材质实例来减少绘制调用。</li>
</ol>
</li>
</ul>
<h3 id="5-2-AI导航与动态环境的兼容性"><a href="#5-2-AI导航与动态环境的兼容性" class="headerlink" title="5.2 AI导航与动态环境的兼容性"></a><strong>5.2 AI导航与动态环境的兼容性</strong></h3><ul>
<li><strong>挑战：</strong> PCG在运行时生成世界，AI导航网格需要正确更新以包含新生成的建筑和障碍物。</li>
<li><strong>解决方案：</strong><ol>
<li>使用动态导航网格体边界体积，在建筑放置后强制重建局部导航网格。</li>
<li>充分利用 <code>EQS</code> 系统，让AI在寻路时能够动态感知PCG生成的对象，而不是依赖于预定义的路径点。</li>
</ol>
</li>
</ul>
<h3 id="5-3-蓝图与PCG的数据通信"><a href="#5-3-蓝图与PCG的数据通信" class="headerlink" title="5.3 蓝图与PCG的数据通信"></a><strong>5.3 蓝图与PCG的数据通信</strong></h3><ul>
<li><strong>挑战：</strong> 如何让PCG生成的对象能够被蓝图系统正确识别和交互。</li>
<li><strong>解决方案：</strong><ol>
<li>在PCG图中使用 <code>Blueprint Spawner</code> 节点，直接生成带有游戏逻辑的蓝图Actor。</li>
<li>通过标签或接口来标记PCG生成的对象类型，方便AI和玩家交互系统进行筛选和交互。</li>
</ol>
</li>
</ul>
<h2 id="6-成果展示"><a href="#6-成果展示" class="headerlink" title="6. 成果展示"></a><strong>6. 成果展示</strong></h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/RTS_PCG-%E5%B0%81%E9%9D%A2.jpg"
                      alt="Cropout Sample Project"
                ></p>
<center>（一个由PCG生成的完整岛屿全景，包含森林、石头、灌木和中心建筑。）</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/2.png"
                      alt="Cropout Sample Project"
                ></p>
<center>（村民正在按照AI指令砍伐PCG生成的树木）</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/3.png"
                      alt="Cropout Sample Project"
                ></p>
<center>（村民正在按照AI指令挖掘PCG生成的石头）</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8ARTS-PCG%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/4.png"
                      alt="Cropout Sample Project"
                ></p>
<center>（村民正在按照AI指令采集PCG生成的灌木木）</center>



<h2 id="7-最低配置要求"><a href="#7-最低配置要求" class="headerlink" title="7. 最低配置要求"></a><strong>7. 最低配置要求</strong></h2><ul>
<li><strong>操作系统：</strong> Windows 10 64-bit</li>
<li><strong>处理器：</strong> Intel Core i5-7400 或 AMD Ryzen 3 1200</li>
<li><strong>内存：</strong> 8 GB RAM</li>
<li><strong>显卡：</strong> NVIDIA GeForce GTX 1050 Ti 或 AMD Radeon RX 560</li>
<li><strong>存储空间：</strong> 需要 5 GB 可用空间</li>
</ul>
<h2 id="8-项目与构建链接"><a href="#8-项目与构建链接" class="headerlink" title="8. 项目与构建链接"></a><strong>8. 项目与构建链接</strong></h2><ul>
<li><strong>项目文件链接：</strong> [<a class="link"   href="https://github.com/Elecmark/RTS_PCG.git]" >https://github.com/Elecmark/RTS_PCG.git]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><strong>游戏构建链接：</strong> [<a class="link"   href="https://github.com/Elecmark/RTS_PCG/tree/master/Windows/RTS_PCG.exe]" >https://github.com/Elecmark/RTS_PCG/tree/master/Windows/RTS_PCG.exe]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal Engine</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>技术报告</tag>
        <tag>Unreal Engine</tag>
        <tag>RTS</tag>
        <tag>PCG</tag>
      </tags>
  </entry>
  <entry>
    <title>Unreal Engine——《Aura》Gameplay Ability System学习报告</title>
    <url>/2025/12/09/%E3%80%8AAura%E3%80%8BUE5-Gameplay-Ability-System%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="虚幻引擎5-游戏技能系统-GAS-俯视角RPG"><a href="#虚幻引擎5-游戏技能系统-GAS-俯视角RPG" class="headerlink" title="虚幻引擎5 - 游戏技能系统(GAS) - 俯视角RPG"></a>虚幻引擎5 - 游戏技能系统(GAS) - 俯视角RPG</h1><p>Create a multiplayer RPG with Unreal Engine’s Gameplay Ability System (GAS)!</p>
<h2 id="0-Introduction-介绍"><a href="#0-Introduction-介绍" class="headerlink" title="0.Introduction &#x2F; 介绍"></a>0.Introduction &#x2F; 介绍</h2><ul>
<li><p>1个讲座·12 分钟 &#x2F; 1 Lecture · 12 Minutes</p>
</li>
<li><p>Introduction</p>
<p>12:07</p>
</li>
</ul>
<h2 id="1-Project-Creation-项目创建"><a href="#1-Project-Creation-项目创建" class="headerlink" title="1.Project Creation &#x2F; 项目创建"></a>1.Project Creation &#x2F; 项目创建</h2><ul>
<li><p>14 个讲座·2 小时 26 分钟 &#x2F; 14 Lectures · 2 Hours 26 Minutes</p>
</li>
<li><p>Jetbrains Rider - Now Free for Non-Commercial Use!</p>
<p>00:26</p>
</li>
<li><p>Project Creation</p>
<p>04:56</p>
</li>
<li><p>Setting up Version Control (Optional)</p>
<p>07:26</p>
</li>
<li><p>The Base Character Class</p>
<p>10:00</p>
</li>
</ul>
<h3 id="🧙‍♀️-AuraCharacterBase-基类分析"><a href="#🧙‍♀️-AuraCharacterBase-基类分析" class="headerlink" title="🧙‍♀️ AuraCharacterBase 基类分析"></a>🧙‍♀️ <strong>AuraCharacterBase 基类分析</strong></h3><h4 id="类定义特性"><a href="#类定义特性" class="headerlink" title="类定义特性"></a><strong>类定义特性</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Abstract)  <span class="comment">// 标记为抽象类，不能被实例化</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>抽象基类</strong>：只作为父类被继承，不能直接放置到关卡中</li>
<li><strong>设计目的</strong>：提供通用功能给英雄和敌人角色共享</li>
</ul>
<h4 id="构造函数核心实现"><a href="#构造函数核心实现" class="headerlink" title="构造函数核心实现"></a><strong>构造函数核心实现</strong></h4><h5 id="1-Tick-系统禁用"><a href="#1-Tick-系统禁用" class="headerlink" title="1. Tick 系统禁用"></a><strong>1. Tick 系统禁用</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>性能优化</strong>：角色不需要每帧更新时禁用 Tick</li>
<li><strong>典型场景</strong>：AI 控制或简单动画的角色</li>
</ul>
<h5 id="2-武器组件创建"><a href="#2-武器组件创建" class="headerlink" title="2. 武器组件创建"></a><strong>2. 武器组件创建</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Weapon = <span class="built_in">CreateDefaultSubobject</span>&lt;USkeletalMeshComponent&gt;(<span class="string">&quot;Weapon&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>CreateDefaultSubobject</code>**：在构造函数中创建组件</li>
<li><strong>命名规范</strong>：给组件指定唯一名称便于调试</li>
</ul>
<h5 id="3-武器附着系统"><a href="#3-武器附着系统" class="headerlink" title="3. 武器附着系统"></a><strong>3. 武器附着系统</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Weapon-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>(), <span class="built_in">FName</span>(<span class="string">&quot;WeaponHandSocket&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>附着到骨骼</strong>：绑定到网格体的指定骨骼插槽</li>
<li>**<code>FName(&quot;WeaponHandSocket&quot;)</code>**：使用骨骼插槽名称</li>
<li><strong>动画同步</strong>：武器随角色动画自然移动</li>
</ul>
<h5 id="4-碰撞设置"><a href="#4-碰撞设置" class="headerlink" title="4. 碰撞设置"></a><strong>4. 碰撞设置</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Weapon-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>NoCollision</code>**：禁用武器所有碰撞</li>
<li><strong>设计考虑</strong>：<ul>
<li>避免武器与环境的意外碰撞</li>
<li>伤害检测通过其他系统实现（如伤害盒）</li>
</ul>
</li>
</ul>
<h4 id="UPROPERTY-配置"><a href="#UPROPERTY-配置" class="headerlink" title="UPROPERTY 配置"></a><strong>UPROPERTY 配置</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Combat&quot;</span>)</span><br><span class="line">TObjectPtr&lt;USkeletalMeshComponent&gt; Weapon;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>EditAnywhere</code>**：可在蓝图实例和类默认值中编辑</li>
<li>**<code>Category = &quot;Combat&quot;</code>**：在编辑器”Combat”分类下显示</li>
<li>**<code>TObjectPtr</code>**：UE5 安全指针，自动处理垃圾回收</li>
</ul>
<h4 id="架构设计意义"><a href="#架构设计意义" class="headerlink" title="架构设计意义"></a><strong>架构设计意义</strong></h4><h5 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><strong>继承结构</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACharacter (UE基类)</span><br><span class="line">    ↓</span><br><span class="line">AAuraCharacterBase (项目基类)</span><br><span class="line">    ├── AHeroCharacter (玩家英雄)</span><br><span class="line">    └── AEnemyCharacter (敌人)</span><br></pre></td></tr></table></figure></div>

<h5 id="职责分离"><a href="#职责分离" class="headerlink" title="职责分离"></a><strong>职责分离</strong></h5><pre><code>1. **基类**：通用组件（武器、基础属性）
2. **派生类**：特定逻辑（玩家控制、AI行为）
</code></pre>
<h4 id="扩展建议"><a href="#扩展建议" class="headerlink" title="扩展建议"></a><strong>扩展建议</strong></h4><h5 id="武器系统增强"><a href="#武器系统增强" class="headerlink" title="武器系统增强"></a><strong>武器系统增强</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可添加的扩展功能</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">EquipWeapon</span><span class="params">(USkeletalMesh* NewWeaponMesh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Attack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TakeDamage</span><span class="params">(<span class="type">float</span> DamageAmount)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="GAS-集成预留"><a href="#GAS-集成预留" class="headerlink" title="GAS 集成预留"></a><strong>GAS 集成预留</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为后续游戏技能系统准备</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAbilitySystemComponent</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAttributeSet</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h4><ul>
<li><p><strong>抽象基类</strong>：提取公共功能，减少代码重复</p>
</li>
<li><p><strong>组件化设计</strong>：武器作为独立组件便于更换</p>
</li>
<li><p><strong>性能优化</strong>：无Tick需求时及时禁用</p>
</li>
<li><p><strong>碰撞分离</strong>：攻击检测与渲染碰撞分开处理</p>
</li>
<li><p>Player and Enemy Characters</p>
<p>06:09</p>
</li>
<li><p>Character Blueprint Setup</p>
<p>12:13</p>
</li>
<li><p>Animation Blueprints</p>
<p>14:30</p>
</li>
<li><p>Enhanced Input</p>
<p>09:43</p>
</li>
<li><p>Aura Player Controller</p>
<p>11:14</p>
</li>
</ul>
<h3 id="🎮-AuraPlayerController-分析"><a href="#🎮-AuraPlayerController-分析" class="headerlink" title="🎮 AuraPlayerController 分析"></a>🎮 AuraPlayerController 分析</h3><ul>
<li>自定义玩家控制器，管理输入系统和光标控制</li>
<li>使用 UE5 <strong>增强输入系统（Enhanced Input）</strong></li>
<li>支持 <strong>多人游戏网络复制</strong></li>
</ul>
<h4 id="🔑-核心特性"><a href="#🔑-核心特性" class="headerlink" title="🔑 核心特性"></a>🔑 <strong>核心特性</strong></h4><h5 id="1-构造函数设置"><a href="#1-构造函数设置" class="headerlink" title="1. 构造函数设置"></a><strong>1. 构造函数设置</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">bReplicates = <span class="literal">true</span>;  <span class="comment">// 启用网络复制</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：让服务器同步控制器状态到所有客户端</li>
</ul>
<h5 id="2-输入系统初始化"><a href="#2-输入系统初始化" class="headerlink" title="2. 输入系统初始化"></a><strong>2. 输入系统初始化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Subsystem-&gt;<span class="built_in">AddMappingContext</span>(AuraContext, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>优先级 0</strong>：基础输入上下文</li>
<li>使用 <code>EditAnywhere</code> 可在编辑器中灵活设置</li>
</ul>
<h5 id="3-光标控制配置"><a href="#3-光标控制配置" class="headerlink" title="3. 光标控制配置"></a><strong>3. 光标控制配置</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">bShowMouseCursor = <span class="literal">true</span>;</span><br><span class="line">DefaultMouseCursor = EMouseCursor::Default;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>显示鼠标光标</li>
<li>使用默认光标样式</li>
</ul>
<h5 id="4-输入模式设置"><a href="#4-输入模式设置" class="headerlink" title="4. 输入模式设置"></a><strong>4. 输入模式设置</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">FInputModeGameAndUI InputModeData;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>游戏+UI混合模式</strong>：同时处理游戏输入和UI交互</li>
<li><strong>不锁定鼠标</strong>：可自由移动出视口</li>
<li><strong>输入时不隐藏光标</strong>：保持可见性</li>
</ul>
<h4 id="⚙️-技术要点"><a href="#⚙️-技术要点" class="headerlink" title="⚙️ 技术要点"></a>⚙️ <strong>技术要点</strong></h4><ul>
<li>**<code>check()</code>**：开发时断言验证资源有效性</li>
<li>**<code>TObjectPtr</code>**：UE5 推荐的对象指针（自动垃圾回收）</li>
<li>**<code>UEnhancedInputLocalPlayerSubsystem</code>**：管理输入上下文的核心系统</li>
</ul>
<h4 id="🎯-应用场景"><a href="#🎯-应用场景" class="headerlink" title="🎯 应用场景"></a>🎯 <strong>应用场景</strong></h4><ul>
<li><p>俯视角 RPG 游戏</p>
</li>
<li><p>需要鼠标交互的游戏</p>
</li>
<li><p>多人网络游戏</p>
</li>
<li><p>Movement Input</p>
<p>16:14</p>
</li>
</ul>
<h3 id="🔄-AuraPlayerController-输入系统升级"><a href="#🔄-AuraPlayerController-输入系统升级" class="headerlink" title="🔄 AuraPlayerController 输入系统升级"></a>🔄 <strong>AuraPlayerController 输入系统升级</strong></h3><h4 id="新增输入动作支持"><a href="#新增输入动作支持" class="headerlink" title="新增输入动作支持"></a><strong>新增输入动作支持</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;Input&quot;</span>)</span><br><span class="line">TObjectPtr&lt;UInputAction&gt; MoveAction;  <span class="comment">// 移动输入动作资源</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>UInputAction</code>**：增强输入系统的原子输入单位</li>
<li><strong>可配置性</strong>：在编辑器中指定具体的移动输入动作</li>
</ul>
<h4 id="输入组件重写"><a href="#输入组件重写" class="headerlink" title="输入组件重写"></a><strong>输入组件重写</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupInputComponent</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 重写输入绑定</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>扩展点</strong>：在父类基础上添加增强输入绑定</li>
<li><strong>最佳实践</strong>：将输入绑定逻辑集中在此函数</li>
</ul>
<h4 id="SetupInputComponent-实现"><a href="#SetupInputComponent-实现" class="headerlink" title="SetupInputComponent 实现"></a><strong>SetupInputComponent 实现</strong></h4><h5 id="1-获取增强输入组件"><a href="#1-获取增强输入组件" class="headerlink" title="1. 获取增强输入组件"></a><strong>1. 获取增强输入组件</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">UEnhancedInputComponent* EnhancedInputComponent = </span><br><span class="line">    <span class="built_in">CastChecked</span>&lt;UEnhancedInputComponent&gt;(InputComponent);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>CastChecked</code>**：安全转换，失败时断言崩溃</li>
<li><strong>类型转换</strong>：将基础输入组件转为增强输入组件</li>
</ul>
<h5 id="2-输入动作绑定"><a href="#2-输入动作绑定" class="headerlink" title="2. 输入动作绑定"></a><strong>2. 输入动作绑定</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(</span><br><span class="line">    MoveAction,                    <span class="comment">// 输入动作资源</span></span><br><span class="line">    ETriggerEvent::Triggered,      <span class="comment">// 触发事件类型</span></span><br><span class="line">    <span class="keyword">this</span>,                         <span class="comment">// 绑定的对象</span></span><br><span class="line">    &amp;AAuraPlayerController::Move   <span class="comment">// 回调函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>ETriggerEvent::Triggered</code>**：输入持续触发（如按住按键）</li>
<li><strong>函数指针绑定</strong>：将输入事件连接到成员函数</li>
</ul>
<h4 id="Move-函数实现"><a href="#Move-函数实现" class="headerlink" title="Move 函数实现"></a><strong>Move 函数实现</strong></h4><h5 id="1-输入值解析"><a href="#1-输入值解析" class="headerlink" title="1. 输入值解析"></a><strong>1. 输入值解析</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FVector2D InputAxisVector = InputActionValue.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>FVector2D</code>**：二维输入向量（WASD&#x2F;摇杆）</li>
<li><strong>泛型获取</strong>：安全获取指定类型的输入值</li>
</ul>
<h5 id="2-方向计算"><a href="#2-方向计算" class="headerlink" title="2. 方向计算"></a><strong>2. 方向计算</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0.f</span>, Rotation.Yaw, <span class="number">0.f</span>)</span></span>;  <span class="comment">// 仅保留偏航角</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>简化旋转</strong>：俯视角游戏中忽略俯仰和滚转</li>
<li><strong>偏航角</strong>：控制角色左右旋转的方向</li>
</ul>
<h5 id="3-坐标系转换"><a href="#3-坐标系转换" class="headerlink" title="3. 坐标系转换"></a><strong>3. 坐标系转换</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FVector ForwardDirection = </span><br><span class="line">    <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X);  <span class="comment">// 前方向</span></span><br><span class="line"><span class="type">const</span> FVector RightDirection = </span><br><span class="line">    <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::Y);   <span class="comment">// 右方向</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>旋转矩阵</strong>：将局部方向转换为世界方向</li>
<li><strong>坐标系</strong>：<ul>
<li><strong>X轴</strong>：前方向（前进&#x2F;后退）</li>
<li><strong>Y轴</strong>：右方向（左移&#x2F;右移）</li>
</ul>
</li>
</ul>
<h5 id="4-应用移动输入"><a href="#4-应用移动输入" class="headerlink" title="4. 应用移动输入"></a><strong>4. 应用移动输入</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">ControlledPawn-&gt;<span class="built_in">AddMovementInput</span>(ForwardDirection, InputAxisVector.Y);</span><br><span class="line">ControlledPawn-&gt;<span class="built_in">AddMovementInput</span>(RightDirection, InputAxisVector.X);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>向量分解</strong>：<ul>
<li><strong>Y分量</strong>：控制前后移动（W&#x2F;S）</li>
<li><strong>X分量</strong>：控制左右移动（A&#x2F;D）</li>
</ul>
</li>
<li><strong>叠加效果</strong>：同时按下两个方向键产生对角线移动</li>
</ul>
<h4 id="输入流程总结"><a href="#输入流程总结" class="headerlink" title="输入流程总结"></a><strong>输入流程总结</strong></h4>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入动作 → 绑定到函数 → 解析向量 → 计算方向 → 应用移动</span><br></pre></td></tr></table></figure></div>

<h4 id="设计优势"><a href="#设计优势" class="headerlink" title="设计优势"></a><strong>设计优势</strong></h4><h5 id="1-灵活性"><a href="#1-灵活性" class="headerlink" title="1. 灵活性"></a><strong>1. 灵活性</strong></h5><ul>
<li>输入映射可在编辑器中配置</li>
<li>支持多种输入设备（键盘、手柄、鼠标）</li>
</ul>
<h5 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2. 模块化"></a><strong>2. 模块化</strong></h5><ul>
<li>输入动作与逻辑分离</li>
<li>便于扩展新输入功能</li>
</ul>
<h5 id="3-维护性"><a href="#3-维护性" class="headerlink" title="3. 维护性"></a><strong>3. 维护性</strong></h5><ul>
<li><p>所有输入绑定集中管理</p>
</li>
<li><p>清晰的输入处理流程</p>
</li>
<li><p>Game Mode</p>
<p>13:23</p>
</li>
</ul>
<h3 id="🤺-AuraCharacter-玩家角色配置"><a href="#🤺-AuraCharacter-玩家角色配置" class="headerlink" title="🤺 AuraCharacter 玩家角色配置"></a>🤺 <strong>AuraCharacter 玩家角色配置</strong></h3><h4 id="角色运动组件设置"><a href="#角色运动组件设置" class="headerlink" title="角色运动组件设置"></a><strong>角色运动组件设置</strong></h4><h5 id="1-朝向运动方向"><a href="#1-朝向运动方向" class="headerlink" title="1. 朝向运动方向"></a><strong>1. 朝向运动方向</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>自动朝向</strong>：角色自动转向移动方向</li>
<li><strong>俯视角特性</strong>：视觉上更自然的移动反馈</li>
<li><strong>替代方案</strong>：如果设为 <code>false</code>，需要手动控制旋转</li>
</ul>
<h5 id="2-旋转速度配置"><a href="#2-旋转速度配置" class="headerlink" title="2. 旋转速度配置"></a><strong>2. 旋转速度配置</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;RotationRate = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="number">400.f</span>, <span class="number">0.f</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>FRotator(Pitch, Yaw, Roll)</code>**：三维旋转速度</li>
<li><strong>Yaw 400</strong>：适中的偏航旋转速度（每秒度数）</li>
<li><strong>Pitch&#x2F;Roll 为 0</strong>：俯视角游戏通常不需要俯仰和滚转</li>
</ul>
<h5 id="3-平面约束"><a href="#3-平面约束" class="headerlink" title="3. 平面约束"></a><strong>3. 平面约束</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bConstrainToPlane = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bSnapToPlaneAtStart = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>平面锁定</strong>：将角色运动限制在水平面（X-Y平面）</li>
<li><strong>初始对齐</strong>：游戏开始时自动对齐到平面</li>
<li><strong>俯视角必要性</strong>：防止意外的Z轴移动</li>
</ul>
<h4 id="控制器旋转配置"><a href="#控制器旋转配置" class="headerlink" title="控制器旋转配置"></a><strong>控制器旋转配置</strong></h4><h5 id="禁用控制器旋转继承"><a href="#禁用控制器旋转继承" class="headerlink" title="禁用控制器旋转继承"></a><strong>禁用控制器旋转继承</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">bUseControllerRotationPitch = <span class="literal">false</span>;</span><br><span class="line">bUseControllerRotationYaw = <span class="literal">false</span>;</span><br><span class="line">bUseControllerRotationRoll = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>完全解耦</strong>：角色旋转与控制器旋转完全独立</li>
<li><strong>设计目的</strong>：<ul>
<li>允许控制器单独控制相机</li>
<li>角色根据移动方向自动旋转</li>
<li>俯视角游戏的典型配置</li>
</ul>
</li>
</ul>
<h4 id="配置效果总结"><a href="#配置效果总结" class="headerlink" title="配置效果总结"></a><strong>配置效果总结</strong></h4><h5 id="运动行为"><a href="#运动行为" class="headerlink" title="运动行为"></a><strong>运动行为</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入处理 → 方向计算 → 自动旋转 → 应用移动</span><br></pre></td></tr></table></figure></div>

<h5 id="旋转关系"><a href="#旋转关系" class="headerlink" title="旋转关系"></a><strong>旋转关系</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制器（控制相机）</span><br><span class="line">    ↓ 独立</span><br><span class="line">角色（根据运动方向自动旋转）</span><br></pre></td></tr></table></figure></div>

<h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a><strong>对比分析</strong></h4><table>
<thead>
<tr>
<th>设置</th>
<th>开启效果</th>
<th>关闭效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>bOrientRotationToMovement</code></td>
<td>自动面向移动方向</td>
<td>保持当前方向</td>
</tr>
<tr>
<td><code>bUseControllerRotationYaw</code></td>
<td>跟随控制器偏转</td>
<td>旋转独立</td>
</tr>
<tr>
<td><code>bConstrainToPlane</code></td>
<td>锁定水平移动</td>
<td>允许垂直移动</td>
</tr>
</tbody></table>
<h4 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a><strong>扩展应用</strong></h4><h5 id="动画适配"><a href="#动画适配" class="headerlink" title="动画适配"></a><strong>动画适配</strong></h5><ul>
<li>自动朝向确保动画播放方向正确</li>
<li>移动停止时保持最后朝向</li>
</ul>
<h5 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a><strong>网络同步</strong></h5><ul>
<li>旋转变化会通过网络复制</li>
<li>确保所有客户端看到一致的角色朝向</li>
</ul>
<h5 id="后续扩展点"><a href="#后续扩展点" class="headerlink" title="后续扩展点"></a><strong>后续扩展点</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可添加的额外运动配置</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">600.f</span>;    <span class="comment">// 最大速度</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;BrakingDecelerationWalking = <span class="number">2000.f</span>;  <span class="comment">// 刹车减速度</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;GroundFriction = <span class="number">8.f</span>;     <span class="comment">// 地面摩擦力</span></span><br></pre></td></tr></table></figure></div>

<h4 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a><strong>最佳实践建议</strong></h4><pre><code>1. **俯视角游戏**：保持这些设置不变
2. **第一/第三人称**：需要调整 `bUseControllerRotationYaw = true`
3. **特殊移动**：可能需要禁用平面约束
4. **性能考量**：合理的旋转速率避免视觉不适
</code></pre>
<p>- </p>
<p>  Enemy Interface</p>
<p>  06:38</p>
<h3 id="🎯-Unreal-Engine-接口系统深入解析"><a href="#🎯-Unreal-Engine-接口系统深入解析" class="headerlink" title="🎯 Unreal Engine 接口系统深入解析"></a>🎯 <strong>Unreal Engine 接口系统深入解析</strong></h3><h4 id="双类接口架构"><a href="#双类接口架构" class="headerlink" title="双类接口架构"></a><strong>双类接口架构</strong></h4><h5 id="1-UInterface（反射类）"><a href="#1-UInterface（反射类）" class="headerlink" title="1. UInterface（反射类）"></a><strong>1. UInterface（反射类）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UINTERFACE</span>(MinimalAPI)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UEnemyInterface</span> : <span class="keyword">public</span> UInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>UINTERFACE</code>**：UE宏，声明反射接口类</li>
<li>**<code>MinimalAPI</code>**：仅导出必要函数，减少编译依赖</li>
<li>**继承自 <code>UInterface</code>**：UE接口基类</li>
<li><strong>作用</strong>：为反射系统提供类型信息，可在蓝图中使用</li>
</ul>
<h5 id="2-IInterface（功能类）"><a href="#2-IInterface（功能类）" class="headerlink" title="2. IInterface（功能类）"></a><strong>2. IInterface（功能类）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> IEnemyInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnHighlightActor</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>功能承载</strong>：实际定义接口方法</li>
<li>**<code>GENERATED_BODY</code>**：允许使用UE反射功能</li>
<li><strong>核心</strong>：纯虚函数声明，强制派生类实现</li>
</ul>
<hr>
<h4 id="⚡-纯虚函数详解"><a href="#⚡-纯虚函数详解" class="headerlink" title="⚡ 纯虚函数详解"></a>⚡ <strong>纯虚函数详解</strong></h4><h5 id="语法特征"><a href="#语法特征" class="headerlink" title="语法特征"></a><strong>语法特征</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FunctionName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>= 0</code>**：纯虚函数标记</li>
<li><strong>抽象性</strong>：没有默认实现</li>
<li><strong>强制性</strong>：派生类必须实现</li>
</ul>
<h5 id="纯虚函数-vs-普通虚函数"><a href="#纯虚函数-vs-普通虚函数" class="headerlink" title="纯虚函数 vs 普通虚函数"></a><strong>纯虚函数 vs 普通虚函数</strong></h5><table>
<thead>
<tr>
<th>特性</th>
<th>纯虚函数</th>
<th>普通虚函数</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td><code>= 0</code></td>
<td>有默认实现</td>
</tr>
<tr>
<td>实现要求</td>
<td><strong>必须</strong>在派生类实现</td>
<td>可选覆盖</td>
</tr>
<tr>
<td>类类型</td>
<td>使类成为<strong>抽象类</strong></td>
<td>不强制</td>
</tr>
<tr>
<td>实例化</td>
<td><strong>不能</strong>直接实例化</td>
<td>可以直接实例化</td>
</tr>
<tr>
<td>UE中用途</td>
<td>接口定义</td>
<td>基类提供默认行为</td>
</tr>
</tbody></table>
<hr>
<h4 id="🏗️-接口设计模式"><a href="#🏗️-接口设计模式" class="headerlink" title="🏗️ 接口设计模式"></a>🏗️ <strong>接口设计模式</strong></h4><h5 id="1-角色高亮接口"><a href="#1-角色高亮接口" class="headerlink" title="1. 角色高亮接口"></a><strong>1. 角色高亮接口</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 敌人交互可视化</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">// 鼠标悬停时高亮</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnHighlightActor</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 鼠标离开时取消高亮</span></span><br></pre></td></tr></table></figure></div>

<h5 id="2-实现示例"><a href="#2-实现示例" class="headerlink" title="2. 实现示例"></a><strong>2. 实现示例</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在敌人角色类中实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AEnemyCharacter</span> : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IEnemyInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 实现高亮逻辑：改变材质、添加轮廓等</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnHighlightActor</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复默认状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="🔧-UE接口系统工作机制"><a href="#🔧-UE接口系统工作机制" class="headerlink" title="🔧 UE接口系统工作机制"></a>🔧 <strong>UE接口系统工作机制</strong></h4><h5 id="反射系统集成"><a href="#反射系统集成" class="headerlink" title="反射系统集成"></a><strong>反射系统集成</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口检查</span></span><br><span class="line"><span class="keyword">if</span> (Actor-&gt;<span class="built_in">Implements</span>&lt;UEnemyInterface&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    IEnemyInterface* Enemy = <span class="built_in">Cast</span>&lt;IEnemyInterface&gt;(Actor);</span><br><span class="line">    <span class="keyword">if</span> (Enemy)</span><br><span class="line">    &#123;</span><br><span class="line">        Enemy-&gt;<span class="built_in">HighlightActor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="蓝图支持"><a href="#蓝图支持" class="headerlink" title="蓝图支持"></a><strong>蓝图支持</strong></h5><ul>
<li>可在蓝图中实现接口</li>
<li>编辑器可识别接口类型</li>
<li>支持接口事件调度</li>
</ul>
<hr>
<h4 id="🎮-游戏中的应用场景"><a href="#🎮-游戏中的应用场景" class="headerlink" title="🎮 游戏中的应用场景"></a>🎮 <strong>游戏中的应用场景</strong></h4><h5 id="敌人交互系统"><a href="#敌人交互系统" class="headerlink" title="敌人交互系统"></a><strong>敌人交互系统</strong></h5>  <pre class="mermaid">flowchart TD
    Player[玩家鼠标悬停] --> Check[检查接口]
    Check -->|有接口| Highlight[调用高亮]
    Check -->|无接口| Ignore[忽略]
    PlayerLeave[鼠标离开] --> Unhighlight[取消高亮]</pre>

<h5 id="多态调用"><a href="#多态调用" class="headerlink" title="多态调用"></a><strong>多态调用</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统一处理不同类型的敌人</span></span><br><span class="line">TArray&lt;AActor*&gt; Enemies;</span><br><span class="line"><span class="keyword">for</span> (AActor* Enemy : Enemies)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Enemy-&gt;<span class="built_in">Implements</span>&lt;UEnemyInterface&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        IEnemyInterface::<span class="built_in">Execute_HighlightActor</span>(Enemy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="💡-设计优势"><a href="#💡-设计优势" class="headerlink" title="💡 设计优势"></a>💡 <strong>设计优势</strong></h4><h5 id="1-松耦合设计"><a href="#1-松耦合设计" class="headerlink" title="1. 松耦合设计"></a><strong>1. 松耦合设计</strong></h5><ul>
<li>调用者不关心具体实现类</li>
<li>只需知道接口协议</li>
</ul>
<h5 id="2-扩展性"><a href="#2-扩展性" class="headerlink" title="2. 扩展性"></a><strong>2. 扩展性</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可轻松添加新接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IInteractable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Interact</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AEnemy</span> : <span class="keyword">public</span> IEnemyInterface, <span class="keyword">public</span> IInteractable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现两个接口的方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="3-类型安全"><a href="#3-类型安全" class="headerlink" title="3. 类型安全"></a><strong>3. 类型安全</strong></h5><ul>
<li>编译时检查接口实现</li>
<li>避免运行时错误</li>
</ul>
<hr>
<h4 id="🚀-最佳实践"><a href="#🚀-最佳实践" class="headerlink" title="🚀 最佳实践"></a>🚀 <strong>最佳实践</strong></h4><h5 id="接口命名规范"><a href="#接口命名规范" class="headerlink" title="接口命名规范"></a><strong>接口命名规范</strong></h5><ul>
<li><strong><code>I</code> 前缀</strong>：功能接口类（<code>IEnemyInterface</code>）</li>
<li><strong><code>U</code> 前缀</strong>：反射接口类（<code>UEnemyInterface</code>）</li>
<li><strong>清晰语义</strong>：接口名描述能力而非身份</li>
</ul>
<h5 id="纯虚函数设计"><a href="#纯虚函数设计" class="headerlink" title="纯虚函数设计"></a><strong>纯虚函数设计</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好的设计：职责单一</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TakeDamage</span><span class="params">(<span class="type">float</span> Damage)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免：功能过于复杂</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HandleCombat</span><span class="params">(<span class="type">float</span> Damage, FVector Location, AActor* Instigator)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="UE特定技巧"><a href="#UE特定技巧" class="headerlink" title="UE特定技巧"></a><strong>UE特定技巧</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 蓝图可调用版本</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor_Implementation</span><span class="params">()</span></span>;  <span class="comment">// C++实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯C++版本</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 强制实现</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="📊-总结对比"><a href="#📊-总结对比" class="headerlink" title="📊 总结对比"></a>📊 <strong>总结对比</strong></h4><table>
<thead>
<tr>
<th>方案</th>
<th>接口</th>
<th>继承</th>
<th>组件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>适用场景</strong></td>
<td>跨类共享能力</td>
<td>类层次关系</td>
<td>功能模块化</td>
</tr>
<tr>
<td><strong>耦合度</strong></td>
<td><strong>低</strong></td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td><strong>高</strong></td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td><strong>UE集成</strong></td>
<td>蓝图友好</td>
<td>标准继承</td>
<td>编辑器友好</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>虚函数开销</td>
<td>虚函数开销</td>
<td>可能更高</td>
</tr>
</tbody></table>
<p>  <strong>接口最适合</strong>：定义”能做什么”而不是”是什么”，特别是需要跨不同类层次共享功能的场景。</p>
<p>- </p>
<p>  Highlight Enemies</p>
<p>  19:25</p>
<h3 id="🎯-鼠标光标追踪与敌人高亮系统"><a href="#🎯-鼠标光标追踪与敌人高亮系统" class="headerlink" title="🎯 鼠标光标追踪与敌人高亮系统"></a>🎯 <strong>鼠标光标追踪与敌人高亮系统</strong></h3><h5 id="新增核心成员变量"><a href="#新增核心成员变量" class="headerlink" title="新增核心成员变量"></a><strong>新增核心成员变量</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CursorTrace</span><span class="params">()</span></span>;  <span class="comment">// 光标追踪方法</span></span><br><span class="line">TObjectPtr&lt;IEnemyInterface&gt; LastActor;  <span class="comment">// 上一帧的敌人接口</span></span><br><span class="line">TObjectPtr&lt;IEnemyInterface&gt; ThisActor;  <span class="comment">// 当前帧的敌人接口</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="🔍-PlayerTick-集成"><a href="#🔍-PlayerTick-集成" class="headerlink" title="🔍 PlayerTick 集成"></a>🔍 <strong>PlayerTick 集成</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlayerTick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>每帧调用</strong>：启用 Actor Tick 系统</li>
<li><strong>实时检测</strong>：持续追踪鼠标下方的敌人</li>
<li><strong>性能考虑</strong>：简单的射线检测开销较小</li>
</ul>
<hr>
<h4 id="🎮-CursorTrace-方法详解"><a href="#🎮-CursorTrace-方法详解" class="headerlink" title="🎮 CursorTrace 方法详解"></a>🎮 <strong>CursorTrace 方法详解</strong></h4><h5 id="1-光线投射检测"><a href="#1-光线投射检测" class="headerlink" title="1. 光线投射检测"></a><strong>1. 光线投射检测</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">FHitResult CursorHit;</span><br><span class="line"><span class="built_in">GetHitResultUnderCursor</span>(ECC_Visibility, <span class="literal">false</span>, CursorHit);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>GetHitResultUnderCursor</code>**：从光标位置发射射线</li>
<li>**<code>ECC_Visibility</code>**：可见性碰撞通道</li>
<li>**<code>false</code>**：不启用复杂碰撞检测</li>
<li><strong>返回值</strong>：包含击中信息的 <code>FHitResult</code></li>
</ul>
<h5 id="2-接口指针转换"><a href="#2-接口指针转换" class="headerlink" title="2. 接口指针转换"></a><strong>2. 接口指针转换</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">LastActor = ThisActor;  <span class="comment">// 保存上一帧结果</span></span><br><span class="line">ThisActor = <span class="built_in">Cast</span>&lt;IEnemyInterface&gt;(CursorHit.<span class="built_in">GetActor</span>());</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>Cast&lt;IEnemyInterface&gt;</code>**：尝试将 Actor 转换为敌人接口</li>
<li><strong>自动转换</strong>：如果 Actor 实现了接口，返回有效指针；否则返回 <code>nullptr</code></li>
<li><strong>指针传递</strong>：使用 <code>TObjectPtr</code> 安全存储接口指针</li>
</ul>
<hr>
<h4 id="🧠-智能状态管理逻辑"><a href="#🧠-智能状态管理逻辑" class="headerlink" title="🧠 智能状态管理逻辑"></a>🧠 <strong>智能状态管理逻辑</strong></h4><h5 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a><strong>状态转移矩阵</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">上一帧 (LastActor)  当前帧 (ThisActor)  操作</span><br><span class="line">    null                null         无操作 (A)</span><br><span class="line">    null                有效         高亮当前 (B)</span><br><span class="line">    有效                null         取消高亮上一帧 (C)</span><br><span class="line">    有效                有效(不同)   取消高亮上一帧，高亮当前 (D)</span><br><span class="line">    有效                有效(相同)   无操作 (E)</span><br></pre></td></tr></table></figure></div>

<h5 id="代码实现逻辑"><a href="#代码实现逻辑" class="headerlink" title="代码实现逻辑"></a><strong>代码实现逻辑</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况 C 和 D：需要取消上一帧的高亮</span></span><br><span class="line"><span class="keyword">if</span> (LastActor != <span class="literal">nullptr</span> &amp;&amp; LastActor != ThisActor)</span><br><span class="line">&#123;</span><br><span class="line">    LastActor-&gt;<span class="built_in">UnHighlightActor</span>();  <span class="comment">// 调用接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 B 和 D：需要高亮当前帧</span></span><br><span class="line"><span class="keyword">if</span> (ThisActor != <span class="literal">nullptr</span> &amp;&amp; ThisActor != LastActor)</span><br><span class="line">&#123;</span><br><span class="line">    ThisActor-&gt;<span class="built_in">HighlightActor</span>();  <span class="comment">// 调用接口方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="💡-设计亮点分析"><a href="#💡-设计亮点分析" class="headerlink" title="💡 设计亮点分析"></a>💡 <strong>设计亮点分析</strong></h4><h5 id="1-无状态切换优化"><a href="#1-无状态切换优化" class="headerlink" title="1. 无状态切换优化"></a><strong>1. 无状态切换优化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 避免了重复调用</span></span><br><span class="line"><span class="keyword">if</span> (ThisActor == LastActor) <span class="keyword">return</span>;  <span class="comment">// 显式优化</span></span><br><span class="line"><span class="comment">// 但代码中通过条件判断隐式实现</span></span><br></pre></td></tr></table></figure></div>

<h5 id="2-接口安全调用"><a href="#2-接口安全调用" class="headerlink" title="2. 接口安全调用"></a><strong>2. 接口安全调用</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空指针安全检查已包含在条件判断中</span></span><br><span class="line">LastActor-&gt;<span class="built_in">UnHighlightActor</span>();  <span class="comment">// 仅在 LastActor 非空时调用</span></span><br></pre></td></tr></table></figure></div>

<h5 id="3-帧间连贯性"><a href="#3-帧间连贯性" class="headerlink" title="3. 帧间连贯性"></a><strong>3. 帧间连贯性</strong></h5><ul>
<li><strong>平滑过渡</strong>：从高亮到非高亮状态自然切换</li>
<li><strong>无闪烁</strong>：避免同一物体反复高亮&#x2F;取消</li>
</ul>
<hr>
<h4 id="🚀-扩展可能性"><a href="#🚀-扩展可能性" class="headerlink" title="🚀 扩展可能性"></a>🚀 <strong>扩展可能性</strong></h4><h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><strong>性能优化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可添加距离检测</span></span><br><span class="line"><span class="type">float</span> Distance = FVector::<span class="built_in">Distance</span>(<span class="built_in">GetPawn</span>()-&gt;<span class="built_in">GetActorLocation</span>(), </span><br><span class="line">                                   CursorHit.Location);</span><br><span class="line"><span class="keyword">if</span> (Distance &gt; MaxHighlightDistance) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="视觉效果增强"><a href="#视觉效果增强" class="headerlink" title="视觉效果增强"></a><strong>视觉效果增强</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可添加淡入淡出效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CursorTrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当前实现...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展：根据距离调整高亮强度</span></span><br><span class="line">    <span class="keyword">if</span> (ThisActor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> Intensity = <span class="built_in">CalculateHighlightIntensity</span>(CursorHit.Distance);</span><br><span class="line">        ThisActor-&gt;<span class="built_in">HighlightWithIntensity</span>(Intensity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="多目标支持"><a href="#多目标支持" class="headerlink" title="多目标支持"></a><strong>多目标支持</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来可扩展为区域选择</span></span><br><span class="line">TArray&lt;TObjectPtr&lt;IEnemyInterface&gt;&gt; HighlightedActors;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HighlightArea</span><span class="params">(FVector Center, <span class="type">float</span> Radius)</span></span>;</span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="📊-与其他系统集成"><a href="#📊-与其他系统集成" class="headerlink" title="📊 与其他系统集成"></a>📊 <strong>与其他系统集成</strong></h4>  <pre class="mermaid">flowchart TD
    Input[鼠标移动事件] --> Tick[PlayerTick调用]
    Tick --> Trace[CursorTrace光线检测]
    Trace --> Interface[获取敌人接口]
    Interface --> Check[状态检查]
    
    Check -->|新敌人| Highlight[调用高亮接口]
    Check -->|离开敌人| Unhighlight[调用取消高亮接口]
    Check -->|同一敌人| NoAction[无操作]
    
    Highlight -->|触发| Enemy[敌人视觉效果]
    Unhighlight -->|触发| Enemy</pre>

<hr>
<h4 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ <strong>注意事项</strong></h4><h5 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a><strong>性能考虑</strong></h5><ul>
<li><strong>每帧调用</strong>：确保 <code>CursorTrace</code> 逻辑轻量</li>
<li><strong>射线检测</strong>：使用合适的碰撞通道和复杂度</li>
<li><strong>接口调用</strong>：虚函数调用有一定开销</li>
</ul>
<h5 id="网络同步-1"><a href="#网络同步-1" class="headerlink" title="网络同步"></a><strong>网络同步</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是多人游戏，需要考虑</span></span><br><span class="line">bReplicates = <span class="literal">true</span>;  <span class="comment">// 已启用复制</span></span><br><span class="line"><span class="comment">// 但高亮效果可能需要服务器验证</span></span><br></pre></td></tr></table></figure></div>

<h5 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a><strong>用户体验</strong></h5><ul>
<li><strong>响应速度</strong>：立即反馈鼠标悬停</li>
<li><strong>视觉清晰</strong>：高亮效果明显但不刺眼</li>
<li><strong>逻辑一致</strong>：确保不会同时高亮多个敌人</li>
</ul>
<hr>
<p>  <strong>核心改进</strong>：通过每帧的鼠标射线检测，实现了智能的敌人高亮系统，为后续的敌人选择和战斗交互奠定了基础。</p>
<p>- </p>
<p>  Post Process Highlight</p>
<p>  13:19</p>
<h3 id="👾-AuraEnemy-敌人实现类"><a href="#👾-AuraEnemy-敌人实现类" class="headerlink" title="👾 AuraEnemy 敌人实现类"></a>👾 <strong>AuraEnemy 敌人实现类</strong></h3><h4 id="多重继承结构"><a href="#多重继承结构" class="headerlink" title="多重继承结构"></a><strong>多重继承结构</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AAuraEnemy</span> : <span class="keyword">public</span> AAuraCharacterBase, <span class="keyword">public</span> IEnemyInterface</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>角色基类</strong>：继承通用的角色功能（武器、移动等）</li>
<li><strong>敌人接口</strong>：实现高亮交互能力</li>
</ul>
<h4 id="碰撞通道配置"><a href="#碰撞通道配置" class="headerlink" title="碰撞通道配置"></a><strong>碰撞通道配置</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_Visibility, ECR_Block);</span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_Camera, ECR_Ignore);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>可见性通道阻挡</strong>：确保光标射线能检测到敌人</li>
<li><strong>相机通道忽略</strong>：防止相机与敌人网格体碰撞</li>
</ul>
<h4 id="自定义深度高亮实现"><a href="#自定义深度高亮实现" class="headerlink" title="自定义深度高亮实现"></a><strong>自定义深度高亮实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCustomDepthStencilValue</span>(CUSTOM_DEPTH_RED);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>渲染通道</strong>：使用自定义深度渲染实现轮廓高亮</li>
<li><strong>模板值</strong>：<code>CUSTOM_DEPTH_RED</code> 定义高亮颜色（通常在项目头文件中定义）</li>
<li><strong>武器同步</strong>：武器组件也应用相同的高亮效果</li>
</ul>
<p>  <strong>核心</strong>：通过UE的渲染系统实现视觉反馈，将接口逻辑转化为具体的视觉效果。</p>
<h3 id="📚-第一章关键方法总结"><a href="#📚-第一章关键方法总结" class="headerlink" title="📚 第一章关键方法总结"></a>📚 第一章关键方法总结</h3><h4 id="基础类定义"><a href="#基础类定义" class="headerlink" title="基础类定义"></a>基础类定义</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Abstract)                     <span class="comment">// 声明为抽象类，不可直接实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> AAuraCharacterBase : <span class="function"><span class="keyword">public</span> ACharacter</span></span><br><span class="line"><span class="function"><span class="title">GENERATED_BODY</span><span class="params">()</span>                     <span class="comment">// UE反射系统必需宏</span></span></span><br><span class="line"><span class="function"><span class="title">UPROPERTY</span><span class="params">(EditAnywhere, Category=<span class="string">&quot;Input&quot;</span>)</span> <span class="comment">// 编辑器可见属性</span></span></span><br><span class="line"><span class="function">TObjectPtr&lt;USkeletalMeshComponent&gt; Weapon  <span class="comment">// UE5安全指针</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="组件创建与设置"><a href="#组件创建与设置" class="headerlink" title="组件创建与设置"></a>组件创建与设置</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;   <span class="comment">// 禁用Actor Tick</span></span><br><span class="line"><span class="built_in">CreateDefaultSubobject</span>&lt;USkeletalMeshComponent&gt;(<span class="string">&quot;Weapon&quot;</span>); <span class="comment">// 创建组件</span></span><br><span class="line"><span class="built_in">SetupAttachment</span>(<span class="built_in">GetMesh</span>(), <span class="built_in">FName</span>(<span class="string">&quot;WeaponHandSocket&quot;</span>));    <span class="comment">// 绑定到骨骼</span></span><br><span class="line"><span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);      <span class="comment">// 禁用碰撞</span></span><br></pre></td></tr></table></figure></div>

<h4 id="玩家控制器配置"><a href="#玩家控制器配置" class="headerlink" title="玩家控制器配置"></a>玩家控制器配置</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">bReplicates = <span class="literal">true</span>;                              <span class="comment">// 启用网络复制</span></span><br><span class="line">Subsystem-&gt;<span class="built_in">AddMappingContext</span>(AuraContext, <span class="number">0</span>);     <span class="comment">// 添加输入映射（0=优先级）</span></span><br><span class="line">bShowMouseCursor = <span class="literal">true</span>;                          <span class="comment">// 显示鼠标光标</span></span><br><span class="line"><span class="built_in">SetInputMode</span>(InputModeData);                      <span class="comment">// 设置输入模式</span></span><br></pre></td></tr></table></figure></div>

<h4 id="增强输入系统"><a href="#增强输入系统" class="headerlink" title="增强输入系统"></a>增强输入系统</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">UEnhancedInputLocalPlayerSubsystem* Subsystem = </span><br><span class="line">    ULocalPlayer::<span class="built_in">GetSubsystem</span>&lt;UEnhancedInputLocalPlayerSubsystem&gt;(<span class="built_in">GetLocalPlayer</span>());</span><br><span class="line">EnhancedInputComponent-&gt;<span class="built_in">BindAction</span>(</span><br><span class="line">    MoveAction,                    <span class="comment">// 输入动作资源</span></span><br><span class="line">    ETriggerEvent::Triggered,      <span class="comment">// 触发事件类型</span></span><br><span class="line">    <span class="keyword">this</span>,                          <span class="comment">// 目标对象</span></span><br><span class="line">    &amp;AAuraPlayerController::Move   <span class="comment">// 回调函数指针</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="角色移动处理"><a href="#角色移动处理" class="headerlink" title="角色移动处理"></a>角色移动处理</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FVector2D InputAxisVector = InputActionValue.<span class="built_in">Get</span>&lt;FVector2D&gt;();  <span class="comment">// 获取2D输入</span></span><br><span class="line"><span class="function">FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0.f</span>, Rotation.Yaw, <span class="number">0.f</span>)</span></span>;     <span class="comment">// 仅保留偏航角</span></span><br><span class="line"><span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X); <span class="comment">// 获取前向向量</span></span><br><span class="line"><span class="built_in">AddMovementInput</span>(ForwardDirection, InputAxisVector.Y); <span class="comment">// 应用移动输入</span></span><br></pre></td></tr></table></figure></div>

<h4 id="角色运动组件配置"><a href="#角色运动组件配置" class="headerlink" title="角色运动组件配置"></a>角色运动组件配置</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bOrientRotationToMovement = <span class="literal">true</span>;  <span class="comment">// 朝向移动方向</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;RotationRate = <span class="built_in">FRotator</span>(<span class="number">0.f</span>, <span class="number">400.f</span>, <span class="number">0.f</span>); <span class="comment">// 旋转速度</span></span><br><span class="line"><span class="built_in">GetCharacterMovement</span>()-&gt;bConstrainToPlane = <span class="literal">true</span>;          <span class="comment">// 平面约束</span></span><br><span class="line">bUseControllerRotationYaw = <span class="literal">false</span>;                         <span class="comment">// 禁用控制器旋转影响</span></span><br></pre></td></tr></table></figure></div>

<h4 id="接口系统"><a href="#接口系统" class="headerlink" title="接口系统"></a>接口系统</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UINTERFACE</span>(MinimalAPI)                      <span class="comment">// 声明反射接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UEnemyInterface</span> : <span class="keyword">public</span> UInterface   <span class="comment">// 反射接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IEnemyInterface</span>                        <span class="comment">// 功能接口类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span> </span>= <span class="number">0</span>;          <span class="comment">// 纯虚函数声明（必须实现）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="光标追踪与接口调用"><a href="#光标追踪与接口调用" class="headerlink" title="光标追踪与接口调用"></a>光标追踪与接口调用</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetHitResultUnderCursor</span>(ECC_Visibility, <span class="literal">false</span>, CursorHit);  <span class="comment">// 光标射线检测</span></span><br><span class="line"><span class="built_in">Cast</span>&lt;IEnemyInterface&gt;(CursorHit.<span class="built_in">GetActor</span>());               <span class="comment">// 接口类型转换</span></span><br><span class="line">LastActor-&gt;<span class="built_in">UnHighlightActor</span>();                              <span class="comment">// 调用接口方法</span></span><br><span class="line">ThisActor-&gt;<span class="built_in">HighlightActor</span>();                                <span class="comment">// 调用接口方法</span></span><br></pre></td></tr></table></figure></div>

<h4 id="自定义深度渲染"><a href="#自定义深度渲染" class="headerlink" title="自定义深度渲染"></a>自定义深度渲染</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);                    <span class="comment">// 启用自定义深度渲染</span></span><br><span class="line"><span class="built_in">SetCustomDepthStencilValue</span>(CUSTOM_DEPTH_RED);  <span class="comment">// 设置模板值（高亮颜色）</span></span><br><span class="line"><span class="built_in">SetCollisionResponseToChannel</span>(ECC_Visibility, ECR_Block);  <span class="comment">// 可见性碰撞响应</span></span><br><span class="line"><span class="built_in">SetCollisionResponseToChannel</span>(ECC_Camera, ECR_Ignore);     <span class="comment">// 相机碰撞忽略</span></span><br></pre></td></tr></table></figure></div>

<h4 id="状态管理逻辑"><a href="#状态管理逻辑" class="headerlink" title="状态管理逻辑"></a>状态管理逻辑</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (LastActor != <span class="literal">nullptr</span> &amp;&amp; LastActor != ThisActor)   <span class="comment">// 需要取消高亮的情况</span></span><br><span class="line"><span class="keyword">if</span> (ThisActor != <span class="literal">nullptr</span> &amp;&amp; ThisActor != LastActor)   <span class="comment">// 需要高亮的情况</span></span><br></pre></td></tr></table></figure></div>

<h2 id="2-Intro-to-the-Gameplay-Ability-System-游戏技能系统介绍"><a href="#2-Intro-to-the-Gameplay-Ability-System-游戏技能系统介绍" class="headerlink" title="2.Intro to the Gameplay Ability System &#x2F; 游戏技能系统介绍"></a>2.Intro to the Gameplay Ability System &#x2F; 游戏技能系统介绍</h2><ul>
<li><p>8个讲座·1小时 23 分钟 &#x2F; 8 Lectures · 1 Hour 23 Minutes</p>
</li>
<li><p>The Gameplay Ability System</p>
<p>12:14</p>
</li>
<li><p>The Main Parts of GAS</p>
<p>08:46</p>
</li>
<li><p>The Player State</p>
<p>04:28</p>
</li>
</ul>
<h3 id="🎮-AuraPlayerState-玩家状态类"><a href="#🎮-AuraPlayerState-玩家状态类" class="headerlink" title="🎮 AuraPlayerState 玩家状态类"></a>🎮 AuraPlayerState 玩家状态类</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a><strong>类定义</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> AAuraPlayerState : <span class="keyword">public</span> APlayerState</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>继承自</strong> <code>APlayerState</code>：UE内置玩家状态基类</li>
<li><strong>功能</strong>：存储玩家游戏数据（经验值、等级、属性点等）</li>
</ul>
<h4 id="构造函数配置"><a href="#构造函数配置" class="headerlink" title="构造函数配置"></a><strong>构造函数配置</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AAuraPlayerState::<span class="built_in">AAuraPlayerState</span>()</span><br><span class="line">&#123;</span><br><span class="line">    NetUpdateFrequency = <span class="number">100.f</span>;  <span class="comment">// 设置网络更新频率为100Hz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="关键参数解析"><a href="#关键参数解析" class="headerlink" title="关键参数解析"></a><strong>关键参数解析</strong></h4><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>默认值</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>NetUpdateFrequency</code></td>
<td><code>float</code></td>
<td><code>2.0f</code></td>
<td>网络更新频率（单位：Hz）</td>
</tr>
<tr>
<td><code>MinNetUpdateFrequency</code></td>
<td><code>float</code></td>
<td><code>2.0f</code></td>
<td>最小更新频率</td>
</tr>
<tr>
<td><code>bReplicateRelevancyInfo</code></td>
<td><code>bool</code></td>
<td><code>true</code></td>
<td>是否复制相关性信息</td>
</tr>
</tbody></table>
<h4 id="NetUpdateFrequency-详解"><a href="#NetUpdateFrequency-详解" class="headerlink" title="NetUpdateFrequency 详解"></a><strong>NetUpdateFrequency 详解</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同场景的设置建议</span></span><br><span class="line">NetUpdateFrequency = <span class="number">100.f</span>;  <span class="comment">// 高频：MOBA、射击游戏</span></span><br><span class="line">NetUpdateFrequency = <span class="number">30.f</span>;   <span class="comment">// 中频：RPG、动作游戏</span></span><br><span class="line">NetUpdateFrequency = <span class="number">2.f</span>;    <span class="comment">// 低频：棋牌、策略游戏（默认值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际更新间隔 = 1 / NetUpdateFrequency</span></span><br><span class="line"><span class="comment">// 100Hz → 每0.01秒更新一次</span></span><br><span class="line"><span class="comment">// 30Hz  → 每0.033秒更新一次</span></span><br><span class="line"><span class="comment">// 2Hz   → 每0.5秒更新一次</span></span><br></pre></td></tr></table></figure></div>

<h4 id="网络同步流程"><a href="#网络同步流程" class="headerlink" title="网络同步流程"></a><strong>网络同步流程</strong></h4>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器端 PlayerState</span><br><span class="line">    ↓ 网络复制（100Hz）</span><br><span class="line">客户端 PlayerState</span><br><span class="line">    ↓</span><br><span class="line">更新玩家UI、属性显示等</span><br></pre></td></tr></table></figure></div>

<h4 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a><strong>典型应用场景</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储玩家数据</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">int32 PlayerLevel;          <span class="comment">// 玩家等级</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">float</span> ExperiencePoints;     <span class="comment">// 经验值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">int32 AttributePoints;      <span class="comment">// 属性点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续可扩展</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">FString PlayerName;         <span class="comment">// 玩家名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">int32 Gold;                 <span class="comment">// 金币数量</span></span><br></pre></td></tr></table></figure></div>

<h4 id="设计考虑"><a href="#设计考虑" class="headerlink" title="设计考虑"></a><strong>设计考虑</strong></h4><pre><code>1. **高频更新**：确保属性变化即时同步
2. **带宽控制**：100Hz比默认2Hz消耗更多带宽
3. **游戏类型适配**：根据需求调整频率
4. **GAS集成**：为后续Gameplay Ability System做准备
</code></pre>
<p>  <strong>核心作用</strong>：作为玩家数据的网络同步载体，为RPG系统提供基础支持。</p>
<p>- </p>
<p>  Ability System Component and Attribute Set</p>
<p>  05:08</p>
<p>- </p>
<p>  GAS in Multiplayer</p>
<p>  10:29</p>
<p>- </p>
<p>  Constructing the ASC and AS</p>
<p>  12:13</p>
<h3 id="🏗️-GAS-架构设计：分离式组件挂载"><a href="#🏗️-GAS-架构设计：分离式组件挂载" class="headerlink" title="🏗️ GAS 架构设计：分离式组件挂载"></a>🏗️ <strong>GAS 架构设计：分离式组件挂载</strong></h3><h4 id="核心架构对比"><a href="#核心架构对比" class="headerlink" title="核心架构对比"></a><strong>核心架构对比</strong></h4><table>
<thead>
<tr>
<th>组件</th>
<th>玩家角色</th>
<th>敌人角色</th>
<th>设计原因</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ASC</strong></td>
<td>挂载在 <code>PlayerState</code></td>
<td>挂载在 <code>EnemyBase</code></td>
<td>玩家数据需要跨关卡保存</td>
</tr>
<tr>
<td><strong>AS</strong></td>
<td>挂载在 <code>PlayerState</code></td>
<td>挂载在 <code>EnemyBase</code></td>
<td>属性与角色生命期绑定</td>
</tr>
<tr>
<td><strong>网络复制</strong></td>
<td><code>PlayerState</code> 复制</td>
<td><code>Enemy</code> 自身复制</td>
<td>玩家状态持久化需求</td>
</tr>
</tbody></table>
<h4 id="1-抽象基类设计"><a href="#1-抽象基类设计" class="headerlink" title="1. 抽象基类设计"></a><strong>1. 抽象基类设计</strong></h4><h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a><strong>接口实现</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件：AuraCharacterBase.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AAuraCharacterBase</span> : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">UAttributeSet* <span class="title">GetAttributeSet</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> AttributeSet; &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    TObjectPtr&lt;UAbilitySystemComponent&gt; AbilitySystemComponent;  <span class="comment">// ASC指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    TObjectPtr&lt;UAttributeSet&gt; AttributeSet;  <span class="comment">// 属性集指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="接口方法实现"><a href="#接口方法实现" class="headerlink" title="接口方法实现"></a><strong>接口方法实现</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源文件：AuraCharacterBase.cpp</span></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">AAuraCharacterBase::GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AbilitySystemComponent;  <span class="comment">// 返回ASC指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-玩家实现：PlayerState-挂载"><a href="#2-玩家实现：PlayerState-挂载" class="headerlink" title="2. 玩家实现：PlayerState 挂载"></a><strong>2. 玩家实现：PlayerState 挂载</strong></h4><h5 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a><strong>构造函数初始化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuraPlayerState.cpp</span></span><br><span class="line">AAuraPlayerState::<span class="built_in">AAuraPlayerState</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建ASC组件</span></span><br><span class="line">    AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UAuraAbilitySystemComponent&gt;(<span class="string">&quot;AbilitySystemComponent&quot;</span>);</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);  <span class="comment">// 启用网络复制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建属性集</span></span><br><span class="line">    AttributeSet = <span class="built_in">CreateDefaultSubobject</span>&lt;UAuraAttributeSet&gt;(<span class="string">&quot;Attributeset&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    NetUpdateFrequency = <span class="number">100.f</span>;  <span class="comment">// 高频网络更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="玩家角色获取ASC"><a href="#玩家角色获取ASC" class="headerlink" title="玩家角色获取ASC"></a><strong>玩家角色获取ASC</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 玩家角色需要通过PlayerState获取ASC</span></span><br><span class="line">AAuraPlayerState* PlayerState = <span class="built_in">GetPlayerState</span>&lt;AAuraPlayerState&gt;();</span><br><span class="line"><span class="keyword">if</span> (PlayerState)</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = PlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>();</span><br><span class="line">    UAttributeSet* AS = PlayerState-&gt;<span class="built_in">GetAttributeSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-敌人实现：Enemy-自身挂载"><a href="#3-敌人实现：Enemy-自身挂载" class="headerlink" title="3. 敌人实现：Enemy 自身挂载"></a><strong>3. 敌人实现：Enemy 自身挂载</strong></h4><h5 id="构造函数初始化-1"><a href="#构造函数初始化-1" class="headerlink" title="构造函数初始化"></a><strong>构造函数初始化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuraEnemy.cpp</span></span><br><span class="line">AAuraEnemy::<span class="built_in">AAuraEnemy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 碰撞设置（保持不变）</span></span><br><span class="line">    <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_Visibility, ECR_Block);</span><br><span class="line">    <span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_Camera, ECR_Ignore);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建ASC组件（直接挂载到敌人）</span></span><br><span class="line">    AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UAuraAbilitySystemComponent&gt;(<span class="string">&quot;AbilitySystemComponent&quot;</span>);</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);  <span class="comment">// 启用网络复制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建属性集</span></span><br><span class="line">    AttributeSet = <span class="built_in">CreateDefaultSubobject</span>&lt;UAuraAttributeSet&gt;(<span class="string">&quot;Attributeset&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="敌人角色获取ASC"><a href="#敌人角色获取ASC" class="headerlink" title="敌人角色获取ASC"></a><strong>敌人角色获取ASC</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 敌人可以直接从自身获取ASC</span></span><br><span class="line">UAbilitySystemComponent* ASC = <span class="built_in">GetAbilitySystemComponent</span>();  <span class="comment">// 继承自基类</span></span><br><span class="line">UAttributeSet* AS = <span class="built_in">GetAttributeSet</span>();                       <span class="comment">// 基类方法</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-设计哲学分析"><a href="#4-设计哲学分析" class="headerlink" title="4. 设计哲学分析"></a><strong>4. 设计哲学分析</strong></h4><h5 id="玩家数据持久化"><a href="#玩家数据持久化" class="headerlink" title="玩家数据持久化"></a><strong>玩家数据持久化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlayerState的生命周期</span></span><br><span class="line">进入游戏 → 创建PlayerState → 存储ASC/AS数据</span><br><span class="line">死亡重生 → PlayerState保留 → 数据不丢失</span><br><span class="line">退出关卡 → PlayerState销毁 → 需要保存到存档</span><br></pre></td></tr></table></figure></div>

<h5 id="敌人临时性"><a href="#敌人临时性" class="headerlink" title="敌人临时性"></a><strong>敌人临时性</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enemy的生命周期</span></span><br><span class="line">关卡开始 → 生成敌人 → 创建ASC/AS</span><br><span class="line">玩家击杀 → 敌人销毁 → ASC/AS同时销毁</span><br><span class="line">关卡结束 → 所有敌人销毁 → 无需保存</span><br></pre></td></tr></table></figure></div>

<h4 id="5-网络复制策略"><a href="#5-网络复制策略" class="headerlink" title="5. 网络复制策略"></a><strong>5. 网络复制策略</strong></h4><h5 id="玩家复制模式"><a href="#玩家复制模式" class="headerlink" title="玩家复制模式"></a><strong>玩家复制模式</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlayerState中设置</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 通常使用：Mixed（混合）或 Full（完全）复制</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Mixed);</span><br></pre></td></tr></table></figure></div>

<h5 id="敌人复制模式"><a href="#敌人复制模式" class="headerlink" title="敌人复制模式"></a><strong>敌人复制模式</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enemy中设置（相同）</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 通常使用：Minimal（最小）复制节省带宽</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Minimal);</span><br></pre></td></tr></table></figure></div>

<h4 id="6-访问模式对比"><a href="#6-访问模式对比" class="headerlink" title="6. 访问模式对比"></a><strong>6. 访问模式对比</strong></h4><table>
<thead>
<tr>
<th>操作</th>
<th>玩家代码</th>
<th>敌人代码</th>
</tr>
</thead>
<tbody><tr>
<td><strong>获取ASC</strong></td>
<td><code>GetPlayerState()-&gt;GetAbilitySystemComponent()</code></td>
<td><code>GetAbilitySystemComponent()</code></td>
</tr>
<tr>
<td><strong>获取AS</strong></td>
<td><code>GetPlayerState()-&gt;GetAttributeSet()</code></td>
<td><code>GetAttributeSet()</code></td>
</tr>
<tr>
<td><strong>应用效果</strong></td>
<td>通过PlayerState的ASC</td>
<td>直接通过自身ASC</td>
</tr>
<tr>
<td><strong>监听属性</strong></td>
<td>监听PlayerState的AS</td>
<td>监听自身AS</td>
</tr>
</tbody></table>
<h4 id="7-优势和考量"><a href="#7-优势和考量" class="headerlink" title="7. 优势和考量"></a><strong>7. 优势和考量</strong></h4><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h5><pre><code>1. **数据分离**：玩家进度与角色实体解耦
2. **持久化**：玩家死亡/重生不丢失属性
3. **网络优化**：PlayerState可独立复制频率
4. **存档友好**：PlayerState数据易于序列化
</code></pre>
<h5 id="考量"><a href="#考量" class="headerlink" title="考量"></a><strong>考量</strong></h5><pre><code>1. **访问路径**：玩家需通过PlayerState访问，增加间接性
2. **初始化时机**：需确保PlayerState在角色之前创建
3. **引用管理**：注意PlayerState与角色的生命周期差异
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>  这种<strong>分离式架构</strong>是多人RPG游戏的<strong>最佳实践</strong>：</p>
<ul>
<li><strong>玩家</strong>：<code>PlayerState</code>作为数据容器，支持进度保存</li>
<li><strong>敌人</strong>：<code>Enemy</code>自身承载数据，简化生命周期管理</li>
</ul>
<p>  为后续的<strong>属性系统</strong>、<strong>技能系统</strong>和<strong>伤害计算</strong>奠定了坚实的架构基础。</p>
<p>- </p>
<p>  Replication Mode</p>
<p>  07:44</p>
<h3 id="🌐-GAS-网络复制模式配置"><a href="#🌐-GAS-网络复制模式配置" class="headerlink" title="🌐 GAS 网络复制模式配置"></a>🌐 <strong>GAS 网络复制模式配置</strong></h3><h4 id="1-玩家状态：Mixed-复制模式"><a href="#1-玩家状态：Mixed-复制模式" class="headerlink" title="1. 玩家状态：Mixed 复制模式"></a><strong>1. 玩家状态：Mixed 复制模式</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlayerState 构造函数新增</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Mixed);</span><br></pre></td></tr></table></figure></div>

<h5 id="Mixed-模式特点"><a href="#Mixed-模式特点" class="headerlink" title="Mixed 模式特点"></a><strong>Mixed 模式特点</strong></h5><ul>
<li><strong>本地玩家</strong>：接收完整的GameplayEffect数据</li>
<li><strong>其他玩家</strong>：只接收最小必要数据</li>
<li><strong>适用场景</strong>：玩家自己的角色（需要完整数据），AI控制的角色用Minimal</li>
</ul>
<h4 id="2-敌人：Minimal-复制模式"><a href="#2-敌人：Minimal-复制模式" class="headerlink" title="2. 敌人：Minimal 复制模式"></a><strong>2. 敌人：Minimal 复制模式</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enemy 构造函数新增  </span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Minimal);</span><br></pre></td></tr></table></figure></div>

<h5 id="Minimal-模式特点"><a href="#Minimal-模式特点" class="headerlink" title="Minimal 模式特点"></a><strong>Minimal 模式特点</strong></h5><ul>
<li><strong>只复制</strong>：GameplayTags和持续时间</li>
<li><strong>不复制</strong>：具体的属性修改值</li>
<li><strong>适用场景</strong>：AI敌人、小兵（带宽优化）</li>
</ul>
<h4 id="3-复制模式对比表"><a href="#3-复制模式对比表" class="headerlink" title="**3. 复制模式对比表"></a>**3. 复制模式对比表</h4><table>
<thead>
<tr>
<th>复制模式</th>
<th>使用场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Full（完整）</td>
<td>单人游戏</td>
<td>Gameplay Effects 复制到所有客户端</td>
</tr>
<tr>
<td>Mixed（混合）</td>
<td>多人游戏，玩家控制</td>
<td>Gameplay Effects 仅复制到所属客户端。Gameplay Cues 和 Gameplay Tags 复制到所有客户端。</td>
</tr>
<tr>
<td>Minimal（最小）</td>
<td>多人游戏，AI控制</td>
<td>Gameplay Effects 不进行复制。Gameplay Cues 和 Gameplay Tags 复制到所有客户端。</td>
</tr>
</tbody></table>
<h4 id="设计考虑-1"><a href="#设计考虑-1" class="headerlink" title="设计考虑"></a><strong>设计考虑</strong></h4><pre><code>1. **网络优化**：根据角色重要性选择复制模式
2. **带宽控制**：敌人用Minimal节省服务器资源  
3. **玩家体验**：本地玩家需要完整数据计算伤害等
4. **一致性**：保持接口实现的一致性
</code></pre>
<p>- </p>
<p>  Init Ability Actor Info</p>
<p>  22:01</p>
<h3 id="🎮-GAS-初始化系统"><a href="#🎮-GAS-初始化系统" class="headerlink" title="🎮 GAS 初始化系统"></a>🎮 <strong>GAS 初始化系统</strong></h3><h4 id="1-敌人角色初始化"><a href="#1-敌人角色初始化" class="headerlink" title="1. 敌人角色初始化"></a><strong>1. 敌人角色初始化</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuraEnemy.cpp - BeginPlay()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEnemy::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="InitAbilityActorInfo-参数"><a href="#InitAbilityActorInfo-参数" class="headerlink" title="InitAbilityActorInfo 参数"></a><strong>InitAbilityActorInfo 参数</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitAbilityActorInfo</span>(</span><br><span class="line">    <span class="keyword">this</span>,  <span class="comment">// 第1参数：OwnerActor（拥有者）</span></span><br><span class="line">    <span class="keyword">this</span>   <span class="comment">// 第2参数：AvatarActor（化身）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>拥有者</strong>：逻辑上的所有者（敌人自身）</li>
<li><strong>化身</strong>：实际执行动作的实体（敌人自身）</li>
<li><strong>敌人场景</strong>：Owner和Avatar都是敌人自己</li>
</ul>
<h4 id="2-玩家角色初始化"><a href="#2-玩家角色初始化" class="headerlink" title="2. 玩家角色初始化"></a><strong>2. 玩家角色初始化</strong></h4><h5 id="服务器端初始化"><a href="#服务器端初始化" class="headerlink" title="服务器端初始化"></a><strong>服务器端初始化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuraCharacter.cpp - PossessedBy()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line">    <span class="built_in">InitAbilityActorInfo</span>();  <span class="comment">// 服务器初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>触发时机</strong>：服务器获得角色控制权时</li>
<li><strong>典型场景</strong>：玩家加入游戏、重生时</li>
</ul>
<h5 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a><strong>客户端初始化</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuraCharacter.cpp - OnRep_PlayerState()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraCharacter::OnRep_PlayerState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">OnRep_PlayerState</span>();</span><br><span class="line">    <span class="built_in">InitAbilityActorInfo</span>();  <span class="comment">// 客户端初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>触发时机</strong>：客户端PlayerState同步完成时</li>
<li><strong>网络复制</strong>：通过<code>OnRep_PlayerState</code>响应复制事件</li>
</ul>
<h4 id="3-玩家ASC初始化实现"><a href="#3-玩家ASC初始化实现" class="headerlink" title="3. 玩家ASC初始化实现"></a><strong>3. 玩家ASC初始化实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuraCharacter.cpp - InitAbilityActorInfo()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraCharacter::InitAbilityActorInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取PlayerState</span></span><br><span class="line">    AAuraPlayerState* AuraPlayerState = <span class="built_in">GetPlayerState</span>&lt;AAuraPlayerState&gt;();</span><br><span class="line">    <span class="built_in">check</span>(AuraPlayerState);  <span class="comment">// 断言验证</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化ASC</span></span><br><span class="line">    AuraPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(</span><br><span class="line">        AuraPlayerState,  <span class="comment">// Owner：PlayerState</span></span><br><span class="line">        <span class="keyword">this</span>              <span class="comment">// Avatar：角色实体</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存引用</span></span><br><span class="line">    AbilitySystemComponent = AuraPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>();</span><br><span class="line">    AttributeSet = AuraPlayerState-&gt;<span class="built_in">GetAttributeSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="玩家参数对比"><a href="#玩家参数对比" class="headerlink" title="玩家参数对比"></a><strong>玩家参数对比</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitAbilityActorInfo</span>(</span><br><span class="line">    AuraPlayerState,  <span class="comment">// Owner：PlayerState（数据持久化）</span></span><br><span class="line">    <span class="keyword">this</span>              <span class="comment">// Avatar：角色实体（执行动作）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="4-初始化时机对比表"><a href="#4-初始化时机对比表" class="headerlink" title="4. 初始化时机对比表"></a><strong>4. 初始化时机对比表</strong></h4><table>
<thead>
<tr>
<th>角色类型</th>
<th>服务器初始化</th>
<th>客户端初始化</th>
<th>Owner</th>
<th>Avatar</th>
</tr>
</thead>
<tbody><tr>
<td><strong>玩家</strong></td>
<td><code>PossessedBy()</code></td>
<td><code>OnRep_PlayerState()</code></td>
<td>PlayerState</td>
<td>角色</td>
</tr>
<tr>
<td><strong>敌人</strong></td>
<td><code>BeginPlay()</code></td>
<td><code>BeginPlay()</code></td>
<td>敌人自身</td>
<td>敌人自身</td>
</tr>
</tbody></table>
<h4 id="5-关键函数作用"><a href="#5-关键函数作用" class="headerlink" title="5. 关键函数作用"></a><strong>5. 关键函数作用</strong></h4><h5 id="InitAbilityActorInfo"><a href="#InitAbilityActorInfo" class="headerlink" title="InitAbilityActorInfo()"></a><strong>InitAbilityActorInfo()</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GAS核心初始化函数</span></span><br><span class="line">ASC-&gt;<span class="built_in">InitAbilityActorInfo</span>(OwnerActor, AvatarActor);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>绑定关系</strong>：建立Owner、Avatar与ASC的关联</li>
<li><strong>激活系统</strong>：使GAS开始工作</li>
<li><strong>必需调用</strong>：未调用则技能系统无法使用</li>
</ul>
<h5 id="check-宏"><a href="#check-宏" class="headerlink" title="check() 宏"></a><strong>check() 宏</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">check</span>(AuraPlayerState);  <span class="comment">// 开发时验证，失败则崩溃</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>调试辅助</strong>：确保关键对象存在</li>
<li><strong>发布版本</strong>：自动移除，不影响性能</li>
</ul>
<h4 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a><strong>设计模式总结</strong></h4><ul>
<li><strong>玩家</strong>：分离式初始化（Owner&#x3D;PlayerState, Avatar&#x3D;角色）</li>
<li><strong>敌人</strong>：一体化初始化（Owner&#x3D;Avatar&#x3D;敌人自身）</li>
<li><strong>网络同步</strong>：确保两端都正确初始化</li>
<li><strong>生命周期</strong>：在合适的时机触发初始化</li>
</ul>
<h3 id="📚-第二章关键方法总结"><a href="#📚-第二章关键方法总结" class="headerlink" title="📚 第二章关键方法总结"></a>📚 第二章关键方法总结</h3><h4 id="GAS核心组件定义"><a href="#GAS核心组件定义" class="headerlink" title="GAS核心组件定义"></a>GAS核心组件定义</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> AAuraPlayerState : <span class="keyword">public</span> APlayerState  <span class="comment">// 玩家状态类</span></span><br></pre></td></tr></table></figure></div>

<h4 id="网络更新频率设置"><a href="#网络更新频率设置" class="headerlink" title="网络更新频率设置"></a>网络更新频率设置</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">NetUpdateFrequency = <span class="number">100.f</span>;  <span class="comment">// 设置网络更新频率为100Hz（默认2Hz）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="GAS接口实现"><a href="#GAS接口实现" class="headerlink" title="GAS接口实现"></a>GAS接口实现</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AAuraCharacterBase</span> : <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface  <span class="comment">// 继承GAS接口</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;  <span class="comment">// 实现接口方法</span></span><br></pre></td></tr></table></figure></div>

<h4 id="ASC（能力系统组件）创建"><a href="#ASC（能力系统组件）创建" class="headerlink" title="ASC（能力系统组件）创建"></a>ASC（能力系统组件）创建</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UAuraAbilitySystemComponent&gt;(<span class="string">&quot;AbilitySystemComponent&quot;</span>);</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetIsReplicated</span>(<span class="literal">true</span>);  <span class="comment">// 启用网络复制</span></span><br></pre></td></tr></table></figure></div>

<h4 id="AS（属性集）创建"><a href="#AS（属性集）创建" class="headerlink" title="AS（属性集）创建"></a>AS（属性集）创建</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AttributeSet = <span class="built_in">CreateDefaultSubobject</span>&lt;UAuraAttributeSet&gt;(<span class="string">&quot;AttributeSet&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="GAS复制模式设置"><a href="#GAS复制模式设置" class="headerlink" title="GAS复制模式设置"></a>GAS复制模式设置</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Mixed);     <span class="comment">// 玩家：混合模式</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">SetReplicationMode</span>(EGameplayEffectReplicationMode::Minimal);   <span class="comment">// 敌人：最小模式</span></span><br></pre></td></tr></table></figure></div>

<h4 id="GAS初始化系统调用"><a href="#GAS初始化系统调用" class="headerlink" title="GAS初始化系统调用"></a>GAS初始化系统调用</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">ASC-&gt;<span class="built_in">InitAbilityActorInfo</span>(OwnerActor, AvatarActor);  <span class="comment">// 核心初始化函数</span></span><br></pre></td></tr></table></figure></div>

<h4 id="玩家初始化时机函数"><a href="#玩家初始化时机函数" class="headerlink" title="玩家初始化时机函数"></a>玩家初始化时机函数</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;  <span class="comment">// 服务器端初始化</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRep_PlayerState</span><span class="params">()</span> <span class="keyword">override</span></span>;                      <span class="comment">// 客户端初始化</span></span><br></pre></td></tr></table></figure></div>

<h4 id="断言验证宏"><a href="#断言验证宏" class="headerlink" title="断言验证宏"></a>断言验证宏</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">check</span>(AuraPlayerState);  <span class="comment">// 开发时验证对象有效性</span></span><br></pre></td></tr></table></figure></div>

<h4 id="复制模式枚举值"><a href="#复制模式枚举值" class="headerlink" title="复制模式枚举值"></a>复制模式枚举值</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">EGameplayEffectReplicationMode::Full      <span class="comment">// 完整复制（单人游戏）</span></span><br><span class="line">EGameplayEffectReplicationMode::Mixed     <span class="comment">// 混合复制（玩家控制）</span></span><br><span class="line">EGameplayEffectReplicationMode::Minimal   <span class="comment">// 最小复制（AI控制）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="玩家状态获取"><a href="#玩家状态获取" class="headerlink" title="玩家状态获取"></a>玩家状态获取</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AAuraPlayerState* AuraPlayerState = <span class="built_in">GetPlayerState</span>&lt;AAuraPlayerState&gt;();  <span class="comment">// 获取玩家状态</span></span><br></pre></td></tr></table></figure></div>

<h4 id="组件引用保存"><a href="#组件引用保存" class="headerlink" title="组件引用保存"></a>组件引用保存</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent = AuraPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>();  <span class="comment">// 保存ASC引用</span></span><br><span class="line">AttributeSet = AuraPlayerState-&gt;<span class="built_in">GetAttributeSet</span>();                      <span class="comment">// 保存AS引用</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-Attributes-属性"><a href="#3-Attributes-属性" class="headerlink" title="3.Attributes &#x2F; 属性"></a>3.Attributes &#x2F; 属性</h2><ul>
<li><p>4个讲座·1小时1分钟 &#x2F; 4 Lectures · 1 Hour 1 Minute</p>
</li>
<li><p>Attributes</p>
<p>06:59</p>
</li>
</ul>
<blockquote>
<p>Attributes are  numerical quantities associated with a given entity in the game, all attributes are floats, they exist within a structure called FGameplayAttributeData.</p>
<p>属性是与游戏中特定实体相关联的数值量，所有属性均为浮点数，它们存在于名为FGameplayAttributeData的结构中。</p>
</blockquote>
<p>- </p>
<p>  Health and Mana</p>
<p>  17:44</p>
<h3 id="🏥-AuraAttributeSet-属性集实现"><a href="#🏥-AuraAttributeSet-属性集实现" class="headerlink" title="🏥 AuraAttributeSet 属性集实现"></a>🏥 <strong>AuraAttributeSet 属性集实现</strong></h3><h4 id="1-类定义和属性声明"><a href="#1-类定义和属性声明" class="headerlink" title="1. 类定义和属性声明"></a><strong>1. 类定义和属性声明</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> UAuraAttributeSet : <span class="keyword">public</span> UAttributeSet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UAuraAttributeSet</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps</span></span><br><span class="line">	<span class="comment">// 参数：输出参数，存放所有需要复制的属性信息</span></span><br><span class="line">	<span class="comment">// 类型：TArray（动态数组），存储FLifetimeProperty结构</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心属性声明</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = <span class="string">&quot;Vital Attributes&quot;</span>)</span><br><span class="line">    FGameplayAttributeData Health;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="代码功能"><a href="#代码功能" class="headerlink" title="代码功能"></a><strong>代码功能</strong></h5><pre><code>1. **继承UAttributeSet**：GAS属性系统的基类
2. **网络复制配置函数**GetLifetimeReplicatedProps：告诉UE哪些属性需要网络复制
3. **声明Health属性**：使用`FGameplayAttributeData`类型存储生命值
4. **声明OnRep_Health函数**：属性复制完成时的回调函数
</code></pre>
<h4 id="2-构造函数实现"><a href="#2-构造函数实现" class="headerlink" title="2. 构造函数实现"></a><strong>2. 构造函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">UAuraAttributeSet::<span class="built_in">UAuraAttributeSet</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空的构造函数，属性初始化使用默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-网络复制配置"><a href="#3-网络复制配置" class="headerlink" title="3. 网络复制配置"></a><strong>3. 网络复制配置</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraAttributeSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 首先调用父类方法</span></span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 注册Health属性进行网络复制</span></span><br><span class="line">    <span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UAuraAttributeSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="DOREPLIFETIME-CONDITION-NOTIFY宏解析"><a href="#DOREPLIFETIME-CONDITION-NOTIFY宏解析" class="headerlink" title="DOREPLIFETIME_CONDITION_NOTIFY宏解析"></a><strong>DOREPLIFETIME_CONDITION_NOTIFY宏解析</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(</span><br><span class="line">    UAuraAttributeSet,   <span class="comment">// 参数1：当前类名</span></span><br><span class="line">    Health,              <span class="comment">// 参数2：要复制的属性名</span></span><br><span class="line">    COND_None,           <span class="comment">// 参数3：复制条件（无条件，总是复制）</span></span><br><span class="line">    REPNOTIFY_Always     <span class="comment">// 参数4：通知策略（总是发送通知）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><ul>
<li>告诉UE：<code>Health</code>属性需要通过网络同步</li>
<li>条件<code>COND_None</code>：任何情况下都复制</li>
<li>通知<code>REPNOTIFY_Always</code>：属性变化时总是通知</li>
</ul>
<h4 id="4-OnRep函数实现"><a href="#4-OnRep函数实现" class="headerlink" title="4. OnRep函数实现"></a><strong>4. OnRep函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraAttributeSet::OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UAuraAttributeSet, Health, OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="GAMEPLAYATTRIBUTE-REPNOTIFY宏功能"><a href="#GAMEPLAYATTRIBUTE-REPNOTIFY宏功能" class="headerlink" title="GAMEPLAYATTRIBUTE_REPNOTIFY宏功能"></a><strong>GAMEPLAYATTRIBUTE_REPNOTIFY宏功能</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个宏内部执行三个操作：</span></span><br><span class="line"><span class="comment">// 1. 比较新旧值，触发属性变化事件</span></span><br><span class="line"><span class="comment">// 2. 更新UI显示（如果绑定了UI）</span></span><br><span class="line"><span class="comment">// 3. 确保属性值正确同步</span></span><br></pre></td></tr></table></figure></div>

<h5 id="OnRep-Health参数"><a href="#OnRep-Health参数" class="headerlink" title="OnRep_Health参数"></a><strong>OnRep_Health参数</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FGameplayAttributeData&amp; OldHealth  <span class="comment">// 参数：属性复制前的旧值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="5-完整执行流程"><a href="#5-完整执行流程" class="headerlink" title="5. 完整执行流程"></a><strong>5. 完整执行流程</strong></h4><h5 id="服务器端发生属性变化"><a href="#服务器端发生属性变化" class="headerlink" title="服务器端发生属性变化"></a><strong>服务器端发生属性变化</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器：</span><br><span class="line">1. Health属性值改变（例如：玩家受伤）</span><br><span class="line">2. 自动触发网络复制系统</span><br><span class="line">3. 通过网络发送Health新值给客户端</span><br></pre></td></tr></table></figure></div>

<h5 id="客户端接收属性变化"><a href="#客户端接收属性变化" class="headerlink" title="客户端接收属性变化"></a><strong>客户端接收属性变化</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端：</span><br><span class="line">1. 收到服务器发来的Health新值</span><br><span class="line">2. UE自动调用OnRep_Health(OldHealth)</span><br><span class="line">3. GAMEPLAYATTRIBUTE_REPNOTIFY宏执行</span><br><span class="line">   - 记录旧值</span><br><span class="line">   - 更新新值</span><br><span class="line">   - 触发属性变化事件</span><br><span class="line">4. UI系统收到事件，更新生命条显示</span><br></pre></td></tr></table></figure></div>

<h4 id="6-代码结构总结"><a href="#6-代码结构总结" class="headerlink" title="6. 代码结构总结"></a><strong>6. 代码结构总结</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个属性需要三部分：</span></span><br><span class="line"><span class="number">1.</span> 声明属性：<span class="built_in">UPROPERTY</span>(...) FGameplayAttributeData 属性名;</span><br><span class="line"><span class="number">2.</span> 复制注册：<span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(类名, 属性名, 条件, 通知策略);</span><br><span class="line"><span class="number">3.</span> OnRep函数：<span class="type">void</span> OnRep_属性名(<span class="type">const</span> FGameplayAttributeData&amp; Old值) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应关系：</span></span><br><span class="line">Health属性  ←→  OnRep_Health函数  ←→  DOREPLIFETIME_CONDITION_NOTIFY注册</span><br></pre></td></tr></table></figure></div>

<h4 id="7-核心机制"><a href="#7-核心机制" class="headerlink" title="7. 核心机制"></a><strong>7. 核心机制</strong></h4><ul>
<li><p><strong>网络复制</strong>：服务器向客户端同步属性值</p>
</li>
<li><p><strong>回调通知</strong>：属性复制完成后调用指定函数</p>
</li>
<li><p><strong>自动同步</strong>：GAS系统自动处理属性变化和UI更新</p>
</li>
<li><p>Attribute Accessors</p>
<p>12:05</p>
</li>
</ul>
<h3 id="🚀-AuraAttributeSet-属性集升级"><a href="#🚀-AuraAttributeSet-属性集升级" class="headerlink" title="🚀 AuraAttributeSet 属性集升级"></a>🚀 <strong>AuraAttributeSet 属性集升级</strong></h3><h4 id="1-新增：属性访问器宏定义"><a href="#1-新增：属性访问器宏定义" class="headerlink" title="1. 新增：属性访问器宏定义"></a><strong>1. 新增：属性访问器宏定义</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">    GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">    GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">    GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span></span><br></pre></td></tr></table></figure></div>

<h5 id="宏展开后的效果"><a href="#宏展开后的效果" class="headerlink" title="宏展开后的效果"></a><strong>宏展开后的效果</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以Health为例，ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Health) 展开为：</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 属性元数据获取器</span></span><br><span class="line">    <span class="function"><span class="type">static</span> FGameplayAttribute <span class="title">GetHealthAttribute</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 当前值获取器</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetHealth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 当前值设置器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetHealth</span><span class="params">(<span class="type">float</span> NewVal)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 初始值设置器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitHealth</span><span class="params">(<span class="type">float</span> NewVal)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-属性声明新增宏调用"><a href="#2-属性声明新增宏调用" class="headerlink" title="2. 属性声明新增宏调用"></a><strong>2. 属性声明新增宏调用</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = <span class="string">&quot;Vital Attributes&quot;</span>)</span><br><span class="line">FGameplayAttributeData Health;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(UAuraAttributeSet, Health);  <span class="comment">// 新增：为Health生成访问函数</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-构造函数初始化属性值"><a href="#3-构造函数初始化属性值" class="headerlink" title="3. 构造函数初始化属性值"></a><strong>3. 构造函数初始化属性值</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">UAuraAttributeSet::<span class="built_in">UAuraAttributeSet</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用宏生成的Init函数设置初始值</span></span><br><span class="line">    <span class="built_in">InitHealth</span>(<span class="number">100.f</span>);      <span class="comment">// Health初始值 = 100</span></span><br><span class="line">    <span class="built_in">InitMaxHealth</span>(<span class="number">100.f</span>);   <span class="comment">// MaxHealth初始值 = 100</span></span><br><span class="line">    <span class="built_in">InitMana</span>(<span class="number">50.f</span>);         <span class="comment">// Mana初始值 = 50</span></span><br><span class="line">    <span class="built_in">InitMaxMana</span>(<span class="number">50.f</span>);      <span class="comment">// MaxMana初始值 = 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="Init函数来源"><a href="#Init函数来源" class="headerlink" title="Init函数来源"></a><strong>Init函数来源</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自宏：GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span></span><br><span class="line"><span class="comment">// 生成函数：InitHealth(float), InitMaxHealth(float)等</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-生成的访问函数使用示例"><a href="#4-生成的访问函数使用示例" class="headerlink" title="4. 生成的访问函数使用示例"></a><strong>4. 生成的访问函数使用示例</strong></h4><h5 id="获取属性值"><a href="#获取属性值" class="headerlink" title="获取属性值"></a><strong>获取属性值</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过宏生成的Get函数</span></span><br><span class="line"><span class="type">float</span> CurrentHealth = <span class="built_in">GetHealth</span>();        <span class="comment">// 获取当前生命值</span></span><br><span class="line"><span class="type">float</span> CurrentMaxHealth = <span class="built_in">GetMaxHealth</span>();  <span class="comment">// 获取最大生命值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的方法（不方便）</span></span><br><span class="line"><span class="type">float</span> OldWay = Health.<span class="built_in">GetCurrentValue</span>();  <span class="comment">// 需要调用GetCurrentValue()</span></span><br></pre></td></tr></table></figure></div>

<h5 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a><strong>设置属性值</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过宏生成的Set函数</span></span><br><span class="line"><span class="built_in">SetHealth</span>(<span class="number">75.f</span>);    <span class="comment">// 设置生命值为75</span></span><br><span class="line"><span class="built_in">SetMana</span>(<span class="number">30.f</span>);      <span class="comment">// 设置魔法值为30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的方法（复杂）</span></span><br><span class="line">FGameplayAttributeData NewHealth;</span><br><span class="line">NewHealth.<span class="built_in">SetCurrentValue</span>(<span class="number">75.f</span>);</span><br><span class="line">Health = NewHealth;</span><br></pre></td></tr></table></figure></div>

<h4 id="5-宏的功能详解"><a href="#5-宏的功能详解" class="headerlink" title="5. 宏的功能详解"></a><strong>5. 宏的功能详解</strong></h4><table>
<thead>
<tr>
<th>宏组件</th>
<th>生成的函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>GAMEPLAYATTRIBUTE_PROPERTY_GETTER</code></td>
<td><code>GetHealthAttribute()</code></td>
<td>获取属性的元数据（类型、名称等）</td>
</tr>
<tr>
<td><code>GAMEPLAYATTRIBUTE_VALUE_GETTER</code></td>
<td><code>GetHealth()</code></td>
<td>获取属性的当前值（float）</td>
</tr>
<tr>
<td><code>GAMEPLAYATTRIBUTE_VALUE_SETTER</code></td>
<td><code>SetHealth(float)</code></td>
<td>设置属性的当前值</td>
</tr>
<tr>
<td><code>GAMEPLAYATTRIBUTE_VALUE_INITTER</code></td>
<td><code>InitHealth(float)</code></td>
<td>初始化属性的基础值</td>
</tr>
</tbody></table>
<h4 id="6-代码结构对比"><a href="#6-代码结构对比" class="headerlink" title="6. 代码结构对比"></a><strong>6. 代码结构对比</strong></h4><h5 id="升级前（手动管理）"><a href="#升级前（手动管理）" class="headerlink" title="升级前（手动管理）"></a><strong>升级前（手动管理）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="type">float</span> health = Health.<span class="built_in">GetCurrentValue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值（复杂）</span></span><br><span class="line">FGameplayAttributeData newHealth;</span><br><span class="line">newHealth.<span class="built_in">SetCurrentValue</span>(<span class="number">100.f</span>);</span><br><span class="line">Health = newHealth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有统一的初始化方法</span></span><br></pre></td></tr></table></figure></div>

<h5 id="升级后（宏辅助）"><a href="#升级后（宏辅助）" class="headerlink" title="升级后（宏辅助）"></a><strong>升级后（宏辅助）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取值（简洁）</span></span><br><span class="line"><span class="type">float</span> health = <span class="built_in">GetHealth</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值（简单）</span></span><br><span class="line"><span class="built_in">SetHealth</span>(<span class="number">100.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化（统一）</span></span><br><span class="line"><span class="built_in">InitHealth</span>(<span class="number">100.f</span>);  <span class="comment">// 构造函数中调用</span></span><br></pre></td></tr></table></figure></div>

<h4 id="7-关键改进总结"><a href="#7-关键改进总结" class="headerlink" title="7. 关键改进总结"></a><strong>7. 关键改进总结</strong></h4><pre><code>1. **代码简化**：宏自动生成Get/Set/Init函数
2. **类型安全**：统一的访问接口
3. **初始化标准化**：构造函数中统一初始化所有属性
4. **可维护性**：属性声明和访问函数绑定在一起
</code></pre>
<h5 id="使用新宏的优势"><a href="#使用新宏的优势" class="headerlink" title="使用新宏的优势"></a><strong>使用新宏的优势</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前：手动编写每个属性的访问函数</span></span><br><span class="line"><span class="comment">// 之后：一行宏搞定所有功能</span></span><br><span class="line"><span class="comment">// 结果：减少代码量，提高一致性，减少错误</span></span><br></pre></td></tr></table></figure></div>

<p>- </p>
<p>  Effect Actor</p>
<p>  24:20</p>
<h3 id="⚠️-AuraEffectActor-临时效果实现与const-cast问题"><a href="#⚠️-AuraEffectActor-临时效果实现与const-cast问题" class="headerlink" title="⚠️ AuraEffectActor 临时效果实现与const_cast问题"></a><strong>⚠️ AuraEffectActor 临时效果实现与const_cast问题</strong></h3><h4 id="1-Actor基础结构"><a href="#1-Actor基础结构" class="headerlink" title="1. Actor基础结构"></a><strong>1. Actor基础结构</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> AAuraEffectActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 组件</span></span><br><span class="line">    TObjectPtr&lt;UStaticMeshComponent&gt; Mesh;    <span class="comment">// 可视网格</span></span><br><span class="line">    TObjectPtr&lt;USphereComponent&gt; Sphere;      <span class="comment">// 碰撞检测球体</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 碰撞回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnOverlap</span><span class="params">(...)</span></span>;  <span class="comment">// 进入碰撞区域</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">EndOverlap</span><span class="params">(...)</span></span>; <span class="comment">// 离开碰撞区域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-当前的临时解决方案"><a href="#2-当前的临时解决方案" class="headerlink" title="2. 当前的临时解决方案"></a><strong>2. 当前的临时解决方案</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEffectActor::OnOverlap</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查OtherActor是否实现了IAbilitySystemInterface</span></span><br><span class="line">    <span class="keyword">if</span>(IAbilitySystemInterface* ASCInterface = <span class="built_in">Cast</span>&lt;IAbilitySystemInterface&gt;(OtherActor))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. 获取OtherActor的属性集</span></span><br><span class="line">        <span class="type">const</span> UAuraAttributeSet* AuraAttributeSet = </span><br><span class="line">            <span class="built_in">Cast</span>&lt;UAuraAttributeSet&gt;(ASCInterface-&gt;<span class="built_in">GetAbilitySystemComponent</span>()</span><br><span class="line">                -&gt;<span class="built_in">GetAttributeSet</span>(UAuraAttributeSet::<span class="built_in">StaticClass</span>()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. ⚠️ 使用const_cast移除const修饰符（危险操作）</span></span><br><span class="line">        UAuraAttributeSet* MutableAuraAttributeSet = </span><br><span class="line">            <span class="built_in">const_cast</span>&lt;UAuraAttributeSet*&gt;(AuraAttributeSet);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 直接修改生命值</span></span><br><span class="line">        MutableAuraAttributeSet-&gt;<span class="built_in">SetHealth</span>(AuraAttributeSet-&gt;<span class="built_in">GetHealth</span>() + <span class="number">25.f</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 销毁自身</span></span><br><span class="line">        <span class="built_in">Destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-const-cast的问题分析"><a href="#3-const-cast的问题分析" class="headerlink" title="3. const_cast的问题分析"></a><strong>3. const_cast的问题分析</strong></h4><h5 id="什么是const-cast？"><a href="#什么是const-cast？" class="headerlink" title="什么是const_cast？"></a><strong>什么是const_cast？</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const_cast语法：移除或添加const修饰符</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;Type*&gt;(const_pointer);  <span class="comment">// 移除const</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">const</span> Type*&gt;(pointer);  <span class="comment">// 添加const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前代码：</span></span><br><span class="line"><span class="type">const</span> UAuraAttributeSet* AuraAttributeSet = ...;  <span class="comment">// const指针</span></span><br><span class="line">UAuraAttributeSet* MutableAuraAttributeSet =       <span class="comment">// 移除const</span></span><br><span class="line">    <span class="built_in">const_cast</span>&lt;UAuraAttributeSet*&gt;(AuraAttributeSet);</span><br></pre></td></tr></table></figure></div>

<h5 id="const-cast的严重问题"><a href="#const-cast的严重问题" class="headerlink" title="const_cast的严重问题"></a><strong>const_cast的严重问题</strong></h5><p>  <strong>问题1：违反const承诺</strong></p>
  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetAttributeSet返回const指针的承诺：</span></span><br><span class="line"><span class="comment">// &quot;这个对象是只读的，我不会修改它&quot;</span></span><br><span class="line"><span class="function"><span class="type">const</span> UAttributeSet* <span class="title">GetAttributeSet</span><span class="params">(...)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用const_cast打破了这个承诺</span></span><br><span class="line"><span class="comment">// 可能导致：</span></span><br><span class="line"><span class="comment">// 1. 其他代码依赖const保证，现在被破坏</span></span><br><span class="line"><span class="comment">// 2. 多线程环境下的数据竞争</span></span><br></pre></td></tr></table></figure></div>

<p>  <strong>问题2：绕过GAS系统</strong></p>
  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GAS正确的属性修改方式：</span></span><br><span class="line">ASC-&gt;<span class="built_in">ApplyModToAttribute</span>(Attribute, Modifier);  <span class="comment">// 通过ASC系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前错误方式：</span></span><br><span class="line">直接调用 <span class="built_in">SetHealth</span>()  <span class="comment">// 绕过GAS，不会触发：</span></span><br><span class="line"><span class="comment">// - 属性变化事件</span></span><br><span class="line"><span class="comment">// - UI更新</span></span><br><span class="line"><span class="comment">// - 网络复制</span></span><br><span class="line"><span class="comment">// - GameplayEffect的后续处理</span></span><br></pre></td></tr></table></figure></div>

<p>  <strong>问题3：网络同步问题</strong></p>
  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GAS修改属性会：</span></span><br><span class="line"><span class="number">1.</span> 服务器修改 → <span class="number">2.</span> 触发复制 → <span class="number">3.</span> 客户端同步</span><br><span class="line"></span><br><span class="line"><span class="comment">// const_cast直接修改：</span></span><br><span class="line"><span class="number">1.</span> 本地修改 → <span class="number">2.</span> 网络不同步 → <span class="number">3.</span> 其他客户端看不到变化</span><br></pre></td></tr></table></figure></div>

<h4 id="4-总结：为什么const-cast是坏的"><a href="#4-总结：为什么const-cast是坏的" class="headerlink" title="4. 总结：为什么const_cast是坏的"></a><strong>4. 总结：为什么const_cast是坏的</strong></h4><table>
<thead>
<tr>
<th>问题</th>
<th>后果</th>
<th>正确做法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>违反const约定</strong></td>
<td>破坏代码安全性，可能导致崩溃</td>
<td>使用const正确的方法</td>
</tr>
<tr>
<td><strong>绕过GAS系统</strong></td>
<td>不触发事件、UI不更新</td>
<td>通过ASC应用GameplayEffect</td>
</tr>
<tr>
<td><strong>网络不同步</strong></td>
<td>多人游戏不同步</td>
<td>GAS自动处理网络复制</td>
</tr>
<tr>
<td><strong>代码维护困难</strong></td>
<td>难以调试和追踪</td>
<td>使用标准GAS流程</td>
</tr>
</tbody></table>
<p>  <strong>注释中的TODO：</strong></p>
  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 将此更改为应用游戏效果，目前使用 const_cast 作为临时解决方案！</span></span><br><span class="line"><span class="comment">// 翻译：这只是临时方案，后面要用GameplayEffect重写！</span></span><br></pre></td></tr></table></figure></div>

<p>- </p>
<p>  Section 4 Quiz</p>
<p>  3 问题</p>
<h3 id="📚-第三章关键方法总结"><a href="#📚-第三章关键方法总结" class="headerlink" title="📚 第三章关键方法总结"></a>📚 第三章关键方法总结</h3><h4 id="属性集类定义"><a href="#属性集类定义" class="headerlink" title="属性集类定义"></a><strong>属性集类定义</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAuraAttributeSet</span> : <span class="keyword">public</span> UAttributeSet                      <span class="comment">// 继承GAS属性集基类</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a><strong>属性声明</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = <span class="string">&quot;Vital Attributes&quot;</span>)</span><br><span class="line">FGameplayAttributeData Health;                                       <span class="comment">// 核心属性声明</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性访问器宏"><a href="#属性访问器宏" class="headerlink" title="属性访问器宏"></a><strong>属性访问器宏</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName)                 <span class="comment">// 属性访问器宏定义</span></span></span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(UAuraAttributeSet, Health)                       <span class="comment">// 应用宏到属性</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a><strong>属性初始化</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitHealth</span>(<span class="number">100.f</span>)                                                    <span class="comment">// 初始化属性值</span></span><br><span class="line"><span class="built_in">InitMana</span>(<span class="number">50.f</span>)                                                       <span class="comment">// 初始化魔法值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性访问函数"><a href="#属性访问函数" class="headerlink" title="属性访问函数"></a><strong>属性访问函数</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetHealth</span>()                                                          <span class="comment">// 获取当前生命值</span></span><br><span class="line"><span class="built_in">SetHealth</span>(<span class="number">75.f</span>)                                                      <span class="comment">// 设置生命值</span></span><br><span class="line"><span class="built_in">GetHealthAttribute</span>()                                                 <span class="comment">// 获取属性元数据</span></span><br></pre></td></tr></table></figure></div>

<h4 id="网络复制配置"><a href="#网络复制配置" class="headerlink" title="网络复制配置"></a><strong>网络复制配置</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"><span class="title">DOREPLIFETIME_CONDITION_NOTIFY</span><span class="params">(UAuraAttributeSet, Health, COND_None, REPNOTIFY_Always)</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="复制通知函数"><a href="#复制通知函数" class="headerlink" title="复制通知函数"></a><strong>复制通知函数</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span>     <span class="comment">// 属性复制回调</span></span></span><br><span class="line"><span class="function"><span class="title">GAMEPLAYATTRIBUTE_REPNOTIFY</span><span class="params">(UAuraAttributeSet, Health, OldHealth)</span>    <span class="comment">// 属性变化通知宏</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性数据类型"><a href="#属性数据类型" class="headerlink" title="属性数据类型"></a><strong>属性数据类型</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">FGameplayAttributeData                                               <span class="comment">// GAS属性数据类型</span></span><br></pre></td></tr></table></figure></div>

<h4 id="复制条件枚举"><a href="#复制条件枚举" class="headerlink" title="复制条件枚举"></a><strong>复制条件枚举</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">COND_None                                                            <span class="comment">// 无条件复制</span></span><br><span class="line">COND_OwnerOnly                                                       <span class="comment">// 仅所有者复制</span></span><br><span class="line">COND_InitialOnly                                                     <span class="comment">// 仅初始复制</span></span><br></pre></td></tr></table></figure></div>

<h4 id="通知策略枚举"><a href="#通知策略枚举" class="headerlink" title="通知策略枚举"></a><strong>通知策略枚举</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">REPNOTIFY_Always                                                     <span class="comment">// 总是通知</span></span><br><span class="line">REPNOTIFY_OnChanged                                                  <span class="comment">// 变化时通知</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a><strong>属性分类</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Category = <span class="string">&quot;Vital Attributes&quot;</span>                                        <span class="comment">// 重要属性分类</span></span><br></pre></td></tr></table></figure></div>

<h4 id="危险操作（临时方案）"><a href="#危险操作（临时方案）" class="headerlink" title="危险操作（临时方案）"></a><strong>危险操作（临时方案）</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;UAuraAttributeSet*&gt;(AuraAttributeSet)                     <span class="comment">// 移除const修饰符（危险）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性集获取"><a href="#属性集获取" class="headerlink" title="属性集获取"></a><strong>属性集获取</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">GetAttributeSet</span>(UAuraAttributeSet::<span class="built_in">StaticClass</span>())</span><br></pre></td></tr></table></figure></div>

<h4 id="宏生成的函数类型"><a href="#宏生成的函数类型" class="headerlink" title="宏生成的函数类型"></a><strong>宏生成的函数类型</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">GAMEPLAYATTRIBUTE_PROPERTY_GETTER                                    <span class="comment">// 属性元数据获取器</span></span><br><span class="line">GAMEPLAYATTRIBUTE_VALUE_GETTER                                       <span class="comment">// 属性值获取器</span></span><br><span class="line">GAMEPLAYATTRIBUTE_VALUE_SETTER                                       <span class="comment">// 属性值设置器</span></span><br><span class="line">GAMEPLAYATTRIBUTE_VALUE_INITTER                                      <span class="comment">// 属性值初始化器</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性模式"><a href="#属性模式" class="headerlink" title="属性模式"></a><strong>属性模式</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Health / MaxHealth                                                   <span class="comment">// 当前值/最大值配对模式</span></span><br><span class="line">Mana / MaxMana                                                       <span class="comment">// 魔法值配对模式</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性变化响应流程"><a href="#属性变化响应流程" class="headerlink" title="属性变化响应流程"></a><strong>属性变化响应流程</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">服务器修改 → 网络复制 → 客户端OnRep回调 → GAMEPLAYATTRIBUTE_REPNOTIFY → UI更新</span><br></pre></td></tr></table></figure></div>

<h2 id="4-RPG-Game-UI-RPG游戏用户界面"><a href="#4-RPG-Game-UI-RPG游戏用户界面" class="headerlink" title="4.RPG Game UI &#x2F; RPG游戏用户界面"></a>4.RPG Game UI &#x2F; RPG游戏用户界面</h2><ul>
<li><p>9 个讲座·2 小时 27 分钟 &#x2F; 9 Lectures · 2 Hours 27 Minutes</p>
</li>
<li><p>Game UI Architecture</p>
<p>07:36</p>
</li>
</ul>
<blockquote>
<p>View(表现层):</p>
<p>数据的视觉表现(eg:血条 法力值等等)</p>
<p>–&gt;AuraUserWidget  </p>
</blockquote>
<blockquote>
<p> (Widget)Controller(控制层):</p>
<p> 作为 View 和 Model 的中介 View想改变视觉表现得通过 Controller 而 Model向 View 传递数据得通过 Controller</p>
<p> –&gt;AuraWidgetController</p>
</blockquote>
<blockquote>
<p> Model(数据层):</p>
<p> 相当于数据库 存放Attribute 的值(FGameplayAttribute)</p>
<p> –&gt;UAuraAttributeSet</p>
</blockquote>
<p>- </p>
<p>  Aura User Widget and Widget Controller</p>
<p>  10:39</p>
<h3 id="🎮-Aura-UI-系统的-MVC-架构实现"><a href="#🎮-Aura-UI-系统的-MVC-架构实现" class="headerlink" title="🎮 Aura UI 系统的 MVC 架构实现"></a>🎮 <strong>Aura UI 系统的 MVC 架构实现</strong></h3><h4 id="1-架构总览"><a href="#1-架构总览" class="headerlink" title="1. 架构总览"></a><strong>1. 架构总览</strong></h4>  <pre class="mermaid">graph TD
    Model[Model层<br/>UAttributeSet] -->|数据变化| Controller[Controller层<br/>UAuraWidgetController]
    Controller -->|更新通知| View[View层<br/>UAuraUserWidget]
    View -->|用户交互| Controller</pre>

<h4 id="2-Controller层：UAuraWidgetController"><a href="#2-Controller层：UAuraWidgetController" class="headerlink" title="2. Controller层：UAuraWidgetController"></a><strong>2. Controller层：UAuraWidgetController</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> UAuraWidgetController : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 四个核心数据源</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category=<span class="string">&quot;WidgetController&quot;</span>)</span><br><span class="line">    TObjectPtr&lt;APlayerController&gt; PlayerController;      <span class="comment">// 玩家控制器</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category=<span class="string">&quot;WidgetController&quot;</span>)</span><br><span class="line">    TObjectPtr&lt;APlayerState&gt; PlayerState;                <span class="comment">// 玩家状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category=<span class="string">&quot;WidgetController&quot;</span>)</span><br><span class="line">    TObjectPtr&lt;UAbilitySystemComponent&gt; AbilitySystemComponent;  <span class="comment">// GAS组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category=<span class="string">&quot;WidgetController&quot;</span>)</span><br><span class="line">    TObjectPtr&lt;UAttributeSet&gt; AttributeSet;              <span class="comment">// 属性集</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="四个数据源的作用"><a href="#四个数据源的作用" class="headerlink" title="四个数据源的作用"></a><strong>四个数据源的作用</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> PlayerController: 处理玩家输入、相机控制</span><br><span class="line"><span class="number">2.</span> PlayerState: 存储玩家数据（等级、经验等）</span><br><span class="line"><span class="number">3.</span> AbilitySystemComponent: 管理技能和属性修改</span><br><span class="line"><span class="number">4.</span> AttributeSet: 具体的属性值（生命、魔法等）</span><br></pre></td></tr></table></figure></div>

<h4 id="3-View层：UAuraUserWidget"><a href="#3-View层：UAuraUserWidget" class="headerlink" title="3. View层：UAuraUserWidget"></a><strong>3. View层：UAuraUserWidget</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> UAuraUserWidget : <span class="keyword">public</span> UUserWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置Controller</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetWidgetController</span><span class="params">(UObject* InWidgetController)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Controller引用</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly)</span><br><span class="line">    TObjectPtr&lt;UObject&gt; WidgetController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 蓝图事件：Controller设置完成后触发</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WidgetControllerSet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-SetWidgetController函数实现"><a href="#4-SetWidgetController函数实现" class="headerlink" title="4. SetWidgetController函数实现"></a><strong>4. SetWidgetController函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraUserWidget::SetWidgetController</span><span class="params">(UObject* InWidgetController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 保存Controller引用</span></span><br><span class="line">    WidgetController = InWidgetController;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 触发蓝图事件</span></span><br><span class="line">    <span class="built_in">WidgetControllerSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a><strong>函数调用流程</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在蓝图或C++中调用：</span></span><br><span class="line">AuraUserWidget-&gt;<span class="built_in">SetWidgetController</span>(WidgetController);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行顺序：</span></span><br><span class="line"><span class="number">1.</span> 设置WidgetController = 传入的Controller</span><br><span class="line"><span class="number">2.</span> 自动调用<span class="built_in">WidgetControllerSet</span>()事件</span><br><span class="line"><span class="number">3.</span> 蓝图中处理数据绑定和UI初始化</span><br></pre></td></tr></table></figure></div>

<h4 id="5-蓝图事件：WidgetControllerSet"><a href="#5-蓝图事件：WidgetControllerSet" class="headerlink" title="5. 蓝图事件：WidgetControllerSet"></a><strong>5. 蓝图事件：WidgetControllerSet</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++声明（接口）</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WidgetControllerSet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蓝图实现（举例）：</span></span><br><span class="line"><span class="comment">// 1. 获取Controller</span></span><br><span class="line"><span class="comment">// 2. 绑定属性变化事件</span></span><br><span class="line"><span class="comment">// 3. 初始化UI显示</span></span><br><span class="line"><span class="comment">// 4. 设置按钮点击事件</span></span><br></pre></td></tr></table></figure></div>

<h5 id="BlueprintImplementableEvent特性"><a href="#BlueprintImplementableEvent特性" class="headerlink" title="BlueprintImplementableEvent特性"></a><strong>BlueprintImplementableEvent特性</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个宏创建的函数：</span></span><br><span class="line"><span class="number">1.</span> 只有声明，没有C++实现</span><br><span class="line"><span class="number">2.</span> 必须在蓝图中实现</span><br><span class="line"><span class="number">3.</span> 自动生成调用节点</span><br><span class="line"><span class="number">4.</span> 无法在C++中直接调用</span><br></pre></td></tr></table></figure></div>

<h4 id="6-数据流向示例"><a href="#6-数据流向示例" class="headerlink" title="6. 数据流向示例"></a><strong>6. 数据流向示例</strong></h4><h5 id="生命值更新流程"><a href="#生命值更新流程" class="headerlink" title="生命值更新流程"></a><strong>生命值更新流程</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 模型层变化</span></span><br><span class="line">AttributeSet::Health 值改变（玩家受伤/治疗）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Controller层监听</span></span><br><span class="line">WidgetController监听到Health属性变化</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通知View层</span></span><br><span class="line">WidgetController触发UI更新事件</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. View层更新</span></span><br><span class="line">AuraUserWidget中的生命条更新显示</span><br></pre></td></tr></table></figure></div>

<h4 id="7-使用UObject作为基类的设计考虑"><a href="#7-使用UObject作为基类的设计考虑" class="headerlink" title="7. 使用UObject作为基类的设计考虑"></a><strong>7. 使用UObject作为基类的设计考虑</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WidgetController类型：</span></span><br><span class="line">TObjectPtr&lt;UObject&gt; WidgetController;  <span class="comment">// 基类指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么用UObject而不是具体类？</span></span><br><span class="line"><span class="number">1.</span> 灵活性：可以传递不同类型的Controller</span><br><span class="line"><span class="number">2.</span> 蓝图友好：蓝图中可以Cast为具体类型</span><br><span class="line"><span class="number">3.</span> 扩展性：方便添加新的Controller类型</span><br></pre></td></tr></table></figure></div>

<h5 id="类型安全转换"><a href="#类型安全转换" class="headerlink" title="类型安全转换"></a><strong>类型安全转换</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在蓝图中使用：</span></span><br><span class="line">UAuraWidgetController* AuraController = </span><br><span class="line">    <span class="built_in">Cast</span>&lt;UAuraWidgetController&gt;(WidgetController);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (AuraController)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 安全地使用AuraController</span></span><br><span class="line">    <span class="type">float</span> Health = AuraController-&gt;<span class="built_in">GetHealth</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="8-MVC架构优势"><a href="#8-MVC架构优势" class="headerlink" title="8. MVC架构优势"></a><strong>8. MVC架构优势</strong></h4><table>
<thead>
<tr>
<th>层</th>
<th>职责</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Model</strong></td>
<td>数据（AttributeSet）</td>
<td>数据与显示分离</td>
</tr>
<tr>
<td><strong>View</strong></td>
<td>UI显示（UserWidget）</td>
<td>纯显示逻辑，易于替换</td>
</tr>
<tr>
<td><strong>Controller</strong></td>
<td>业务逻辑（WidgetController）</td>
<td>集中处理，易于维护</td>
</tr>
</tbody></table>
<p>  <strong>总结</strong>：这个MVC架构为UI系统提供了清晰的分层结构，为后续的复杂UI功能（属性面板、技能栏、背包等）奠定了坚实的基础。</p>
<p>- </p>
<p>  Globe Progress Bar</p>
<p>  28:38</p>
<p>- </p>
<p>  Health Globe</p>
<p>  10:38</p>
<p>- </p>
<p>  Aura HUD</p>
<p>  08:14</p>
<h3 id="🖥️-AuraHUD：UI管理系统"><a href="#🖥️-AuraHUD：UI管理系统" class="headerlink" title="🖥️ AuraHUD：UI管理系统"></a>🖥️ <strong>AuraHUD：UI管理系统</strong></h3><h4 id="1-HUD基类继承"><a href="#1-HUD基类继承" class="headerlink" title="1. HUD基类继承"></a><strong>1. HUD基类继承</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> AAuraHUD : <span class="keyword">public</span> AHUD</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>继承自</strong> <code>AHUD</code>：虚幻引擎的HUD基类</li>
<li><strong>作用</strong>：在游戏屏幕上显示UI</li>
</ul>
<h4 id="2-成员变量声明"><a href="#2-成员变量声明" class="headerlink" title="2. 成员变量声明"></a><strong>2. 成员变量声明</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 当前显示的覆盖层Widget实例</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    TObjectPtr&lt;UAuraUserWidget&gt; OverlayWidget;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 要创建的Widget的蓝图类（在编辑器中设置）</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    TSubclassOf&lt;UAuraUserWidget&gt; OverlayWidgetClass;</span><br></pre></td></tr></table></figure></div>

<h5 id="变量详细说明"><a href="#变量详细说明" class="headerlink" title="变量详细说明"></a><strong>变量详细说明</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. OverlayWidget（实例）</span></span><br><span class="line">TObjectPtr&lt;UAuraUserWidget&gt; OverlayWidget;</span><br><span class="line"><span class="comment">// 作用：存储已经创建出来的UI对象</span></span><br><span class="line"><span class="comment">// 类型：UAuraUserWidget指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. OverlayWidgetClass（类引用）</span></span><br><span class="line">TSubclassOf&lt;UAuraUserWidget&gt; OverlayWidgetClass;</span><br><span class="line"><span class="comment">// 作用：告诉CreateWidget函数要创建哪个类的UI</span></span><br><span class="line"><span class="comment">// 编辑器设置：在AuraHUD的蓝图实例中选择一个Widget蓝图</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-BeginPlay函数实现"><a href="#3-BeginPlay函数实现" class="headerlink" title="3. BeginPlay函数实现"></a><strong>3. BeginPlay函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraHUD::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建Widget实例</span></span><br><span class="line">    UUserWidget* Widget = <span class="built_in">CreateWidget</span>&lt;UUserWidget&gt;(<span class="built_in">GetWorld</span>(), OverlayWidgetClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将Widget添加到屏幕</span></span><br><span class="line">    Widget-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="代码执行步骤"><a href="#代码执行步骤" class="headerlink" title="代码执行步骤"></a><strong>代码执行步骤</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 游戏开始 → 调用BeginPlay()</span><br><span class="line">2. 调用父类AHUD的BeginPlay</span><br><span class="line">3. CreateWidget创建UI对象</span><br><span class="line">4. AddToViewport把UI显示到屏幕上</span><br></pre></td></tr></table></figure></div>

<h4 id="4-CreateWidget函数详解"><a href="#4-CreateWidget函数详解" class="headerlink" title="4. CreateWidget函数详解"></a><strong>4. CreateWidget函数详解</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateWidget</span>&lt;UUserWidget&gt;(<span class="built_in">GetWorld</span>(), OverlayWidgetClass);</span><br></pre></td></tr></table></figure></div>

<h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h5><table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>模板参数</strong></td>
<td><code>&lt;UUserWidget&gt;</code></td>
<td>返回的指针类型</td>
</tr>
<tr>
<td><strong>参数1</strong></td>
<td><code>GetWorld()</code></td>
<td>当前的游戏世界</td>
</tr>
<tr>
<td><strong>参数2</strong></td>
<td><code>OverlayWidgetClass</code></td>
<td>要创建的Widget类</td>
</tr>
</tbody></table>
<h4 id="5-AddToViewport函数"><a href="#5-AddToViewport函数" class="headerlink" title="5. AddToViewport函数"></a><strong>5. AddToViewport函数</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget-&gt;<span class="built_in">AddToViewport</span>();</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>功能</strong>：把Widget添加到游戏屏幕</li>
<li><strong>效果</strong>：玩家可以看到这个UI</li>
</ul>
<h4 id="6-当前代码的逻辑流程"><a href="#6-当前代码的逻辑流程" class="headerlink" title="6. 当前代码的逻辑流程"></a><strong>6. 当前代码的逻辑流程</strong></h4>  <pre class="mermaid">graph LR
    A[游戏开始] --> B[AAuraHUD::BeginPlay]
    B --> C[CreateWidget创建UI]
    C --> D[AddToViewport显示UI]
    D --> E[玩家看到覆盖层界面]</pre>

<h4 id="7-总结当前代码功能"><a href="#7-总结当前代码功能" class="headerlink" title="7. 总结当前代码功能"></a><strong>7. 总结当前代码功能</strong></h4><pre><code>1. **声明了一个UI类引用**：在编辑器中设置要显示哪个Widget
2. **游戏开始时创建UI**：在BeginPlay中实例化Widget
3. **显示到屏幕**：通过AddToViewport显示给玩家看
</code></pre>
<p>- </p>
<p>  Overlay Widget Controller</p>
<p>  32:15</p>
<h3 id="🎮-Aura-UI-系统的初始化流程"><a href="#🎮-Aura-UI-系统的初始化流程" class="headerlink" title="🎮 Aura UI 系统的初始化流程"></a>🎮 <strong>Aura UI 系统的初始化流程</strong></h3><h4 id="1-新增：FWidgetControllerParams-结构体"><a href="#1-新增：FWidgetControllerParams-结构体" class="headerlink" title="1. 新增：FWidgetControllerParams 结构体"></a><strong>1. 新增：FWidgetControllerParams 结构体</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FWidgetControllerParams</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数：接受4个参数</span></span><br><span class="line">    <span class="built_in">FWidgetControllerParams</span>(APlayerController* PC, APlayerState* PS, </span><br><span class="line">                           UAbilitySystemComponent* ASC, UAttributeSet* AS)</span><br><span class="line">        : <span class="built_in">PlayerController</span>(PC), <span class="built_in">PlayerState</span>(PS), </span><br><span class="line">          <span class="built_in">AbilitySystemComponent</span>(ASC), <span class="built_in">AttributeSet</span>(AS) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四个数据源指针</span></span><br><span class="line">    TObjectPtr&lt;APlayerController&gt; PlayerController;       <span class="comment">// 玩家控制器</span></span><br><span class="line">    TObjectPtr&lt;APlayerState&gt; PlayerState;                 <span class="comment">// 玩家状态</span></span><br><span class="line">    TObjectPtr&lt;UAbilitySystemComponent&gt; AbilitySystemComponent; <span class="comment">// GAS组件</span></span><br><span class="line">    TObjectPtr&lt;UAttributeSet&gt; AttributeSet;               <span class="comment">// 属性集</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：打包UI需要的4个核心数据源</li>
<li><strong>好处</strong>：一个结构体传递所有参数，代码更简洁</li>
</ul>
<h4 id="2-WidgetController参数设置函数"><a href="#2-WidgetController参数设置函数" class="headerlink" title="2. WidgetController参数设置函数"></a><strong>2. WidgetController参数设置函数</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraWidgetController::SetWidgetControllerParams</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp; WCParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将结构体中的参数赋给成员变量</span></span><br><span class="line">    PlayerController = WCParams.PlayerController;</span><br><span class="line">    PlayerState = WCParams.PlayerState;</span><br><span class="line">    AbilitySystemComponent = WCParams.AbilitySystemComponent;</span><br><span class="line">    AttributeSet = WCParams.AttributeSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>功能</strong>：一次性设置Controller的所有数据源</li>
<li><strong>调用时机</strong>：Controller创建后立即调用</li>
</ul>
<h4 id="3-HUD中的Controller管理"><a href="#3-HUD中的Controller管理" class="headerlink" title="3. HUD中的Controller管理"></a><strong>3. HUD中的Controller管理</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuraHUD.h 新增成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    TObjectPtr&lt;UOverlayWidgetController&gt; OverlayWidgetController;  <span class="comment">// Controller实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    TSubclassOf&lt;UOverlayWidgetController&gt; OverlayWidgetControllerClass;  <span class="comment">// Controller类</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-GetOverlayWidgetController函数（单例模式）"><a href="#4-GetOverlayWidgetController函数（单例模式）" class="headerlink" title="4. GetOverlayWidgetController函数（单例模式）"></a><strong>4. GetOverlayWidgetController函数（单例模式）</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UOverlayWidgetController* <span class="title">AAuraHUD::GetOverlayWidgetController</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp; WCParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OverlayWidgetController == <span class="literal">nullptr</span>)  <span class="comment">// 如果还没创建</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Controller实例</span></span><br><span class="line">        OverlayWidgetController = <span class="built_in">NewObject</span>&lt;UOverlayWidgetController&gt;(<span class="keyword">this</span>, OverlayWidgetControllerClass);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置数据源参数</span></span><br><span class="line">        OverlayWidgetController-&gt;<span class="built_in">SetWidgetControllerParams</span>(WCParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OverlayWidgetController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>单例模式</strong>：确保整个游戏只有一个OverlayController</li>
<li><strong>懒加载</strong>：第一次需要时才创建</li>
</ul>
<h4 id="5-InitOverlay初始化函数"><a href="#5-InitOverlay初始化函数" class="headerlink" title="5. InitOverlay初始化函数"></a><strong>5. InitOverlay初始化函数</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraHUD::InitOverlay</span><span class="params">(APlayerController* PC, APlayerState* PS, </span></span></span><br><span class="line"><span class="params"><span class="function">                           UAbilitySystemComponent* ASC, UAttributeSet* AS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查类引用是否设置（开发时断言）</span></span><br><span class="line">    <span class="built_in">checkf</span>(OverlayWidgetClass, <span class="built_in">TEXT</span>(<span class="string">&quot;覆层类未初始化，请填写BP_AuraHUD&quot;</span>));</span><br><span class="line">    <span class="built_in">checkf</span>(OverlayWidgetControllerClass, <span class="built_in">TEXT</span>(<span class="string">&quot;覆层控制器类未初始化，请填写BP_AuraHUD&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 创建UI Widget</span></span><br><span class="line">    UUserWidget* Widget = <span class="built_in">CreateWidget</span>&lt;UUserWidget&gt;(<span class="built_in">GetWorld</span>(), OverlayWidgetClass);</span><br><span class="line">    OverlayWidget = <span class="built_in">Cast</span>&lt;UAuraUserWidget&gt;(Widget);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 准备Controller参数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FWidgetControllerParams <span class="title">WidgetControllerParams</span><span class="params">(PC, PS, ASC, AS)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 获取或创建Controller</span></span><br><span class="line">    UOverlayWidgetController* WidgetController = <span class="built_in">GetOverlayWidgetController</span>(WidgetControllerParams);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 将Controller绑定到Widget</span></span><br><span class="line">    OverlayWidget-&gt;<span class="built_in">SetWidgetController</span>(WidgetController);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 显示UI</span></span><br><span class="line">    Widget-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="6-在玩家角色中初始化UI"><a href="#6-在玩家角色中初始化UI" class="headerlink" title="6. 在玩家角色中初始化UI"></a><strong>6. 在玩家角色中初始化UI</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraCharacter::InitAbilityActorInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取PlayerState和GAS组件（之前的代码）</span></span><br><span class="line">    AAuraPlayerState* AuraPlayerState = <span class="built_in">GetPlayerState</span>&lt;AAuraPlayerState&gt;();</span><br><span class="line">    <span class="built_in">check</span>(AuraPlayerState);</span><br><span class="line">    AuraPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(AuraPlayerState, <span class="keyword">this</span>);</span><br><span class="line">    AbilitySystemComponent = AuraPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>();</span><br><span class="line">    AttributeSet = AuraPlayerState-&gt;<span class="built_in">GetAttributeSet</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 新增：初始化UI系统</span></span><br><span class="line">    <span class="keyword">if</span> (AAuraPlayerController* AuraPlayerController = <span class="built_in">Cast</span>&lt;AAuraPlayerController&gt;(<span class="built_in">GetController</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (AAuraHUD* AuraHUD = <span class="built_in">Cast</span>&lt;AAuraHUD&gt;(AuraPlayerController-&gt;<span class="built_in">GetHUD</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用HUD初始化UI</span></span><br><span class="line">            AuraHUD-&gt;<span class="built_in">InitOverlay</span>(AuraPlayerController, AuraPlayerState, </span><br><span class="line">                                 AbilitySystemComponent, AttributeSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="7-代码执行流程"><a href="#7-代码执行流程" class="headerlink" title="7. 代码执行流程"></a><strong>7. 代码执行流程</strong></h4>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">玩家加入游戏 → 角色被控制器拥有(PossessedBy)</span><br><span class="line">    ↓</span><br><span class="line">调用InitAbilityActorInfo()</span><br><span class="line">    ↓</span><br><span class="line">获取PlayerState、ASC、AS</span><br><span class="line">    ↓</span><br><span class="line">通过Controller找到HUD</span><br><span class="line">    ↓</span><br><span class="line">调用HUD.InitOverlay(4个参数)</span><br><span class="line">    ↓</span><br><span class="line">HUD创建Widget和Controller</span><br><span class="line">    ↓</span><br><span class="line">Controller绑定数据源，Widget绑定Controller</span><br><span class="line">    ↓</span><br><span class="line">UI显示在屏幕上</span><br></pre></td></tr></table></figure></div>

<h4 id="8-Cast操作的作用"><a href="#8-Cast操作的作用" class="headerlink" title="8. Cast操作的作用"></a><strong>8. Cast操作的作用</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两次Cast确保类型正确：</span></span><br><span class="line"><span class="number">1.</span> <span class="built_in">Cast</span>&lt;AAuraPlayerController&gt;(<span class="built_in">GetController</span>())</span><br><span class="line">   <span class="comment">// 确保Controller是Aura自定义的</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="built_in">Cast</span>&lt;AAuraHUD&gt;(AuraPlayerController-&gt;<span class="built_in">GetHUD</span>())</span><br><span class="line">   <span class="comment">// 确保HUD是Aura自定义的</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="built_in">Cast</span>&lt;UAuraUserWidget&gt;(Widget)</span><br><span class="line">   <span class="comment">// 确保创建的Widget是Aura自定义的</span></span><br></pre></td></tr></table></figure></div>

<h4 id="9-checkf断言函数"><a href="#9-checkf断言函数" class="headerlink" title="9. checkf断言函数"></a><strong>9. checkf断言函数</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">checkf</span>(OverlayWidgetClass, <span class="built_in">TEXT</span>(<span class="string">&quot;错误信息&quot;</span>));</span><br><span class="line"><span class="comment">// 作用：开发时检查，如果条件为false则崩溃并显示错误信息</span></span><br><span class="line"><span class="comment">// 发布版本中自动移除，不影响性能</span></span><br></pre></td></tr></table></figure></div>

<p>- </p>
<p>  Broadcasting Initial Values</p>
<p>  25:37</p>
<h3 id="📢-广播初始值系统"><a href="#📢-广播初始值系统" class="headerlink" title="📢 广播初始值系统"></a>📢 <strong>广播初始值系统</strong></h3><h4 id="1-新增虚函数-BroadcastInitialValues"><a href="#1-新增虚函数-BroadcastInitialValues" class="headerlink" title="1. 新增虚函数 BroadcastInitialValues"></a><strong>1. 新增虚函数 BroadcastInitialValues</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 UAuraWidgetController</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BroadcastInitialValues</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：通知UI显示属性的初始值</li>
<li><strong>虚函数</strong>：子类可以重写实现特定逻辑</li>
</ul>
<h4 id="2-基类实现（空函数）"><a href="#2-基类实现（空函数）" class="headerlink" title="2. 基类实现（空函数）"></a><strong>2. 基类实现（空函数）</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraWidgetController::BroadcastInitialValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基类不实现具体逻辑</span></span><br><span class="line">    <span class="comment">// 子类需要重写这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-派生类-UOverlayWidgetController-重写"><a href="#3-派生类-UOverlayWidgetController-重写" class="headerlink" title="3. 派生类 UOverlayWidgetController 重写"></a><strong>3. 派生类 UOverlayWidgetController 重写</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OverlayWidgetController.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UOverlayWidgetController</span> : <span class="keyword">public</span> UAuraWidgetController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BroadcastInitialValues</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-BroadcastInitialValues-实现"><a href="#4-BroadcastInitialValues-实现" class="headerlink" title="4. BroadcastInitialValues 实现"></a><strong>4. BroadcastInitialValues 实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::BroadcastInitialValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 安全地转换为AuraAttributeSet</span></span><br><span class="line">    <span class="type">const</span> UAuraAttributeSet* AuraAttributeSet = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 广播生命值初始值</span></span><br><span class="line">    OnHealtChanged.<span class="built_in">Broadcast</span>(AuraAttributeSet-&gt;<span class="built_in">GetHealth</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 广播最大生命值初始值</span></span><br><span class="line">    OnHMaxHealtChanged.<span class="built_in">Broadcast</span>(AuraAttributeSet-&gt;<span class="built_in">GetMaxHealth</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a><strong>关键函数说明</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. CastChecked</span></span><br><span class="line"><span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet)</span><br><span class="line"><span class="comment">// 作用：安全类型转换，如果转换失败则断言崩溃</span></span><br><span class="line"><span class="comment">// 前提：确保AttributeSet确实是UAuraAttributeSet类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Broadcast函数</span></span><br><span class="line">OnHealtChanged.<span class="built_in">Broadcast</span>(值);</span><br><span class="line"><span class="comment">// 作用：通知所有监听这个事件的UI更新显示</span></span><br><span class="line"><span class="comment">// 参数：要广播的属性值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="5-委托声明"><a href="#5-委托声明" class="headerlink" title="5. 委托声明"></a><strong>5. 委托声明</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OverlayWidgetController.h</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnHealtChangedSignature, <span class="type">float</span>, NewHealth);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnMaxHealtChangedSignature, <span class="type">float</span>, NewMaxHealth);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托变量</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">&quot;GAS|Attributes&quot;</span>)</span><br><span class="line">FOnHealtChangedSignature OnHealtChanged;  <span class="comment">// 生命值变化委托</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">&quot;GAS|Attributes&quot;</span>)</span><br><span class="line">FOnMaxHealtChangedSignature OnHMaxHealtChanged;  <span class="comment">// 最大生命值变化委托</span></span><br></pre></td></tr></table></figure></div>

<h5 id="委托宏解析"><a href="#委托宏解析" class="headerlink" title="委托宏解析"></a><strong>委托宏解析</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(</span><br><span class="line">    FOnHealtChangedSignature,  <span class="comment">// 委托类型名</span></span><br><span class="line">    <span class="type">float</span>,                     <span class="comment">// 参数类型</span></span><br><span class="line">    NewHealth                  <span class="comment">// 参数名</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h4 id="6-HUD中的调用时机"><a href="#6-HUD中的调用时机" class="headerlink" title="6. HUD中的调用时机"></a><strong>6. HUD中的调用时机</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraHUD::InitOverlay</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 前面创建Widget和Controller的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 绑定Controller到Widget</span></span><br><span class="line">    OverlayWidget-&gt;<span class="built_in">SetWidgetController</span>(WidgetController);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 新增：广播初始值</span></span><br><span class="line">    WidgetController-&gt;<span class="built_in">BroadcastInitialValues</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 显示UI</span></span><br><span class="line">    Widget-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="7-完整的UI初始化流程"><a href="#7-完整的UI初始化流程" class="headerlink" title="7. 完整的UI初始化流程"></a><strong>7. 完整的UI初始化流程</strong></h4>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建Widget实例</span><br><span class="line">2. 创建Controller实例</span><br><span class="line">3. Controller设置数据源参数</span><br><span class="line">4. Widget绑定Controller</span><br><span class="line">5. Controller广播初始值 ← 新增步骤</span><br><span class="line">6. Widget显示到屏幕</span><br></pre></td></tr></table></figure></div>

<h4 id="8-为什么需要广播初始值？"><a href="#8-为什么需要广播初始值？" class="headerlink" title="8. 为什么需要广播初始值？"></a><strong>8. 为什么需要广播初始值？</strong></h4><h5 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a><strong>问题场景</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果没有广播初始值：</span></span><br><span class="line"><span class="comment">// 1. UI创建时显示默认值（可能是0）</span></span><br><span class="line"><span class="comment">// 2. 玩家看到生命条为空</span></span><br><span class="line"><span class="comment">// 3. 需要等待属性变化事件才能看到正确值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了广播初始值：</span></span><br><span class="line"><span class="comment">// 1. UI一创建就显示正确的当前值</span></span><br><span class="line"><span class="comment">// 2. 玩家立即看到正确的生命值和魔法值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="9-广播的具体作用"><a href="#9-广播的具体作用" class="headerlink" title="9. 广播的具体作用"></a><strong>9. 广播的具体作用</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnHealtChanged.Broadcast(AuraAttributeSet-&gt;GetHealth());</span></span><br><span class="line"><span class="comment">// 执行过程：</span></span><br><span class="line"><span class="number">1.</span> 获取当前生命值（如：<span class="number">100</span>）</span><br><span class="line"><span class="number">2.</span> 触发OnHealtChanged委托</span><br><span class="line"><span class="number">3.</span> 所有绑定到这个委托的UI函数被调用</span><br><span class="line"><span class="number">4.</span> UI更新显示为<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 蓝图中：</span></span><br><span class="line"><span class="comment">// 可以绑定OnHealtChanged事件来更新生命条</span></span><br></pre></td></tr></table></figure></div>


<p>- </p>
<p>  Listening for Attribute Changes</p>
<p>  11:58</p>
<h3 id="📡-属性变化监听系统"><a href="#📡-属性变化监听系统" class="headerlink" title="📡 属性变化监听系统"></a>📡 <strong>属性变化监听系统</strong></h3><h4 id="1-新增虚函数-BindCallbacksToDependencies"><a href="#1-新增虚函数-BindCallbacksToDependencies" class="headerlink" title="1. 新增虚函数 BindCallbacksToDependencies"></a><strong>1. 新增虚函数 BindCallbacksToDependencies</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 UAuraWidgetController</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BindCallbacksToDependencies</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：绑定属性变化监听器</li>
<li><strong>虚函数</strong>：子类重写实现特定监听</li>
</ul>
<h4 id="2-基类实现（空函数）-1"><a href="#2-基类实现（空函数）-1" class="headerlink" title="2. 基类实现（空函数）"></a><strong>2. 基类实现（空函数）</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraWidgetController::BroadcastInitialValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基类实现为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraWidgetController::BindCallbacksToDependencies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基类实现为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-OverlayWidgetController-实现"><a href="#3-OverlayWidgetController-实现" class="headerlink" title="3. OverlayWidgetController 实现"></a><strong>3. OverlayWidgetController 实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::BindCallbacksToDependencies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 安全转换为AuraAttributeSet</span></span><br><span class="line">    <span class="type">const</span> UAuraAttributeSet* AuraAttributeSet = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 绑定生命值变化监听</span></span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(</span><br><span class="line">        AuraAttributeSet-&gt;<span class="built_in">GetHealthAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UOverlayWidgetController::HealthChanged);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 绑定最大生命值变化监听</span></span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(</span><br><span class="line">        AuraAttributeSet-&gt;<span class="built_in">GetMaxHealthAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UOverlayWidgetController::MaxHealthChanged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-关键函数详解"><a href="#4-关键函数详解" class="headerlink" title="4. 关键函数详解"></a><strong>4. 关键函数详解</strong></h4><h5 id="GetGameplayAttributeValueChangeDelegate"><a href="#GetGameplayAttributeValueChangeDelegate" class="headerlink" title="GetGameplayAttributeValueChangeDelegate"></a><strong>GetGameplayAttributeValueChangeDelegate</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GAS提供的属性变化委托获取函数</span></span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(属性)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数</strong>：要监听的属性（通过GetHealthAttribute()获取）</li>
<li><strong>返回</strong>：<code>FOnGameplayAttributeValueChange</code>委托</li>
</ul>
<h5 id="AddUObject-绑定函数"><a href="#AddUObject-绑定函数" class="headerlink" title="AddUObject 绑定函数"></a><strong>AddUObject 绑定函数</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UOverlayWidgetController::HealthChanged)</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>this</code></td>
<td>拥有回调函数的对象</td>
</tr>
<tr>
<td><code>&amp;UOverlayWidgetController::HealthChanged</code></td>
<td>成员函数指针</td>
</tr>
</tbody></table>
<h4 id="5-回调函数实现"><a href="#5-回调函数实现" class="headerlink" title="5. 回调函数实现"></a><strong>5. 回调函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::HealthChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OnHealthChanged.<span class="built_in">Broadcast</span>(Data.NewValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::MaxHealthChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OnMaxHealthChanged.<span class="built_in">Broadcast</span>(Data.NewValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="FOnAttributeChangeData-结构体"><a href="#FOnAttributeChangeData-结构体" class="headerlink" title="FOnAttributeChangeData 结构体"></a><strong>FOnAttributeChangeData 结构体</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GAS提供的属性变化数据</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FOnAttributeChangeData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> NewValue;      <span class="comment">// 新值</span></span><br><span class="line">    <span class="type">float</span> OldValue;      <span class="comment">// 旧值</span></span><br><span class="line">    <span class="comment">// 其他相关信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="6-HUD中的调用时机-1"><a href="#6-HUD中的调用时机-1" class="headerlink" title="6. HUD中的调用时机"></a><strong>6. HUD中的调用时机</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetOverlayWidgetController 函数中</span></span><br><span class="line"><span class="function">UOverlayWidgetController* <span class="title">AAuraHUD::GetOverlayWidgetController</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp; WCParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OverlayWidgetController == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Controller</span></span><br><span class="line">        OverlayWidgetController = <span class="built_in">NewObject</span>&lt;UOverlayWidgetController&gt;(<span class="keyword">this</span>, OverlayWidgetControllerClass);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置数据源</span></span><br><span class="line">        OverlayWidgetController-&gt;<span class="built_in">SetWidgetControllerParams</span>(WCParams);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 新增：绑定属性监听</span></span><br><span class="line">        OverlayWidgetController-&gt;<span class="built_in">BindCallbacksToDependencies</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OverlayWidgetController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="7-完整的UI初始化流程-1"><a href="#7-完整的UI初始化流程-1" class="headerlink" title="7. 完整的UI初始化流程"></a><strong>7. 完整的UI初始化流程</strong></h4>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建Widget实例</span><br><span class="line">2. 创建Controller实例</span><br><span class="line">3. Controller设置数据源参数</span><br><span class="line">4. Controller绑定属性监听 ← 新增步骤</span><br><span class="line">5. Widget绑定Controller</span><br><span class="line">6. Controller广播初始值</span><br><span class="line">7. Widget显示到屏幕</span><br></pre></td></tr></table></figure></div>

<h4 id="8-工作流程示意图"><a href="#8-工作流程示意图" class="headerlink" title="8. 工作流程示意图"></a><strong>8. 工作流程示意图</strong></h4>  <pre class="mermaid">sequenceDiagram
    participant ASC as AbilitySystemComponent
    participant Controller as OverlayWidgetController
    participant UI as UserWidget

    Note over ASC,UI: 1. 初始设置
    Controller->>ASC: GetGameplayAttributeValueChangeDelegate(Health)
    ASC-->>Controller: 返回委托
    
    Note over ASC,UI: 2. 属性变化时
    ASC->>ASC: Health属性值改变
    ASC->>Controller: 触发HealthChanged回调
    Controller->>UI: OnHealthChanged.Broadcast(新值)
    UI->>UI: 更新生命条显示</pre>

<h4 id="9-属性监听机制详解"><a href="#9-属性监听机制详解" class="headerlink" title="9. 属性监听机制详解"></a><strong>9. 属性监听机制详解</strong></h4><h5 id="委托绑定链"><a href="#委托绑定链" class="headerlink" title="委托绑定链"></a><strong>委托绑定链</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整的委托绑定链：</span></span><br><span class="line"><span class="number">1.</span> GAS内部存储属性变化委托</span><br><span class="line"><span class="number">2.</span> 通过GetGameplayAttributeValueChangeDelegate获取委托</span><br><span class="line"><span class="number">3.</span> 使用AddUObject将成员函数绑定到委托</span><br><span class="line"><span class="number">4.</span> 属性变化时，GAS自动调用所有绑定的函数</span><br></pre></td></tr></table></figure></div>

<h5 id="实时响应优势"><a href="#实时响应优势" class="headerlink" title="实时响应优势"></a><strong>实时响应优势</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相比每帧检查的优势：</span></span><br><span class="line"><span class="comment">// 旧方式（效率低）：</span></span><br><span class="line">每帧检查：<span class="keyword">if</span> (CurrentHealth != LastHealth) &#123; 更新UI &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新方式（事件驱动）：</span></span><br><span class="line">GAS自动通知：属性变化 → 立即更新UI</span><br></pre></td></tr></table></figure></div>

<p>  <strong>核心改进</strong>：从被动轮询变为事件驱动，UI实时响应属性变化，效率更高，响应更快。</p>
<p>- </p>
<p>  Callbacks for Mana Changes</p>
<p>  11:02</p>
<h3 id="🔄-扩展Mana属性监听"><a href="#🔄-扩展Mana属性监听" class="headerlink" title="🔄 扩展Mana属性监听"></a>🔄 <strong>扩展Mana属性监听</strong></h3><h4 id="1-新增Mana相关委托"><a href="#1-新增Mana相关委托" class="headerlink" title="1. 新增Mana相关委托"></a><strong>1. 新增Mana相关委托</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明Mana属性变化委托</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnManaChangedSignature, <span class="type">float</span>, NewMana);</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnMaxManaChangedSignature, <span class="type">float</span>, NewMaxMana);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托变量</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">FOnManaChangedSignature OnManaChanged;          <span class="comment">// 魔法值变化委托</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">FOnMaxManaChangedSignature OnMaxManaChanged;    <span class="comment">// 最大魔法值变化委托</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-新增回调函数"><a href="#2-新增回调函数" class="headerlink" title="2. 新增回调函数"></a><strong>2. 新增回调函数</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 魔法值变化回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ManaChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxManaChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-BroadcastInitialValues-扩展"><a href="#3-BroadcastInitialValues-扩展" class="headerlink" title="3. BroadcastInitialValues 扩展"></a><strong>3. BroadcastInitialValues 扩展</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::BroadcastInitialValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> UAuraAttributeSet* AuraAttributeSet = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有：生命值</span></span><br><span class="line">    OnHealthChanged.<span class="built_in">Broadcast</span>(AuraAttributeSet-&gt;<span class="built_in">GetHealth</span>());</span><br><span class="line">    OnMaxHealthChanged.<span class="built_in">Broadcast</span>(AuraAttributeSet-&gt;<span class="built_in">GetMaxHealth</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：魔法值</span></span><br><span class="line">    OnManaChanged.<span class="built_in">Broadcast</span>(AuraAttributeSet-&gt;<span class="built_in">GetMana</span>());</span><br><span class="line">    OnMaxManaChanged.<span class="built_in">Broadcast</span>(AuraAttributeSet-&gt;<span class="built_in">GetMaxMana</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-BindCallbacksToDependencies-扩展"><a href="#4-BindCallbacksToDependencies-扩展" class="headerlink" title="4. BindCallbacksToDependencies 扩展"></a><strong>4. BindCallbacksToDependencies 扩展</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::BindCallbacksToDependencies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> UAuraAttributeSet* AuraAttributeSet = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有：生命值监听</span></span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(</span><br><span class="line">        AuraAttributeSet-&gt;<span class="built_in">GetHealthAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UOverlayWidgetController::HealthChanged);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：魔法值监听</span></span><br><span class="line">    AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(</span><br><span class="line">        AuraAttributeSet-&gt;<span class="built_in">GetManaAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UOverlayWidgetController::ManaChanged);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大值的监听（同理）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="5-回调函数实现-1"><a href="#5-回调函数实现-1" class="headerlink" title="5. 回调函数实现"></a><strong>5. 回调函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 魔法值变化回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::ManaChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OnManaChanged.<span class="built_in">Broadcast</span>(Data.NewValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::MaxManaChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OnMaxManaChanged.<span class="built_in">Broadcast</span>(Data.NewValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>  <strong>总结</strong>：完全复制了Health属性的监听模式，为Mana属性建立了相同的监听机制，UI现在可以实时响应生命值和魔法值的变化。</p>
<h3 id="📚-第四章关键方法总结"><a href="#📚-第四章关键方法总结" class="headerlink" title="📚 第四章关键方法总结"></a>📚 第四章关键方法总结</h3><h4 id="MVC架构定义"><a href="#MVC架构定义" class="headerlink" title="MVC架构定义"></a><strong>MVC架构定义</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAuraWidgetController</span> : <span class="keyword">public</span> UObject                     <span class="comment">// Controller层</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAuraUserWidget</span> : <span class="keyword">public</span> UUserWidget                       <span class="comment">// View层</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UAuraAttributeSet</span> : <span class="keyword">public</span> UAttributeSet                   <span class="comment">// Model层</span></span><br></pre></td></tr></table></figure></div>

<h4 id="数据传递结构体"><a href="#数据传递结构体" class="headerlink" title="数据传递结构体"></a><strong>数据传递结构体</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FWidgetControllerParams</span>                                   <span class="comment">// UI参数打包</span></span><br><span class="line"><span class="built_in">FWidgetControllerParams</span>(APlayerController*, APlayerState*, UAbilitySystemComponent*, UAttributeSet*)</span><br></pre></td></tr></table></figure></div>

<h4 id="WidgetController参数设置"><a href="#WidgetController参数设置" class="headerlink" title="WidgetController参数设置"></a><strong>WidgetController参数设置</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetWidgetControllerParams</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp; WCParams)</span>  <span class="comment">// 设置4个数据源</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="UI创建与管理"><a href="#UI创建与管理" class="headerlink" title="UI创建与管理"></a><strong>UI创建与管理</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateWidget</span>&lt;T&gt;(<span class="built_in">GetWorld</span>(), WidgetClass)                        <span class="comment">// 创建Widget实例</span></span><br><span class="line">Widget-&gt;<span class="built_in">AddToViewport</span>()                                         <span class="comment">// 显示到屏幕</span></span><br><span class="line"><span class="built_in">Cast</span>&lt;T&gt;(指针)                                                   <span class="comment">// 安全类型转换</span></span><br></pre></td></tr></table></figure></div>

<h4 id="HUD单例Controller模式"><a href="#HUD单例Controller模式" class="headerlink" title="HUD单例Controller模式"></a><strong>HUD单例Controller模式</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UOverlayWidgetController* <span class="title">GetOverlayWidgetController</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp;)</span>  <span class="comment">// 单例获取</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(Controller == <span class="literal">nullptr</span>)</span> Controller </span>= <span class="built_in">NewObject</span>&lt;T&gt;(<span class="keyword">this</span>, ControllerClass)           <span class="comment">// 懒加载创建</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性变化委托声明"><a href="#属性变化委托声明" class="headerlink" title="属性变化委托声明"></a><strong>属性变化委托声明</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnHealthChangedSignature, <span class="type">float</span>, NewHealth)</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnManaChangedSignature, <span class="type">float</span>, NewMana)</span><br></pre></td></tr></table></figure></div>

<h4 id="委托变量声明"><a href="#委托变量声明" class="headerlink" title="委托变量声明"></a><strong>委托变量声明</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">FOnHealthChangedSignature OnHealthChanged                       <span class="comment">// 蓝图可绑定委托</span></span><br></pre></td></tr></table></figure></div>

<h4 id="虚函数框架"><a href="#虚函数框架" class="headerlink" title="虚函数框架"></a><strong>虚函数框架</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BroadcastInitialValues</span><span class="params">()</span>                           <span class="comment">// 广播初始值</span></span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BindCallbacksToDependencies</span><span class="params">()</span>                      <span class="comment">// 绑定属性监听</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性值获取"><a href="#属性值获取" class="headerlink" title="属性值获取"></a><strong>属性值获取</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AuraAttributeSet-&gt;<span class="built_in">GetHealth</span>()                                   <span class="comment">// 获取生命值</span></span><br><span class="line">AuraAttributeSet-&gt;<span class="built_in">GetMana</span>()                                     <span class="comment">// 获取魔法值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性变化监听绑定"><a href="#属性变化监听绑定" class="headerlink" title="属性变化监听绑定"></a><strong>属性变化监听绑定</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(属性)</span><br><span class="line">    .<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UOverlayWidgetController::回调函数)      <span class="comment">// 绑定属性变化回调</span></span><br></pre></td></tr></table></figure></div>

<h4 id="属性变化回调函数"><a href="#属性变化回调函数" class="headerlink" title="属性变化回调函数"></a><strong>属性变化回调函数</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HealthChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> <span class="type">const</span>    <span class="comment">// 属性变化响应</span></span></span><br><span class="line"><span class="function">OnHealthChanged.<span class="title">Broadcast</span><span class="params">(Data.NewValue)</span>                        <span class="comment">// 广播新值</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="开发调试函数"><a href="#开发调试函数" class="headerlink" title="开发调试函数"></a><strong>开发调试函数</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">checkf</span>(条件, <span class="built_in">TEXT</span>(<span class="string">&quot;错误信息&quot;</span>))                                 <span class="comment">// 开发时断言检查</span></span><br><span class="line"><span class="built_in">CastChecked</span>&lt;T&gt;(指针)                                           <span class="comment">// 安全转换（失败则断言）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="蓝图事件声明"><a href="#蓝图事件声明" class="headerlink" title="蓝图事件声明"></a><strong>蓝图事件声明</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WidgetControllerSet</span><span class="params">()</span>                                      <span class="comment">// 蓝图实现的事件</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="WidgetController设置"><a href="#WidgetController设置" class="headerlink" title="WidgetController设置"></a><strong>WidgetController设置</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetWidgetController</span><span class="params">(UObject* InWidgetController)</span>           <span class="comment">// 设置Controller引用</span></span></span><br><span class="line"><span class="function"><span class="title">WidgetControllerSet</span><span class="params">()</span>                                           <span class="comment">// 触发蓝图事件</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="UI初始化流程函数"><a href="#UI初始化流程函数" class="headerlink" title="UI初始化流程函数"></a><strong>UI初始化流程函数</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitOverlay</span><span class="params">(APlayerController*, APlayerState*, UAbilitySystemComponent*, UAttributeSet*)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitAbilityActorInfo</span><span class="params">()</span>                                     <span class="comment">// 角色GAS初始化</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="数据类型与指针"><a href="#数据类型与指针" class="headerlink" title="数据类型与指针"></a><strong>数据类型与指针</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">TObjectPtr&lt;T&gt;                                                   <span class="comment">// UE5安全对象指针</span></span><br><span class="line">TSubclassOf&lt;T&gt;                                                  <span class="comment">// 类型安全的类引用</span></span><br></pre></td></tr></table></figure></div>

<h2 id="5-Gameplay-Effects-游戏效果"><a href="#5-Gameplay-Effects-游戏效果" class="headerlink" title="5.Gameplay Effects &#x2F; 游戏效果"></a>5.Gameplay Effects &#x2F; 游戏效果</h2><ul>
<li><p>12 个讲座·3 小时 31分钟 &#x2F; 12 Lectures · 3 Hours 31 Minutes</p>
</li>
<li><p>Gameplay Effects</p>
<p>07:41</p>
</li>
<li><p>Effect Actor Improved</p>
<p>29:48</p>
</li>
</ul>
<h3 id="🎯-AuraEffectActor-改进：使用GameplayEffect系统"><a href="#🎯-AuraEffectActor-改进：使用GameplayEffect系统" class="headerlink" title="🎯 AuraEffectActor 改进：使用GameplayEffect系统"></a>🎯 <strong>AuraEffectActor 改进：使用GameplayEffect系统</strong></h3><h4 id="1-类定义改进"><a href="#1-类定义改进" class="headerlink" title="1. 类定义改进"></a><strong>1. 类定义改进</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_AURA_API</span> AAuraEffectActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AAuraEffectActor</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的应用效果函数</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ApplyEffectToTarget</span><span class="params">(AActor* Target, TSubclassOf&lt;UGameplayEffect&gt; GameplayEffectClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GameplayEffect类引用</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Category=<span class="string">&quot;Applied Effects&quot;</span>)</span><br><span class="line">    TSubclassOf&lt;UGameplayEffect&gt; InstantGameplayEffectClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="关键改进"><a href="#关键改进" class="headerlink" title="关键改进"></a><strong>关键改进</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除了之前的：</span></span><br><span class="line"><span class="comment">// - OnOverlap/EndOverlap碰撞函数</span></span><br><span class="line"><span class="comment">// - Mesh和Sphere组件</span></span><br><span class="line"><span class="comment">// - const_cast危险操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增了：</span></span><br><span class="line"><span class="comment">// 1. ApplyEffectToTarget函数：正确的GAS应用方式</span></span><br><span class="line"><span class="comment">// 2. InstantGameplayEffectClass：要应用的GameplayEffect类</span></span><br><span class="line"><span class="comment">// 3. 通过蓝图调用，更加灵活</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-ApplyEffectToTarget函数实现"><a href="#2-ApplyEffectToTarget函数实现" class="headerlink" title="2. ApplyEffectToTarget函数实现"></a><strong>2. ApplyEffectToTarget函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEffectActor::ApplyEffectToTarget</span><span class="params">(AActor* Target, TSubclassOf&lt;UGameplayEffect&gt; GameplayEffectClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取目标的AbilitySystemComponent</span></span><br><span class="line">    UAbilitySystemComponent* TargetASC = </span><br><span class="line">        UAbilitySystemBlueprintLibrary::<span class="built_in">GetAbilitySystemComponent</span>(Target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (TargetASC == <span class="literal">nullptr</span>) <span class="keyword">return</span>;  <span class="comment">// 如果目标没有ASC，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 验证GameplayEffectClass是否有效</span></span><br><span class="line">    <span class="built_in">check</span>(GameplayEffectClass);  <span class="comment">// 开发时断言检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建效果上下文</span></span><br><span class="line">    FGameplayEffectContextHandle EffectContextHandle = TargetASC-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">    EffectContextHandle.<span class="built_in">AddSourceObject</span>(<span class="keyword">this</span>);  <span class="comment">// 设置效果来源为本Actor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建效果规格</span></span><br><span class="line">    <span class="type">const</span> FGameplayEffectSpecHandle EffectSpecHandle = </span><br><span class="line">        TargetASC-&gt;<span class="built_in">MakeOutgoingSpec</span>(GameplayEffectClass, <span class="number">1.f</span>, EffectContextHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 应用效果到目标自身</span></span><br><span class="line">    TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*EffectSpecHandle.Data.<span class="built_in">Get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-关键函数详解"><a href="#3-关键函数详解" class="headerlink" title="3. 关键函数详解"></a><strong>3. 关键函数详解</strong></h4><h5 id="GetAbilitySystemComponent"><a href="#GetAbilitySystemComponent" class="headerlink" title="GetAbilitySystemComponent"></a><strong>GetAbilitySystemComponent</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">UAbilitySystemBlueprintLibrary::<span class="built_in">GetAbilitySystemComponent</span>(Target)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：从Actor获取其AbilitySystemComponent</li>
<li><strong>参数</strong>：<code>Target</code> - 要获取ASC的目标Actor</li>
<li><strong>返回</strong>：目标的ASC指针（可能为nullptr）</li>
</ul>
<h5 id="MakeEffectContext"><a href="#MakeEffectContext" class="headerlink" title="MakeEffectContext"></a><strong>MakeEffectContext</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">TargetASC-&gt;<span class="built_in">MakeEffectContext</span>()</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：创建GameplayEffect的上下文</li>
<li><strong>上下文包含</strong>：施法者、目标、来源、时间戳等信息</li>
</ul>
<h5 id="AddSourceObject"><a href="#AddSourceObject" class="headerlink" title="AddSourceObject"></a><strong>AddSourceObject</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">EffectContextHandle.<span class="built_in">AddSourceObject</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：设置效果的来源对象</li>
<li><strong>用途</strong>：用于追踪谁施加了这个效果</li>
</ul>
<h5 id="MakeOutgoingSpec"><a href="#MakeOutgoingSpec" class="headerlink" title="MakeOutgoingSpec"></a><strong>MakeOutgoingSpec</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">TargetASC-&gt;<span class="built_in">MakeOutgoingSpec</span>(GameplayEffectClass, <span class="number">1.f</span>, EffectContextHandle)</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>GameplayEffectClass</code></td>
<td>要创建的GameplayEffect类型</td>
</tr>
<tr>
<td><code>1.f</code></td>
<td>效果的等级（Level）</td>
</tr>
<tr>
<td><code>EffectContextHandle</code></td>
<td>效果上下文</td>
</tr>
</tbody></table>
<h5 id="ApplyGameplayEffectSpecToSelf"><a href="#ApplyGameplayEffectSpecToSelf" class="headerlink" title="ApplyGameplayEffectSpecToSelf"></a><strong>ApplyGameplayEffectSpecToSelf</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*EffectSpecHandle.Data.<span class="built_in">Get</span>())</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>作用</strong>：将GameplayEffect应用到自身</li>
<li><strong>正确的方法</strong>：通过ASC系统应用，而不是直接修改属性</li>
</ul>
<h4 id="4-GameplayEffect应用流程"><a href="#4-GameplayEffect应用流程" class="headerlink" title="4. GameplayEffect应用流程"></a><strong>4. GameplayEffect应用流程</strong></h4>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 获取目标的ASC</span><br><span class="line">   ↓</span><br><span class="line">2. 验证效果类有效</span><br><span class="line">   ↓</span><br><span class="line">3. 创建效果上下文（设置来源）</span><br><span class="line">   ↓</span><br><span class="line">4. 创建效果规格（包含等级、上下文）</span><br><span class="line">   ↓</span><br><span class="line">5. 应用效果到目标</span><br><span class="line">   ↓</span><br><span class="line">6. GAS系统自动处理：属性修改、网络复制、UI更新等</span><br></pre></td></tr></table></figure></div>

<h4 id="5-构造函数的简化"><a href="#5-构造函数的简化" class="headerlink" title="5. 构造函数的简化"></a><strong>5. 构造函数的简化</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">AAuraEffectActor::<span class="built_in">AAuraEffectActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;  <span class="comment">// 禁用Tick</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">SetRootComponent</span>(<span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="string">&quot;SceneRoot&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>移除了</strong>：Mesh和Sphere组件</li>
<li><strong>简化了</strong>：只有一个SceneRoot作为根组件</li>
<li><strong>更灵活</strong>：可以在蓝图中添加需要的组件</li>
</ul>
<h4 id="6-与之前版本的对比"><a href="#6-与之前版本的对比" class="headerlink" title="6. 与之前版本的对比"></a><strong>6. 与之前版本的对比</strong></h4><h5 id="旧版本（错误）"><a href="#旧版本（错误）" class="headerlink" title="旧版本（错误）"></a><strong>旧版本（错误）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接修改属性，绕过GAS</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;UAuraAttributeSet*&gt;(AuraAttributeSet)-&gt;<span class="built_in">SetHealth</span>(...);</span><br></pre></td></tr></table></figure></div>

<h5 id="新版本（正确）"><a href="#新版本（正确）" class="headerlink" title="新版本（正确）"></a><strong>新版本（正确）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过GAS系统应用效果</span></span><br><span class="line">TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(...);</span><br></pre></td></tr></table></figure></div>

<h5 id="优势对比"><a href="#优势对比" class="headerlink" title="优势对比"></a><strong>优势对比</strong></h5><table>
<thead>
<tr>
<th>方面</th>
<th>旧版本</th>
<th>新版本</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GAS集成</strong></td>
<td>绕过系统</td>
<td>完全集成</td>
</tr>
<tr>
<td><strong>网络同步</strong></td>
<td>不同步</td>
<td>自动同步</td>
</tr>
<tr>
<td><strong>事件触发</strong></td>
<td>不触发</td>
<td>触发所有相关事件</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>危险（const_cast）</td>
<td>安全</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>固定功能</td>
<td>可通过不同GameplayEffect实现不同效果</td>
</tr>
</tbody></table>
<h4 id="7-InstantGameplayEffectClass的使用"><a href="#7-InstantGameplayEffectClass的使用" class="headerlink" title="7. InstantGameplayEffectClass的使用"></a><strong>7. InstantGameplayEffectClass的使用</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category=<span class="string">&quot;Applied Effects&quot;</span>)</span><br><span class="line">TSubclassOf&lt;UGameplayEffect&gt; InstantGameplayEffectClass;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>在编辑器中设置</strong>：选择具体的GameplayEffect蓝图</li>
<li><strong>即时效果</strong>：Instant类型的GameplayEffect（立即生效）</li>
<li><strong>可配置</strong>：不同的Actor实例可以使用不同的效果</li>
</ul>
<h4 id="8-如何使用这个Actor"><a href="#8-如何使用这个Actor" class="headerlink" title="8. 如何使用这个Actor"></a><strong>8. 如何使用这个Actor</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 蓝图中：</span></span><br><span class="line"><span class="comment">// 1. 创建AuraEffectActor实例</span></span><br><span class="line"><span class="comment">// 2. 设置InstantGameplayEffectClass属性</span></span><br><span class="line"><span class="comment">// 3. 调用ApplyEffectToTarget函数，传入目标和效果类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接在蓝图中调用：</span></span><br><span class="line">AuraEffectActor-&gt;<span class="built_in">ApplyEffectToTarget</span>(Player, HealingEffect);</span><br></pre></td></tr></table></figure></div>

<h4 id="9-修复的核心问题"><a href="#9-修复的核心问题" class="headerlink" title="9. 修复的核心问题"></a><strong>9. 修复的核心问题</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前注释中的TODO已经实现：</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 将此更改为应用游戏效果，目前使用 const_cast 作为临时解决方案！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在：</span></span><br><span class="line"><span class="comment">// √ 移除了const_cast危险操作</span></span><br><span class="line"><span class="comment">// √ 使用正确的GAS API</span></span><br><span class="line"><span class="comment">// √ 支持网络同步</span></span><br><span class="line"><span class="comment">// √ 触发所有相关事件</span></span><br><span class="line"><span class="comment">// √ 可以通过配置实现不同效果</span></span><br></pre></td></tr></table></figure></div>

<p>  <strong>总结</strong>：这个改进将效果Actor从危险的临时方案变成了标准的GAS实现，通过GameplayEffect系统实现了安全、可扩展、网络同步的属性修改功能。</p>
<p>- </p>
<p>  Instant Gameplay Effects</p>
<p>  20:26</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8AAura%E3%80%8BUE5-Gameplay-Ability-System%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/5-1.png"
                      alt="img"
                ></p>
<center>蓝图中应用GE</center>


<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8AAura%E3%80%8BUE5-Gameplay-Ability-System%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/5-2.png"
                      alt="img"
                ></p>
<center>Instant效果</center>


<p>- </p>
<p>  Duration Gameplay Effects</p>
<p>  18:21</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8AAura%E3%80%8BUE5-Gameplay-Ability-System%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/5-3.png"
                      alt="img"
                ></p>
<center>Duration效果</center>

<p>- </p>
<p>  Periodic Gameplay Effects</p>
<p>  16:17</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8AAura%E3%80%8BUE5-Gameplay-Ability-System%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/5-4.png"
                      alt="5-4"
                ></p>
<p>- </p>
<p>  Effect Stacking</p>
<p>  14:36</p>
<p>- </p>
<p>  Infinite Gameplay Effects</p>
<p>  12:55</p>
<h3 id="🎛️-AuraEffectActor-增强：多类型效果系统"><a href="#🎛️-AuraEffectActor-增强：多类型效果系统" class="headerlink" title="🎛️ AuraEffectActor 增强：多类型效果系统"></a>🎛️ <strong>AuraEffectActor 增强：多类型效果系统</strong></h3><h4 id="1-新增枚举类型"><a href="#1-新增枚举类型" class="headerlink" title="1. 新增枚举类型"></a><strong>1. 新增枚举类型</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 效果应用策略枚举</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EEffectApplicationPolicy</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    ApplyOnOverlap,     <span class="comment">// 重叠时应用</span></span><br><span class="line">    ApplyOnEndOverlap,  <span class="comment">// 结束重叠时应用  </span></span><br><span class="line">    DoNotApply          <span class="comment">// 不应用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果移除策略枚举</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EEffectRemovalPolicy</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    RemoveOnEndOverlap, <span class="comment">// 结束重叠时移除</span></span><br><span class="line">    DoNotRemove         <span class="comment">// 不移除</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="枚举作用"><a href="#枚举作用" class="headerlink" title="枚举作用"></a><strong>枚举作用</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EEffectApplicationPolicy：控制何时应用效果</span></span><br><span class="line"><span class="comment">// EEffectRemovalPolicy：控制何时移除无限持续效果</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-扩展的效果类型系统"><a href="#2-扩展的效果类型系统" class="headerlink" title="2. 扩展的效果类型系统"></a><strong>2. 扩展的效果类型系统</strong></h4><h5 id="三种效果类型"><a href="#三种效果类型" class="headerlink" title="三种效果类型"></a><strong>三种效果类型</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 即时效果（Instant）- 立即生效，无持续时间</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;UGameplayEffect&gt; InstantGameplayEffectClass;            <span class="comment">// 效果类</span></span><br><span class="line">EEffectApplicationPolicy InstantEffectApplicationPolicy;            <span class="comment">// 应用策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 持续效果（Duration）- 固定时间段后自动移除  </span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;UGameplayEffect&gt; DurationGameplayEffectClass;          <span class="comment">// 效果类</span></span><br><span class="line">EEffectApplicationPolicy DurationEffectApplicationPolicy;          <span class="comment">// 应用策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 无限效果（Infinite）- 永久持续，需要手动移除</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;UGameplayEffect&gt; InfiniteGameplayEffectClass;          <span class="comment">// 效果类  </span></span><br><span class="line">EEffectApplicationPolicy InfiniteEffectApplicationPolicy;          <span class="comment">// 应用策略</span></span><br><span class="line">EEffectRemovalPolicy InfiniteEffectRemovalPolicy;                <span class="comment">// 移除策略</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-新增碰撞处理函数"><a href="#3-新增碰撞处理函数" class="headerlink" title="3. 新增碰撞处理函数"></a><strong>3. 新增碰撞处理函数</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重叠开始回调</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnOverlap</span><span class="params">(AActor* TargetActor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重叠结束回调  </span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnEndOverlap</span><span class="params">(AActor* TargetActor)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="函数设计"><a href="#函数设计" class="headerlink" title="函数设计"></a><strong>函数设计</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 蓝图可调用：可以在蓝图中手动触发</span></span><br><span class="line"><span class="comment">// 参数TargetActor：重叠的目标Actor</span></span><br><span class="line"><span class="comment">// 可以在蓝图中连接到碰撞事件</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-效果移除相关"><a href="#4-效果移除相关" class="headerlink" title="4. 效果移除相关"></a><strong>4. 效果移除相关</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 效果移除时是否销毁Actor</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Applied Effects&quot;</span>)</span><br><span class="line"><span class="type">bool</span> bDestroyOnEffectRemoval = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="bDestroyOnEffectRemoval作用"><a href="#bDestroyOnEffectRemoval作用" class="headerlink" title="bDestroyOnEffectRemoval作用"></a><strong>bDestroyOnEffectRemoval作用</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// true：当无限效果被移除时，销毁这个Actor</span></span><br><span class="line"><span class="comment">// false：保留Actor，可以重复使用</span></span><br><span class="line"><span class="comment">// 默认值：false（不销毁）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="5-GameplayEffect类型说明"><a href="#5-GameplayEffect类型说明" class="headerlink" title="5. GameplayEffect类型说明"></a><strong>5. GameplayEffect类型说明</strong></h4><h5 id="三种效果类型对比"><a href="#三种效果类型对比" class="headerlink" title="三种效果类型对比"></a><strong>三种效果类型对比</strong></h5><table>
<thead>
<tr>
<th>类型</th>
<th>持续时间</th>
<th>应用时机</th>
<th>移除时机</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Instant</strong></td>
<td>立即生效，无持续</td>
<td>一次性的</td>
<td>无法移除</td>
</tr>
<tr>
<td><strong>Duration</strong></td>
<td>固定时间段</td>
<td>定时移除</td>
<td>时间到自动移除</td>
</tr>
<tr>
<td><strong>Infinite</strong></td>
<td>永久持续</td>
<td>需要手动移除</td>
<td>根据策略移除</td>
</tr>
</tbody></table>
<h4 id="6-策略配置示例"><a href="#6-策略配置示例" class="headerlink" title="6. 策略配置示例"></a><strong>6. 策略配置示例</strong></h4><h5 id="在编辑器中配置"><a href="#在编辑器中配置" class="headerlink" title="在编辑器中配置"></a><strong>在编辑器中配置</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1：治疗药水（即时效果）</span></span><br><span class="line">InstantGameplayEffectClass = GE_HealingPotion</span><br><span class="line">InstantEffectApplicationPolicy = ApplyOnOverlap</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：中毒效果（持续效果）  </span></span><br><span class="line">DurationGameplayEffectClass = GE_Poison</span><br><span class="line">DurationEffectApplicationPolicy = ApplyOnOverlap</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3：增益光环（无限效果）</span></span><br><span class="line">InfiniteGameplayEffectClass = GE_BuffAura  </span><br><span class="line">InfiniteEffectApplicationPolicy = ApplyOnOverlap</span><br><span class="line">InfiniteEffectRemovalPolicy = RemoveOnEndOverlap</span><br><span class="line">bDestroyOnEffectRemoval = <span class="literal">false</span></span><br></pre></td></tr></table></figure></div>

<h4 id="7-当前代码状态"><a href="#7-当前代码状态" class="headerlink" title="7. 当前代码状态"></a><strong>7. 当前代码状态</strong></h4><h5 id="已实现的函数"><a href="#已实现的函数" class="headerlink" title="已实现的函数"></a><strong>已实现的函数</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 核心效果应用函数（完整实现）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApplyEffectToTarget</span><span class="params">(AActor* TargetActor, TSubclassOf&lt;UGameplayEffect&gt; GameplayEffectClass)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 2. 碰撞处理函数（待实现）</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnOverlap</span><span class="params">(AActor* TargetActor)</span>       <span class="comment">// 需要实现具体逻辑</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnEndOverlap</span><span class="params">(AActor* TargetActor)</span>    <span class="comment">// 需要实现具体逻辑</span></span></span><br></pre></td></tr></table></figure></div>

<h5 id="待实现逻辑"><a href="#待实现逻辑" class="headerlink" title="待实现逻辑"></a><strong>待实现逻辑</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnOverlap函数需要实现：</span></span><br><span class="line"><span class="number">1.</span> 检查目标是否有ASC</span><br><span class="line"><span class="number">2.</span> 根据三种效果类型的策略决定是否应用</span><br><span class="line"><span class="number">3.</span> 调用ApplyEffectToTarget应用相应效果</span><br><span class="line"></span><br><span class="line"><span class="comment">// OnEndOverlap函数需要实现：</span></span><br><span class="line"><span class="number">1.</span> 检查无限效果的移除策略</span><br><span class="line"><span class="number">2.</span> 如果需要移除，找到并移除对应的无限效果</span><br><span class="line"><span class="number">3.</span> 如果bDestroyOnEffectRemoval为<span class="literal">true</span>，销毁自身</span><br></pre></td></tr></table></figure></div>

<h4 id="8-数据结构设计思路"><a href="#8-数据结构设计思路" class="headerlink" title="8. 数据结构设计思路"></a><strong>8. 数据结构设计思路</strong></h4><h5 id="配置驱动设计"><a href="#配置驱动设计" class="headerlink" title="配置驱动设计"></a><strong>配置驱动设计</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过UPROPERTY配置，而不是硬编码</span></span><br><span class="line"><span class="comment">// 优势：</span></span><br><span class="line"><span class="number">1.</span> 可在编辑器可视化配置</span><br><span class="line"><span class="number">2.</span> 不同实例可以不同配置</span><br><span class="line"><span class="number">3.</span> 非程序员也可以调整</span><br></pre></td></tr></table></figure></div>

<h5 id="策略模式应用"><a href="#策略模式应用" class="headerlink" title="策略模式应用"></a><strong>策略模式应用</strong></h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用枚举控制行为，而不是if-else逻辑</span></span><br><span class="line"><span class="comment">// 更清晰，更容易扩展</span></span><br></pre></td></tr></table></figure></div>

<h4 id="9-与碰撞组件的配合"><a href="#9-与碰撞组件的配合" class="headerlink" title="9. 与碰撞组件的配合"></a><strong>9. 与碰撞组件的配合</strong></h4><h5 id="建议的蓝图设置"><a href="#建议的蓝图设置" class="headerlink" title="建议的蓝图设置"></a><strong>建议的蓝图设置</strong></h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">在AuraEffectActor蓝图中：</span><br><span class="line">1. 添加Sphere/Capsule碰撞组件</span><br><span class="line">2. 绑定碰撞事件到OnOverlap/OnEndOverlap</span><br><span class="line">3. 配置各种效果类型和策略</span><br><span class="line">4. 放置到关卡中</span><br></pre></td></tr></table></figure></div>

<h4 id="10-当前架构优势"><a href="#10-当前架构优势" class="headerlink" title="10. 当前架构优势"></a><strong>10. 当前架构优势</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 支持多种效果类型（Instant/Duration/Infinite）</span></span><br><span class="line"><span class="comment">// 2. 灵活的策略配置（应用时机、移除时机）</span></span><br><span class="line"><span class="comment">// 3. 蓝图友好（所有配置和函数都暴露给蓝图）</span></span><br><span class="line"><span class="comment">// 4. 可重用性（一个Actor支持多种效果配置）</span></span><br><span class="line"><span class="comment">// 5. 易于扩展（可以添加更多策略或效果类型）</span></span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong>：这个扩展将AuraEffectActor从一个简单的即时效果应用器升级为完整的、可配置的多类型效果系统，支持三种GameplayEffect类型和灵活的应用&#x2F;移除策略。</p>
<p>- </p>
<p>  Instant and Duration Application Policy</p>
<p>  04:16</p>
<h3 id="⏰-AuraEffectActor：即时与持续效果应用策略"><a href="#⏰-AuraEffectActor：即时与持续效果应用策略" class="headerlink" title="⏰ AuraEffectActor：即时与持续效果应用策略"></a>⏰ <strong>AuraEffectActor：即时与持续效果应用策略</strong></h3><h4 id="1-OnOverlap函数实现"><a href="#1-OnOverlap函数实现" class="headerlink" title="1. OnOverlap函数实现"></a><strong>1. OnOverlap函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEffectActor::OnOverlap</span><span class="params">(AActor* TargetActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查即时效果：是否在重叠时应用</span></span><br><span class="line">    <span class="keyword">if</span> (InstantEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnOverlap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ApplyEffectToTarget</span>(TargetActor, InstantGameplayEffectClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查持续效果：是否在重叠时应用</span></span><br><span class="line">    <span class="keyword">if</span> (DurationEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnOverlap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ApplyEffectToTarget</span>(TargetActor, DurationGameplayEffectClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a><strong>执行逻辑</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">玩家进入碰撞区域（OnOverlap）：</span><br><span class="line">    ↓</span><br><span class="line">检查InstantEffectApplicationPolicy策略</span><br><span class="line">    ↓ 如果策略是ApplyOnOverlap</span><br><span class="line">调用ApplyEffectToTarget应用即时效果</span><br><span class="line">    ↓</span><br><span class="line">检查DurationEffectApplicationPolicy策略</span><br><span class="line">    ↓ 如果策略是ApplyOnOverlap</span><br><span class="line">调用ApplyEffectToTarget应用持续效果</span><br></pre></td></tr></table></figure></div>

<h4 id="2-OnEndOverlap函数实现"><a href="#2-OnEndOverlap函数实现" class="headerlink" title="2. OnEndOverlap函数实现"></a><strong>2. OnEndOverlap函数实现</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEffectActor::OnEndOverlap</span><span class="params">(AActor* TargetActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查即时效果：是否在结束重叠时应用</span></span><br><span class="line">    <span class="keyword">if</span> (InstantEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnEndOverlap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ApplyEffectToTarget</span>(TargetActor, InstantGameplayEffectClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查持续效果：是否在结束重叠时应用</span></span><br><span class="line">    <span class="keyword">if</span> (DurationEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnEndOverlap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ApplyEffectToTarget</span>(TargetActor, DurationGameplayEffectClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="执行逻辑-1"><a href="#执行逻辑-1" class="headerlink" title="执行逻辑"></a><strong>执行逻辑</strong></h5>  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">玩家离开碰撞区域（OnEndOverlap）：</span><br><span class="line">    ↓</span><br><span class="line">检查InstantEffectApplicationPolicy策略</span><br><span class="line">    ↓ 如果策略是ApplyOnEndOverlap</span><br><span class="line">调用ApplyEffectToTarget应用即时效果</span><br><span class="line">    ↓</span><br><span class="line">检查DurationEffectApplicationPolicy策略</span><br><span class="line">    ↓ 如果策略是ApplyOnEndOverlap</span><br><span class="line">调用ApplyEffectToTarget应用持续效果</span><br></pre></td></tr></table></figure></div>

<h4 id="3-策略组合示例"><a href="#3-策略组合示例" class="headerlink" title="3. 策略组合示例"></a><strong>3. 策略组合示例</strong></h4><h5 id="药水效果（进入时治疗）"><a href="#药水效果（进入时治疗）" class="headerlink" title="药水效果（进入时治疗）"></a><strong>药水效果（进入时治疗）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">InstantGameplayEffectClass = GE_HealthPotion</span><br><span class="line">InstantEffectApplicationPolicy = EEffectApplicationPolicy::ApplyOnOverlap  <span class="comment">// 进入时应用</span></span><br></pre></td></tr></table></figure></div>

<h5 id="陷阱效果（离开时伤害）"><a href="#陷阱效果（离开时伤害）" class="headerlink" title="陷阱效果（离开时伤害）"></a><strong>陷阱效果（离开时伤害）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DurationGameplayEffectClass = GE_PoisonTrap</span><br><span class="line">DurationEffectApplicationPolicy = EEffectApplicationPolicy::ApplyOnEndOverlap  <span class="comment">// 离开时应用</span></span><br></pre></td></tr></table></figure></div>

<h5 id="双向效果（进入和离开都有不同效果）"><a href="#双向效果（进入和离开都有不同效果）" class="headerlink" title="双向效果（进入和离开都有不同效果）"></a><strong>双向效果（进入和离开都有不同效果）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入时：获得加速效果</span></span><br><span class="line">DurationGameplayEffectClass = GE_SpeedBoost</span><br><span class="line">DurationEffectApplicationPolicy = EEffectApplicationPolicy::ApplyOnOverlap</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离开时：获得减速效果</span></span><br><span class="line">InstantGameplayEffectClass = GE_SlowDebuff</span><br><span class="line">InstantEffectApplicationPolicy = EEffectApplicationPolicy::ApplyOnEndOverlap</span><br></pre></td></tr></table></figure></div>

<h4 id="4-策略枚举使用说明"><a href="#4-策略枚举使用说明" class="headerlink" title="4. 策略枚举使用说明"></a><strong>4. 策略枚举使用说明</strong></h4><h5 id="EEffectApplicationPolicy-的三个值"><a href="#EEffectApplicationPolicy-的三个值" class="headerlink" title="EEffectApplicationPolicy 的三个值"></a><strong>EEffectApplicationPolicy 的三个值</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">ApplyOnOverlap:     <span class="comment">// 进入碰撞区域时应用</span></span><br><span class="line">ApplyOnEndOverlap:  <span class="comment">// 离开碰撞区域时应用  </span></span><br><span class="line">DoNotApply:         <span class="comment">// 不应用（默认值）</span></span><br></pre></td></tr></table></figure></div>

<h5 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a><strong>使用模式</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模式1：只进不出</span></span><br><span class="line">InstantEffectApplicationPolicy = ApplyOnOverlap</span><br><span class="line">DurationEffectApplicationPolicy = DoNotApply</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式2：只出不进</span></span><br><span class="line">InstantEffectApplicationPolicy = DoNotApply  </span><br><span class="line">DurationEffectApplicationPolicy = ApplyOnEndOverlap</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式3：进出都有</span></span><br><span class="line">InstantEffectApplicationPolicy = ApplyOnOverlap</span><br><span class="line">DurationEffectApplicationPolicy = ApplyOnEndOverlap</span><br></pre></td></tr></table></figure></div>

<h4 id="5-策略执行流程图"><a href="#5-策略执行流程图" class="headerlink" title="5. 策略执行流程图"></a><strong>5. 策略执行流程图</strong></h4>  <pre class="mermaid">  graph TD
      A[玩家进入碰撞区域] --> B{Instant策略检查}
      B -->|ApplyOnOverlap| C[应用即时效果]
      B -->|其他| D
      
      D --> E{Duration策略检查}
      E -->|ApplyOnOverlap| F[应用持续效果]
      E -->|其他| G[跳过]
      
      H[玩家离开碰撞区域] --> I{Instant策略检查}
      I -->|ApplyOnEndOverlap| J[应用即时效果]
      I -->|其他| K
      
      K --> L{Duration策略检查}
      L -->|ApplyOnEndOverlap| M[应用持续效果]
      L -->|其他| N[跳过]</pre>

<h4 id="6-与之前架构的对比"><a href="#6-与之前架构的对比" class="headerlink" title="6. 与之前架构的对比"></a><strong>6. 与之前架构的对比</strong></h4><h5 id="之前：固定行为"><a href="#之前：固定行为" class="headerlink" title="之前：固定行为"></a><strong>之前：固定行为</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧版本的OnOverlap：</span></span><br><span class="line"><span class="number">1.</span> 总是应用效果</span><br><span class="line"><span class="number">2.</span> 总是立即销毁Actor</span><br><span class="line"><span class="number">3.</span> 没有策略配置</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为固定，不可配置</span></span><br></pre></td></tr></table></figure></div>

<h5 id="现在：策略驱动"><a href="#现在：策略驱动" class="headerlink" title="现在：策略驱动"></a><strong>现在：策略驱动</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新版本的OnOverlap：</span></span><br><span class="line"><span class="number">1.</span> 根据策略决定是否应用</span><br><span class="line"><span class="number">2.</span> 可以配置不同时机（进入/离开）</span><br><span class="line"><span class="number">3.</span> 可以配置不同效果类型（Instant/Duration）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为可配置，更灵活</span></span><br></pre></td></tr></table></figure></div>

<p>  <strong>总结</strong>：这个实现为即时和持续效果添加了灵活的应用策略，可以根据配置在进入或离开碰撞区域时应用不同的效果。但还需要完善无限效果的处理逻辑。</p>
<p>- </p>
<p>  Infinite Effect Application and Removal</p>
<p>  28:37</p>
<h3 id="♾️-AuraEffectActor：无限效果应用与移除系统"><a href="#♾️-AuraEffectActor：无限效果应用与移除系统" class="headerlink" title="♾️ AuraEffectActor：无限效果应用与移除系统"></a>♾️ <strong>AuraEffectActor：无限效果应用与移除系统</strong></h3><h4 id="1-新增关键数据结构"><a href="#1-新增关键数据结构" class="headerlink" title="1. 新增关键数据结构"></a><strong>1. 新增关键数据结构</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储活动效果句柄和对应的ASC</span></span><br><span class="line">TMap&lt;FActiveGameplayEffectHandle, UAbilitySystemComponent*&gt; ActiveEffectHandles;</span><br></pre></td></tr></table></figure></div>

<h5 id="数据结构说明"><a href="#数据结构说明" class="headerlink" title="数据结构说明"></a><strong>数据结构说明</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TMap&lt;键类型, 值类型&gt;</span></span><br><span class="line"><span class="comment">// 键：FActiveGameplayEffectHandle - 活动GameplayEffect的唯一标识句柄</span></span><br><span class="line"><span class="comment">// 值：UAbilitySystemComponent* - 应用该效果的ASC</span></span><br></pre></td></tr></table></figure></div>

<h5 id="为什么需要这个映射"><a href="#为什么需要这个映射" class="headerlink" title="为什么需要这个映射"></a><strong>为什么需要这个映射</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 即时效果：应用后立即完成，不需要追踪</span></span><br><span class="line"><span class="comment">// 持续效果：自动过期，不需要追踪</span></span><br><span class="line"><span class="comment">// 无限效果：永久持续，需要存储句柄以便后续移除</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-头文件新增包含"><a href="#2-头文件新增包含" class="headerlink" title="2. 头文件新增包含"></a><strong>2. 头文件新增包含</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameplayEffect.h&quot;</span>  <span class="comment">// 新增包含，用于FActiveGameplayEffectHandle</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-变量重命名"><a href="#3-变量重命名" class="headerlink" title="3. 变量重命名"></a><strong>3. 变量重命名</strong></h4>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前：</span></span><br><span class="line">EEffectRemovalPolicy InfiniteGameplayRemovalPolicy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在：</span></span><br><span class="line">EEffectRemovalPolicy InfiniteEffectRemovalPolicy  <span class="comment">// 更一致的命名</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-无限效果的特殊性"><a href="#4-无限效果的特殊性" class="headerlink" title="4. 无限效果的特殊性"></a><strong>4. 无限效果的特殊性</strong></h4><h5 id="与其他效果类型的区别"><a href="#与其他效果类型的区别" class="headerlink" title="与其他效果类型的区别"></a><strong>与其他效果类型的区别</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 即时效果（Instant）：</span></span><br><span class="line"><span class="comment">// - 立即生效并结束</span></span><br><span class="line"><span class="comment">// - 不需要移除</span></span><br><span class="line"><span class="comment">// - 不需要存储句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续效果（Duration）：</span></span><br><span class="line"><span class="comment">// - 生效一段时间后自动结束</span></span><br><span class="line"><span class="comment">// - 自动移除</span></span><br><span class="line"><span class="comment">// - 不需要存储句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限效果（Infinite）：</span></span><br><span class="line"><span class="comment">// - 永久持续</span></span><br><span class="line"><span class="comment">// - 需要手动移除</span></span><br><span class="line"><span class="comment">// - 需要存储句柄以便后续移除</span></span><br></pre></td></tr></table></figure></div>

<h4 id="5-FActiveGameplayEffectHandle-的作用"><a href="#5-FActiveGameplayEffectHandle-的作用" class="headerlink" title="5. FActiveGameplayEffectHandle 的作用"></a><strong>5. FActiveGameplayEffectHandle 的作用</strong></h4><h5 id="什么是效果句柄"><a href="#什么是效果句柄" class="headerlink" title="什么是效果句柄"></a><strong>什么是效果句柄</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当应用GameplayEffect时，GAS返回一个句柄：</span></span><br><span class="line">FActiveGameplayEffectHandle Handle = ASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个句柄用于：</span></span><br><span class="line"><span class="number">1.</span> 唯一标识一个活动中的效果</span><br><span class="line"><span class="number">2.</span> 后续移除这个效果</span><br><span class="line"><span class="number">3.</span> 查询效果状态</span><br></pre></td></tr></table></figure></div>

<h5 id="句柄的特性"><a href="#句柄的特性" class="headerlink" title="句柄的特性"></a><strong>句柄的特性</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个活动效果都有唯一的句柄</span></span><br><span class="line"><span class="comment">// 即使相同的效果类，不同实例也有不同句柄</span></span><br><span class="line"><span class="comment">// 句柄在效果被移除后失效</span></span><br></pre></td></tr></table></figure></div>

<h4 id="6-ActiveEffectHandles-映射的使用"><a href="#6-ActiveEffectHandles-映射的使用" class="headerlink" title="6. ActiveEffectHandles 映射的使用"></a><strong>6. ActiveEffectHandles 映射的使用</strong></h4><h5 id="存储应用的效果"><a href="#存储应用的效果" class="headerlink" title="存储应用的效果"></a><strong>存储应用的效果</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用无限效果时：</span></span><br><span class="line">FActiveGameplayEffectHandle Handle = ASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(...);</span><br><span class="line">ActiveEffectHandles.<span class="built_in">Add</span>(Handle, ASC);  <span class="comment">// 存储句柄和ASC</span></span><br></pre></td></tr></table></figure></div>

<h5 id="移除效果时查找"><a href="#移除效果时查找" class="headerlink" title="移除效果时查找"></a><strong>移除效果时查找</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要移除效果时：</span></span><br><span class="line"><span class="comment">// 遍历ActiveEffectHandles查找对应的ASC和句柄</span></span><br><span class="line"><span class="comment">// 使用句柄移除效果</span></span><br><span class="line">ASC-&gt;<span class="built_in">RemoveActiveGameplayEffect</span>(Handle, <span class="number">1</span>);  <span class="comment">// 1表示移除所有堆叠层数</span></span><br></pre></td></tr></table></figure></div>

<h4 id="7-预期的实现逻辑"><a href="#7-预期的实现逻辑" class="headerlink" title="7. 预期的实现逻辑"></a><strong>7. 预期的实现逻辑</strong></h4><h5 id="OnOverlap中的无限效果处理"><a href="#OnOverlap中的无限效果处理" class="headerlink" title="OnOverlap中的无限效果处理"></a><strong>OnOverlap中的无限效果处理</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEffectActor::OnOverlap</span><span class="params">(AActor* TargetActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 已有的即时和持续效果逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增无限效果处理：</span></span><br><span class="line">    <span class="keyword">if</span> (InfiniteEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnOverlap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 应用无限效果</span></span><br><span class="line">        FActiveGameplayEffectHandle Handle = <span class="built_in">ApplyEffectToTarget</span>(TargetActor, InfiniteGameplayEffectClass);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果应用成功，存储句柄</span></span><br><span class="line">        <span class="keyword">if</span> (Handle.<span class="built_in">IsValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            UAbilitySystemComponent* TargetASC = <span class="built_in">GetASCFromActor</span>(TargetActor);</span><br><span class="line">            ActiveEffectHandles.<span class="built_in">Add</span>(Handle, TargetASC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="OnEndOverlap中的无限效果移除"><a href="#OnEndOverlap中的无限效果移除" class="headerlink" title="OnEndOverlap中的无限效果移除"></a><strong>OnEndOverlap中的无限效果移除</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEffectActor::OnEndOverlap</span><span class="params">(AActor* TargetActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 已有的即时和持续效果逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增无限效果移除：</span></span><br><span class="line">    <span class="keyword">if</span> (InfiniteEffectRemovalPolicy == EEffectRemovalPolicy::RemoveOnEndOverlap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查找并移除该目标的所有无限效果</span></span><br><span class="line">        <span class="built_in">RemoveInfiniteEffectsFromTarget</span>(TargetActor);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要，销毁Actor</span></span><br><span class="line">        <span class="keyword">if</span> (bDestroyOnEffectRemoval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="6-无限效果应用场景示例"><a href="#6-无限效果应用场景示例" class="headerlink" title="6. 无限效果应用场景示例"></a><strong>6. 无限效果应用场景示例</strong></h4><h5 id="光环效果（进入区域获得，离开区域失去）"><a href="#光环效果（进入区域获得，离开区域失去）" class="headerlink" title="光环效果（进入区域获得，离开区域失去）"></a><strong>光环效果（进入区域获得，离开区域失去）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">InfiniteGameplayEffectClass = GE_RegenerationAura      <span class="comment">// 恢复光环</span></span><br><span class="line">InfiniteEffectApplicationPolicy = ApplyOnOverlap       <span class="comment">// 进入时应用</span></span><br><span class="line">InfiniteEffectRemovalPolicy = RemoveOnEndOverlap       <span class="comment">// 离开时移除</span></span><br><span class="line">bDestroyOnEffectRemoval = <span class="literal">false</span>                        <span class="comment">// Actor不销毁，可重复使用</span></span><br></pre></td></tr></table></figure></div>

<h5 id="永久增益（一次性应用，不自动移除）"><a href="#永久增益（一次性应用，不自动移除）" class="headerlink" title="永久增益（一次性应用，不自动移除）"></a><strong>永久增益（一次性应用，不自动移除）</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">InfiniteGameplayEffectClass = GE_PermanentStrengthBuff  <span class="comment">// 永久力量增益</span></span><br><span class="line">InfiniteEffectApplicationPolicy = ApplyOnOverlap        <span class="comment">// 进入时应用</span></span><br><span class="line">InfiniteEffectRemovalPolicy = DoNotRemove               <span class="comment">// 不移除，永久生效</span></span><br><span class="line">bDestroyOnEffectRemoval = <span class="literal">true</span>                          <span class="comment">// 应用后销毁Actor</span></span><br></pre></td></tr></table></figure></div>

<h4 id="9-设计优势"><a href="#9-设计优势" class="headerlink" title="9. 设计优势"></a><strong>9. 设计优势</strong></h4><h5 id="灵活的效果管理"><a href="#灵活的效果管理" class="headerlink" title="灵活的效果管理"></a><strong>灵活的效果管理</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以同时管理多个目标的多个无限效果</span></span><br><span class="line"><span class="comment">// 可以精准控制每个效果的移除时机</span></span><br><span class="line"><span class="comment">// 支持复杂的叠加和移除逻辑</span></span><br></pre></td></tr></table></figure></div>

<h5 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a><strong>资源管理</strong></h5>  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过bDestroyOnEffectRemoval控制Actor生命周期</span></span><br><span class="line"><span class="comment">// 避免内存泄漏：及时移除不需要的效果句柄</span></span><br><span class="line"><span class="comment">// 支持效果的重用和共享</span></span><br></pre></td></tr></table></figure></div>


<p>  <strong>总结</strong>：这个扩展为AuraEffectActor添加了完整的无限效果管理系统，通过<code>TMap</code>存储效果句柄，实现了精确的效果应用、追踪和移除功能。现在支持三种完整的效果类型，每种都有独立的策略配置。</p>
<p>- </p>
<p>  PreAttributeChange</p>
<p>  12:16</p>
<p>- </p>
<p>  PostGameplayEffectExecute</p>
<p>  30:57</p>
<p>- </p>
<p>  Curve Tables for Scalable Floats</p>
<p>  15:19</p>
<h2 id="6-Gameplay-Tags-游戏标签"><a href="#6-Gameplay-Tags-游戏标签" class="headerlink" title="6.Gameplay Tags &#x2F; 游戏标签"></a>6.Gameplay Tags &#x2F; 游戏标签</h2><ul>
<li><p>16 个讲座·3 小时 23 分钟 &#x2F; 16 Lectures · 3 Hours 23 Minutes</p>
</li>
<li><p>Gameplay Tags</p>
<p>05:55</p>
</li>
<li><p>Creating Gameplay Tags in the Editor</p>
<p>07:42</p>
</li>
<li><p>Creating Gameplay Tags from Data Tables</p>
<p>06:22</p>
</li>
<li><p>Adding Gameplay Tags to Gameplay Effects</p>
<p>00:15</p>
</li>
<li><p>Apply Gameplay Tags with Effects</p>
<p>18:18</p>
</li>
<li><p>Gameplay Effect Delegates</p>
<p>12:46</p>
</li>
<li><p>Get All Asset Tags</p>
<p>10:34</p>
</li>
<li><p>Broadcasting Effect Asset Tags</p>
<p>10:03</p>
</li>
<li><p>UI Widget Data Table</p>
<p>12:40</p>
</li>
<li><p>Retrieving Rows from Data Tables</p>
<p>16:17</p>
</li>
<li><p>Broadcasting Data Table Rows</p>
<p>15:49</p>
</li>
<li><p>Message Widget</p>
<p>15:24</p>
</li>
<li><p>Animating the Message Widget</p>
<p>17:38</p>
</li>
<li><p>Replacing Callbacks with Lambdas</p>
<p>09:44</p>
</li>
<li><p>Ghost Globe</p>
<p>33:43</p>
</li>
<li><p>Properly Clamping Attributes</p>
<p>09:41</p>
</li>
</ul>
<h2 id="7-RPG-Attributes-RPG属性"><a href="#7-RPG-Attributes-RPG属性" class="headerlink" title="7.RPG Attributes &#x2F; RPG属性"></a>7.RPG Attributes &#x2F; RPG属性</h2><ul>
<li><p>11个讲座·2 小时 48 分钟 &#x2F; 11 Lectures · 2 Hours 48 Minutes</p>
</li>
<li><p>Initialize Attributes from a Data Table</p>
<p>14:44</p>
</li>
<li><p>Initialize Attributes with Gameplay Effects</p>
<p>15:52</p>
</li>
<li><p>Attribute Based Modifiers</p>
<p>09:09</p>
</li>
<li><p>Modifier Order of Operations</p>
<p>11:08</p>
</li>
<li><p>Modifier Coefficients</p>
<p>06:54</p>
</li>
<li><p>Secondary Attributes</p>
<p>13:47</p>
</li>
<li><p>Derived Attributes</p>
<p>31:39</p>
</li>
<li><p>Custom Calculations</p>
<p>06:14</p>
</li>
<li><p>Player Level and Combat Interface</p>
<p>13:07</p>
</li>
<li><p>Modifier Magnitude Calculations</p>
<p>37:27</p>
</li>
<li><p>Initializing Vital Attributes</p>
<p>07:47</p>
</li>
</ul>
<h2 id="8-Attribute-Menu-属性菜单"><a href="#8-Attribute-Menu-属性菜单" class="headerlink" title="8.Attribute Menu &#x2F; 属性菜单"></a>8.Attribute Menu &#x2F; 属性菜单</h2><ul>
<li><p>21个讲座·4 小时 42 分钟 &#x2F; 21 Lectures · 4 Hours 42 Minutes</p>
</li>
<li><p>Attribute Menu - Game Plan</p>
<p>05:20</p>
</li>
<li><p>Attribute Menu - Framed Value</p>
<p>11:08</p>
</li>
<li><p>Attribute Menu - Text Value Row</p>
<p>08:28</p>
</li>
<li><p>Attribute Menu - Text Value Button Row</p>
<p>06:43</p>
</li>
<li><p>Attribute Menu - Construction</p>
<p>18:43</p>
</li>
<li><p>Button Widget</p>
<p>21:34</p>
</li>
<li><p>Wide Button Widget</p>
<p>09:19</p>
</li>
<li><p>Opening the Attribute Menu</p>
<p>07:06</p>
</li>
<li><p>Closing the Attribute Menu</p>
<p>05:40</p>
</li>
<li><p>Plan for Displaying Attribute Data</p>
<p>10:07</p>
</li>
<li><p>Gameplay Tags Singleton</p>
<p>09:52</p>
</li>
<li><p>Aura Asset Manager</p>
<p>14:48</p>
</li>
<li><p>Native Gameplay Tags</p>
<p>09:10</p>
</li>
<li><p>Attribute Info Data Asset</p>
<p>15:46</p>
</li>
<li><p>Attribute Menu Widget Controller</p>
<p>05:17</p>
</li>
<li><p>Aura Ability System Blueprint Library</p>
<p>15:05</p>
</li>
<li><p>Constructing the Attribute Menu Widget Controller</p>
<p>17:07</p>
</li>
<li><p>Attribute Info Delegate</p>
<p>20:30</p>
</li>
<li><p>Widget Attribute Tags</p>
<p>16:01</p>
</li>
<li><p>Mapping Tags to Attributes</p>
<p>37:58</p>
</li>
<li><p>Responding to Attribute Changes</p>
<p>16:07</p>
</li>
</ul>
<h2 id="9-Gameplay-Abilities-游戏技能"><a href="#9-Gameplay-Abilities-游戏技能" class="headerlink" title="9.Gameplay Abilities &#x2F; 游戏技能"></a>9.Gameplay Abilities &#x2F; 游戏技能</h2><ul>
<li><p>15 个讲座·3 小时 56 分钟 &#x2F; 15 Lectures · 3 Hours 56 Minutes</p>
</li>
<li><p>Gameplay Abilities</p>
<p>05:09</p>
</li>
<li><p>Granting Abilities</p>
<p>15:07</p>
</li>
<li><p>Settings on Gameplay Abilities</p>
<p>18:31</p>
</li>
<li><p>Input Config Data Asset</p>
<p>22:19</p>
</li>
<li><p>Aura Input Component</p>
<p>14:52</p>
</li>
<li><p>Callbacks for Ability Input</p>
<p>12:46</p>
</li>
<li><p>Activating Abilities</p>
<p>27:22</p>
</li>
<li><p>Click To Move</p>
<p>16:23</p>
</li>
<li><p>Setting Up Click to Move</p>
<p>18:17</p>
</li>
<li><p>Setting Up Auto Running</p>
<p>11:48</p>
</li>
<li><p>Implementing Auto Running</p>
<p>11:42</p>
</li>
<li><p>Code Clean Up</p>
<p>11:29</p>
</li>
<li><p>Aura Projectile</p>
<p>14:25</p>
</li>
<li><p>Aura Projectile Spell</p>
<p>13:37</p>
</li>
<li><p>Spawning Projectiles</p>
<p>22:33</p>
</li>
</ul>
<h2 id="10-Ability-Tasks-技能任务"><a href="#10-Ability-Tasks-技能任务" class="headerlink" title="10.Ability Tasks &#x2F; 技能任务"></a>10.Ability Tasks &#x2F; 技能任务</h2><ul>
<li><p>15 个讲座·3 小时 53 分钟 &#x2F; 15 Lectures · 3 Hours 53 Minutes</p>
</li>
<li><p>Ability Tasks</p>
<p>16:54</p>
</li>
<li><p>Sending Gameplay Events</p>
<p>10:38</p>
</li>
<li><p>Spawn FireBolt from Event</p>
<p>05:50</p>
</li>
<li><p>Custom Ability Tasks</p>
<p>20:18</p>
</li>
<li><p>Target Data</p>
<p>06:10</p>
</li>
<li><p>Send Mouse Cursor Data</p>
<p>13:42</p>
</li>
<li><p>Receiving Target Data</p>
<p>16:11</p>
</li>
<li><p>Prediction in GAS</p>
<p>10:53</p>
</li>
<li><p>Orienting the Projectile</p>
<p>16:55</p>
</li>
<li><p>Motion Warping</p>
<p>15:16</p>
</li>
<li><p>Projectile Impact</p>
<p>16:05</p>
</li>
<li><p>Projectile Collision Channel</p>
<p>09:31</p>
</li>
<li><p>Projectile Gameplay Effect</p>
<p>23:42</p>
</li>
<li><p>Enemy Health Bar</p>
<p>30:23</p>
</li>
<li><p>Ghost Bar</p>
<p>20:56</p>
</li>
</ul>
<h2 id="11-RPG-Character-Classes-RPG角色职业"><a href="#11-RPG-Character-Classes-RPG角色职业" class="headerlink" title="11.RPG Character Classes &#x2F; RPG角色职业"></a>11.RPG Character Classes &#x2F; RPG角色职业</h2><ul>
<li><p>5 个讲座·1小时 11分钟 &#x2F; 5 Lectures · 1 Hour 11 Minutes</p>
</li>
<li><p>RPG Character Classes</p>
<p>06:24</p>
</li>
<li><p>Character Class Info</p>
<p>07:27</p>
</li>
<li><p>Default Attribute Effects</p>
<p>04:28</p>
</li>
<li><p>Curve Tables - CSV and JSON</p>
<p>29:52</p>
</li>
<li><p>Initializing Enemy Attributes</p>
<p>22:40</p>
</li>
</ul>
<h2 id="12-Damage-伤害"><a href="#12-Damage-伤害" class="headerlink" title="12.Damage &#x2F; 伤害"></a>12.Damage &#x2F; 伤害</h2><ul>
<li><p>17个讲座·4 小时 32 分钟 &#x2F; 17 Lectures · 4 Hours 32 Minutes</p>
</li>
<li><p>Meta Attributes</p>
<p>04:29</p>
</li>
<li><p>Damage Meta Attribute</p>
<p>08:44</p>
</li>
<li><p>Set By Caller Magnitude</p>
<p>07:37</p>
</li>
<li><p>Ability Damage</p>
<p>14:46</p>
</li>
<li><p>Enemy Hit React</p>
<p>26:52</p>
</li>
<li><p>Activating the Enemy Hit React Ability</p>
<p>17:32</p>
</li>
<li><p>Enemy Death</p>
<p>12:49</p>
</li>
<li><p>Dissolve Effect</p>
<p>22:19</p>
</li>
<li><p>Floating Text Widget</p>
<p>15:03</p>
</li>
<li><p>Showing Damage Text</p>
<p>25:24</p>
</li>
<li><p>Execution Calculations</p>
<p>06:29</p>
</li>
<li><p>Damage Execution Calculation</p>
<p>08:39</p>
</li>
<li><p>ExecCalcs - Capturing Attributes</p>
<p>28:27</p>
</li>
<li><p>Implementing Block Chance</p>
<p>18:30</p>
</li>
<li><p>Implementing Armor and Armor Penetration</p>
<p>12:25</p>
</li>
<li><p>Damage Calculation Coefficients</p>
<p>24:57</p>
</li>
<li><p>Implementing Critical Hits</p>
<p>17:23</p>
</li>
</ul>
<h2 id="13-Advanced-Damage-Techniques-高级伤害技术"><a href="#13-Advanced-Damage-Techniques-高级伤害技术" class="headerlink" title="13.Advanced Damage Techniques &#x2F; 高级伤害技术"></a>13.Advanced Damage Techniques &#x2F; 高级伤害技术</h2><ul>
<li><p>14 个讲座·4 小时16 分钟 &#x2F; 14 Lectures · 4 Hours 16 Minutes</p>
</li>
<li><p>The Gameplay Effect Context</p>
<p>34:48</p>
</li>
<li><p>Custom Gameplay Effect Context</p>
<p>14:24</p>
</li>
<li><p>NetSerialize</p>
<p>27:41</p>
</li>
<li><p>Implementing Net Serialize</p>
<p>07:23</p>
</li>
<li><p>Struct Ops Type Traits</p>
<p>07:46</p>
</li>
<li><p>Aura Ability System Globals</p>
<p>11:17</p>
</li>
<li><p>Using a Custom Effect Context</p>
<p>23:00</p>
</li>
<li><p>Floating Text Color</p>
<p>19:23</p>
</li>
<li><p>Hit Message</p>
<p>16:17</p>
</li>
<li><p>Damage Types</p>
<p>20:25</p>
</li>
<li><p>Mapping Damage Types to Resistances</p>
<p>10:23</p>
</li>
<li><p>Resistance Attributes</p>
<p>21:30</p>
</li>
<li><p>Resistance Damage Reduction</p>
<p>17:42</p>
</li>
<li><p>Multiplayer Test</p>
<p>23:59</p>
</li>
</ul>
<h2 id="14-Enemy-AI-敌人AI"><a href="#14-Enemy-AI-敌人AI" class="headerlink" title="14.Enemy AI &#x2F; 敌人AI"></a>14.Enemy AI &#x2F; 敌人AI</h2><ul>
<li><p>14 个讲座·2 小时 33 分钟 &#x2F; 14 Lectures · 2 Hours 33 Minutes</p>
</li>
<li><p>Enemy AI Setup</p>
<p>04:43</p>
</li>
<li><p>AI Controller Blackboard and Behavior Tree</p>
<p>15:41</p>
</li>
<li><p>Behavior Tree Service</p>
<p>10:25</p>
</li>
<li><p>Blackboard Keys</p>
<p>13:40</p>
</li>
<li><p>Finding the Nearest Player</p>
<p>09:10</p>
</li>
<li><p>AI and Effect Actors</p>
<p>15:12</p>
</li>
<li><p>Behavior Tree Decorators</p>
<p>18:39</p>
</li>
<li><p>Attack Behavior Tree Task</p>
<p>10:33</p>
</li>
<li><p>Find New Location Around Target</p>
<p>14:43</p>
</li>
<li><p>Environment Query System</p>
<p>03:24</p>
</li>
<li><p>Environment Queries</p>
<p>09:29</p>
</li>
<li><p>EQS Tests</p>
<p>09:59</p>
</li>
<li><p>Distance Test</p>
<p>05:21</p>
</li>
<li><p>Using EQS Queries in Behavior Trees</p>
<p>11:44</p>
</li>
</ul>
<h2 id="15-Enemy-Melee-Attacks-敌人近战攻击"><a href="#15-Enemy-Melee-Attacks-敌人近战攻击" class="headerlink" title="15.Enemy Melee Attacks &#x2F; 敌人近战攻击"></a>15.Enemy Melee Attacks &#x2F; 敌人近战攻击</h2><ul>
<li><p>13 个讲座·3 小时8分钟 &#x2F; 13 Lectures · 3 Hours 8 Minutes</p>
</li>
<li><p>Melee Attack Ability</p>
<p>24:41</p>
</li>
<li><p>Attack Montage</p>
<p>08:05</p>
</li>
<li><p>Combat Target</p>
<p>15:16</p>
</li>
<li><p>Melee Attack Gameplay Event</p>
<p>16:12</p>
</li>
<li><p>Get Live Players Within Radius</p>
<p>32:07</p>
</li>
<li><p>Causing Melee Damage</p>
<p>15:31</p>
</li>
<li><p>Multiplayer Melee Test</p>
<p>03:13</p>
</li>
<li><p>Montage Gameplay Tags</p>
<p>07:26</p>
</li>
<li><p>Tagged Montage</p>
<p>09:36</p>
</li>
<li><p>Multiple Attack Sockets</p>
<p>09:10</p>
</li>
<li><p>Ghoul Enemy</p>
<p>11:58</p>
</li>
<li><p>Ghoul Attack Montages</p>
<p>12:49</p>
</li>
<li><p>Melee Polish</p>
<p>21:56</p>
</li>
</ul>
<h2 id="16-Enemy-Ranged-Attacks-敌人远程攻击"><a href="#16-Enemy-Ranged-Attacks-敌人远程攻击" class="headerlink" title="16.Enemy Ranged Attacks &#x2F; 敌人远程攻击"></a>16.Enemy Ranged Attacks &#x2F; 敌人远程攻击</h2><ul>
<li><p>9 个讲座·1小时 15 分钟 &#x2F; 9 Lectures · 1 Hour 15 Minutes</p>
</li>
<li><p>Ranged Attack</p>
<p>06:50</p>
</li>
<li><p>Rock Projectile</p>
<p>03:21</p>
</li>
<li><p>Ranged Damage Curve</p>
<p>03:47</p>
</li>
<li><p>Granting Ranged Attacks</p>
<p>02:51</p>
</li>
<li><p>Slingshot Attack Montage</p>
<p>05:20</p>
</li>
<li><p>Playing the Ranged Attack Montage</p>
<p>13:53</p>
</li>
<li><p>Spawning the Rock Projectile</p>
<p>14:03</p>
</li>
<li><p>Slingshot Animation Blueprint</p>
<p>11:40</p>
</li>
<li><p>Slingshot Attack Montage</p>
<p>13:11</p>
</li>
</ul>
<h2 id="17-Enemy-Spell-Attacks-敌人法术攻击"><a href="#17-Enemy-Spell-Attacks-敌人法术攻击" class="headerlink" title="17.Enemy Spell Attacks &#x2F; 敌人法术攻击"></a>17.Enemy Spell Attacks &#x2F; 敌人法术攻击</h2><ul>
<li><p>5个讲座·38 分钟 &#x2F; 5 Lectures · 38 Minutes</p>
</li>
<li><p>Goblin Shaman</p>
<p>07:31</p>
</li>
<li><p>Shaman Attack Montage</p>
<p>04:06</p>
</li>
<li><p>Shaman Attack Ability</p>
<p>10:33</p>
</li>
<li><p>Dead Blackboard Key</p>
<p>07:18</p>
</li>
<li><p>Enemies Multiplayer Testing</p>
<p>08:48</p>
</li>
</ul>
<h2 id="18-Enemy-Finishing-Touches-敌人最终完善"><a href="#18-Enemy-Finishing-Touches-敌人最终完善" class="headerlink" title="18.Enemy Finishing Touches &#x2F; 敌人最终完善"></a>18.Enemy Finishing Touches &#x2F; 敌人最终完善</h2><ul>
<li><p>26 个讲座·4 小时 33 分钟 &#x2F; 26 Lectures · 4 Hours 33 Minutes</p>
</li>
<li><p>Goblin Spear - Sound Notifies</p>
<p>06:19</p>
</li>
<li><p>Impact Effects</p>
<p>16:35</p>
</li>
<li><p>Melee Impact Gameplay Cue</p>
<p>18:58</p>
</li>
<li><p>Montage and Socket Tags</p>
<p>22:13</p>
</li>
<li><p>Goblin Spear - Hurt and Death Sounds</p>
<p>07:19</p>
</li>
<li><p>Goblin Slingshot - Sound Notifies</p>
<p>04:31</p>
</li>
<li><p>Rock Impact Effects</p>
<p>07:01</p>
</li>
<li><p>Goblin Shaman - Sound Notifies</p>
<p>04:11</p>
</li>
<li><p>Ghoul - Sound Notifies</p>
<p>10:21</p>
</li>
<li><p>Ghoul - Swipe Trail</p>
<p>04:48</p>
</li>
<li><p>Demon Blueprint</p>
<p>05:55</p>
</li>
<li><p>Demon Melee Attack</p>
<p>14:50</p>
</li>
<li><p>Demon Ranged Attack</p>
<p>11:04</p>
</li>
<li><p>Demon - Sound Notifies</p>
<p>09:43</p>
</li>
<li><p>Demon - Dissolve Effect</p>
<p>01:56</p>
</li>
<li><p>Shaman Summon Locations</p>
<p>28:23</p>
</li>
<li><p>Async Spawn Times</p>
<p>10:34</p>
</li>
<li><p>Summoning Particle Effect</p>
<p>04:54</p>
</li>
<li><p>Select Minion Class at Random</p>
<p>06:01</p>
</li>
<li><p>Minion Summon Montage</p>
<p>05:48</p>
</li>
<li><p>Minion Count</p>
<p>07:34</p>
</li>
<li><p>Elementalist Behavior Tree</p>
<p>09:35</p>
</li>
<li><p>Elementalist Attack Task</p>
<p>14:11</p>
</li>
<li><p>Decrementing Minion Count</p>
<p>12:18</p>
</li>
<li><p>Adding Juice with Tweening</p>
<p>08:25</p>
</li>
<li><p>Enemies Final Polish</p>
<p>19:42</p>
</li>
</ul>
<h2 id="19-Level-Tweaks-关卡调整"><a href="#19-Level-Tweaks-关卡调整" class="headerlink" title="19.Level Tweaks &#x2F; 关卡调整"></a>19.Level Tweaks &#x2F; 关卡调整</h2><ul>
<li><p>5 个讲座·1小时 54 分钟 &#x2F; 5 Lectures · 1 Hour 54 Minutes</p>
</li>
<li><p>Level Lighting and Post Process</p>
<p>28:39</p>
</li>
<li><p>Texture Streaming Pool Over Budget</p>
<p>20:41</p>
</li>
<li><p>Flame Pillar Actor</p>
<p>13:23</p>
</li>
<li><p>Fade Actor</p>
<p>24:49</p>
</li>
<li><p>Fading Out Obstructing Geometry</p>
<p>26:00</p>
</li>
</ul>
<h2 id="20-Cost-and-Cooldown-消耗与冷却"><a href="#20-Cost-and-Cooldown-消耗与冷却" class="headerlink" title="20.Cost and Cooldown &#x2F; 消耗与冷却"></a>20.Cost and Cooldown &#x2F; 消耗与冷却</h2><ul>
<li><p>14 个讲座·3 小时 48 分钟 &#x2F; 14 Lectures · 3 Hours 48 Minutes</p>
</li>
<li><p>Health Mana Spells Widget</p>
<p>16:19</p>
</li>
<li><p>Spell Globe</p>
<p>20:04</p>
</li>
<li><p>Adding Spell Globes</p>
<p>15:21</p>
</li>
<li><p>XP Bar</p>
<p>10:25</p>
</li>
<li><p>Ability Info Data Asset</p>
<p>20:01</p>
</li>
<li><p>Initialize Overlay Startup Abilities</p>
<p>13:26</p>
</li>
<li><p>For Each Ability Delegate</p>
<p>19:46</p>
</li>
<li><p>Binding Widget Events to the Ability Info Delegate</p>
<p>18:55</p>
</li>
<li><p>Gameplay Ability Cost</p>
<p>12:29</p>
</li>
<li><p>Gameplay Ability Cooldown</p>
<p>09:22</p>
</li>
<li><p>Cooldown Async Task</p>
<p>38:18</p>
</li>
<li><p>Cooldown Tags in Ability Info</p>
<p>06:58</p>
</li>
<li><p>Showing Cooldown Time in the HUD</p>
<p>13:43</p>
</li>
<li><p>Modeling Mode</p>
<p>13:02</p>
</li>
</ul>
<h2 id="21-Experience-and-Leveling-Up-经验与升级"><a href="#21-Experience-and-Leveling-Up-经验与升级" class="headerlink" title="21.Experience and Leveling Up &#x2F; 经验与升级"></a>21.Experience and Leveling Up &#x2F; 经验与升级</h2><ul>
<li><p>15 个讲座·3 小时 54 分钟 &#x2F; 15 Lectures · 3 Hours 54 Minutes</p>
</li>
<li><p>Experience and Leveling Up</p>
<p>14:03</p>
</li>
<li><p>Level Up Info Data Asset</p>
<p>16:10</p>
</li>
<li><p>Adding XP to the Player State</p>
<p>11:05</p>
</li>
<li><p>Listening for XP Changes</p>
<p>17:55</p>
</li>
<li><p>Awarding XP Game Plan</p>
<p>06:51</p>
</li>
<li><p>XP Reward for Enemies</p>
<p>16:36</p>
</li>
<li><p>Incoming XP Meta Attribute</p>
<p>04:13</p>
</li>
<li><p>Passively Listening for Events</p>
<p>18:38</p>
</li>
<li><p>Sending XP Events</p>
<p>14:40</p>
</li>
<li><p>Showing XP in the HUD</p>
<p>14:51</p>
</li>
<li><p>Level Up Interface Function</p>
<p>16:59</p>
</li>
<li><p>Leveling Up</p>
<p>21:56</p>
</li>
<li><p>Showing Level in the HUD</p>
<p>24:37</p>
</li>
<li><p>Level Up Niagara System</p>
<p>17:02</p>
</li>
<li><p>Level Up HUD Message</p>
<p>18:17</p>
</li>
</ul>
<h2 id="22-Attribute-Points-属性点"><a href="#22-Attribute-Points-属性点" class="headerlink" title="22.Attribute Points &#x2F; 属性点"></a>22.Attribute Points &#x2F; 属性点</h2><ul>
<li><p>6 个讲座·1小时 15 分钟 &#x2F; 6 Lectures · 1 Hour 15 Minutes</p>
</li>
<li><p>Attribute Points Member Variable</p>
<p>09:11</p>
</li>
<li><p>Showing Attribute Points in the HUD</p>
<p>08:25</p>
</li>
<li><p>Attribute Upgrade Buttons</p>
<p>08:34</p>
</li>
<li><p>Upgrading Attributes</p>
<p>18:43</p>
</li>
<li><p>Top Off Our Fluids</p>
<p>14:12</p>
</li>
<li><p>Attribute Menu Polish</p>
<p>16:08</p>
</li>
</ul>
<h2 id="23-Spell-Menu-法术菜单"><a href="#23-Spell-Menu-法术菜单" class="headerlink" title="23.Spell Menu &#x2F; 法术菜单"></a>23.Spell Menu &#x2F; 法术菜单</h2><ul>
<li><p>23 个讲座·5 小时 45 分钟 &#x2F; 23 Lectures · 5 Hours 45 Minutes</p>
</li>
<li><p>Spell Menu Design</p>
<p>06:00</p>
</li>
<li><p>Spell Globe Button</p>
<p>13:10</p>
</li>
<li><p>Offensive Spell Tree</p>
<p>11:45</p>
</li>
<li><p>Passive Spell Tree</p>
<p>09:19</p>
</li>
<li><p>Equipped Spell Row</p>
<p>16:57</p>
</li>
<li><p>Spell Menu Widget</p>
<p>19:52</p>
</li>
<li><p>Spell Description Box</p>
<p>12:05</p>
</li>
<li><p>Spell Menu Button</p>
<p>24:29</p>
</li>
<li><p>Spell Menu Widget Controller</p>
<p>28:45</p>
</li>
<li><p>Constructing the Spell Menu Widget Controller</p>
<p>21:46</p>
</li>
<li><p>Equipped Row Button</p>
<p>26:05</p>
</li>
<li><p>Ability Status and Type</p>
<p>13:33</p>
</li>
<li><p>Showing Abilities in the Spell Tree</p>
<p>24:07</p>
</li>
<li><p>Ability Level Requirement</p>
<p>12:09</p>
</li>
<li><p>Update Ability Statuses</p>
<p>12:34</p>
</li>
<li><p>Updating Status in the Spell Menu</p>
<p>14:07</p>
</li>
<li><p>Show Spell Points</p>
<p>10:10</p>
</li>
<li><p>Selecting Icons</p>
<p>12:12</p>
</li>
<li><p>Deselecting Icons</p>
<p>07:01</p>
</li>
<li><p>Spell Menu Buttons</p>
<p>39:22</p>
</li>
<li><p>Selected Ability</p>
<p>12:14</p>
</li>
<li><p>Spending Spell Points</p>
<p>29:55</p>
</li>
<li><p>Rich Text Blocks</p>
<p>12:59</p>
</li>
<li><p>Spell Descriptions</p>
<p>19:26</p>
</li>
<li><p>FireBolt Description</p>
<p>12:37</p>
</li>
<li><p>Cost and Cooldown in Spell Description</p>
<p>33:40</p>
</li>
<li><p>Self Deselect</p>
<p>11:17</p>
</li>
<li><p>Equipped Spell Row Animations</p>
<p>17:33</p>
</li>
<li><p>Ability Types</p>
<p>22:47</p>
</li>
<li><p>Equipping Abilities</p>
<p>42:03</p>
</li>
<li><p>Updating the Overlay When Equipping Abilities</p>
<p>09:52</p>
</li>
<li><p>Globe Reassigned</p>
<p>07:11</p>
</li>
<li><p>Unbinding Delegates</p>
<p>05:38</p>
</li>
</ul>
<h2 id="24-Combat-Tricks-战斗技巧"><a href="#24-Combat-Tricks-战斗技巧" class="headerlink" title="24.Combat Tricks &#x2F; 战斗技巧"></a>24.Combat Tricks &#x2F; 战斗技巧</h2><ul>
<li><p>15 个讲座·3 小时 42 分钟 &#x2F; 15 Lectures · 3 Hours 42 Minutes</p>
</li>
<li><p>Debuff Tags</p>
<p>17:45</p>
</li>
<li><p>Debuff Parameters</p>
<p>06:16</p>
</li>
<li><p>Damage Effect Params Struct</p>
<p>24:36</p>
</li>
<li><p>Using Damage Effect Params</p>
<p>14:27</p>
</li>
<li><p>Determining Debuff</p>
<p>23:40</p>
</li>
<li><p>Debuff Info in the Effect Context</p>
<p>18:51</p>
</li>
<li><p>Debuff in the Attribute Set</p>
<p>15:16</p>
</li>
<li><p>Dynamic Gameplay Effects</p>
<p>24:36</p>
</li>
<li><p>Debuff Niagara Component</p>
<p>26:40</p>
</li>
<li><p>Death Impulse Magnitude</p>
<p>05:25</p>
</li>
<li><p>Death Impulse in the Effect Context</p>
<p>12:30</p>
</li>
<li><p>Handling Death Impulse</p>
<p>18:56</p>
</li>
<li><p>Knockback</p>
<p>35:08</p>
</li>
</ul>
<h2 id="25-What-a-Shock-震惊法术（示例）"><a href="#25-What-a-Shock-震惊法术（示例）" class="headerlink" title="25.What a Shock &#x2F; 震惊法术（示例）"></a>25.What a Shock &#x2F; 震惊法术（示例）</h2><ul>
<li><p>17 个讲座·4 小时 53 分钟 &#x2F; 17 Lectures · 4 Hours 53 Minutes</p>
</li>
<li><p>FireBolt Projectile Spread</p>
<p>28:39</p>
</li>
<li><p>Spawning Multiple Projectiles</p>
<p>15:28</p>
</li>
<li><p>Homing Projectiles</p>
<p>21:10</p>
</li>
<li><p>Click Niagara System</p>
<p>03:41</p>
</li>
<li><p>Invoke Replicated Event</p>
<p>24:30</p>
</li>
<li><p>Aura Beam Spell</p>
<p>16:37</p>
</li>
<li><p>Electrocute Montage</p>
<p>21:24</p>
</li>
<li><p>Player Block Tags</p>
<p>13:58</p>
</li>
<li><p>GameplayCue Notify Paths</p>
<p>13:38</p>
</li>
<li><p>Gameplay Cue Notify Actor</p>
<p>19:13</p>
</li>
<li><p>Electrocute Looping Sound</p>
<p>06:18</p>
</li>
<li><p>Target Trace Channel</p>
<p>09:37</p>
</li>
<li><p>First Trace Target</p>
<p>28:39</p>
</li>
<li><p>Additional Targets</p>
<p>23:37</p>
</li>
<li><p>Shock Loop Cues on Additional Targets</p>
<p>16:16</p>
</li>
<li><p>Electrocute Cost Cooldown and Damage</p>
<p>08:54</p>
</li>
<li><p>Applying Electrocute Cost and Damage</p>
<p>14:20</p>
</li>
<li><p>Electrocute Polish</p>
<p>24:50</p>
</li>
<li><p>Explode Dem FireBoltz</p>
<p>07:36</p>
</li>
<li><p>Stun</p>
<p>47:55</p>
</li>
<li><p>Stun Niagara System</p>
<p>16:49</p>
</li>
<li><p>Shock Loop Animations</p>
<p>20:19</p>
</li>
</ul>
<h2 id="26-Passive-Spells-被动法术"><a href="#26-Passive-Spells-被动法术" class="headerlink" title="26.Passive Spells &#x2F; 被动法术"></a>26.Passive Spells &#x2F; 被动法术</h2><ul>
<li><p>2 个讲座·8 分钟 &#x2F; 2 Lectures · 8 Minutes</p>
</li>
<li><p>Passive Spell tags</p>
<p>02:31</p>
</li>
<li><p>Aura Passive Ability</p>
<p>08:08</p>
</li>
<li><p>Passive Ability Info</p>
<p>07:55</p>
</li>
<li><p>Passive Tags in Spell Tree</p>
<p>07:23</p>
</li>
<li><p>Multiple Level Up Rewards</p>
<p>10:18</p>
</li>
<li><p>Passive Ability Activation</p>
<p>37:30</p>
</li>
<li><p>Passive Niagara Component</p>
<p>30:31</p>
</li>
</ul>
<h2 id="27-Arcane-Shards-奥术碎片"><a href="#27-Arcane-Shards-奥术碎片" class="headerlink" title="27.Arcane Shards &#x2F; 奥术碎片"></a>27.Arcane Shards &#x2F; 奥术碎片</h2><ul>
<li><p>18 个讲座·4 小时 39 分钟 &#x2F; 18 Lectures · 4 Hours 39 Minutes</p>
</li>
<li><p>Magic Circle</p>
<p>12:25</p>
</li>
<li><p>Spawning Magic Circles</p>
<p>11:35</p>
</li>
<li><p>Magic Circle Interface Functions</p>
<p>09:56</p>
</li>
<li><p>Arcane Shards Spell</p>
<p>13:25</p>
</li>
<li><p>Wait Input Press</p>
<p>08:58</p>
</li>
<li><p>Anti Aliasing and Moving Decals</p>
<p>04:10</p>
</li>
<li><p>Point Collection</p>
<p>46:45</p>
</li>
<li><p>Async Point Locations</p>
<p>10:21</p>
</li>
<li><p>Gameplay Cue Notify Burst</p>
<p>17:26</p>
</li>
<li><p>Arcane Shards Montage</p>
<p>14:36</p>
</li>
<li><p>Radial Damage Parameters</p>
<p>19:29</p>
</li>
<li><p>Setting Radial Damage Parameters</p>
<p>10:18</p>
</li>
<li><p>Radial Damage with Falloff</p>
<p>21:18</p>
</li>
<li><p>Tying Radial Damage All Together</p>
<p>27:10</p>
</li>
<li><p>Ignore Enemies while Magic Circle Active</p>
<p>06:52</p>
</li>
<li><p>Knockback Force and Death Impulse Overrides</p>
<p>15:50</p>
</li>
<li><p>Spell Descriptions</p>
<p>13:45</p>
</li>
<li><p>Arcane Shards Cost and Cooldown</p>
<p>14:23</p>
</li>
</ul>
<h2 id="28-Fire-Blast-火焰冲击"><a href="#28-Fire-Blast-火焰冲击" class="headerlink" title="28.Fire Blast &#x2F; 火焰冲击"></a>28.Fire Blast &#x2F; 火焰冲击</h2><ul>
<li><p>9 个讲座·1小时 59 分钟 &#x2F; 9 Lectures · 1 Hour 59 Minutes</p>
</li>
<li><p>FireBlast Ability</p>
<p>12:36</p>
</li>
<li><p>FireBlast Cost and Cooldown</p>
<p>05:44</p>
</li>
<li><p>Aura Fire Ball</p>
<p>12:21</p>
</li>
<li><p>Spawning FireBalls</p>
<p>10:02</p>
</li>
<li><p>FireBall Timelines</p>
<p>17:39</p>
</li>
<li><p>Causing FireBall Damage</p>
<p>10:51</p>
</li>
<li><p>FireBall Explosive Damage</p>
<p>31:26</p>
</li>
<li><p>Empty Cooldown Texture</p>
<p>05:26</p>
</li>
<li><p>Execute Local Gameplay Cues</p>
<p>12:43</p>
</li>
</ul>
<h2 id="29-Saving-Progress-保存进度"><a href="#29-Saving-Progress-保存进度" class="headerlink" title="29.Saving Progress &#x2F; 保存进度"></a>29.Saving Progress &#x2F; 保存进度</h2><ul>
<li><p>23 个讲座·5 小时 45 分钟 &#x2F; 23 Lectures · 5 Hours 45 Minutes</p>
</li>
<li><p>Saving Progress</p>
<p>08:54</p>
</li>
<li><p>Main Menu</p>
<p>33:09</p>
</li>
<li><p>Play and Quit Buttons</p>
<p>12:20</p>
</li>
<li><p>Vacant Load Slot</p>
<p>13:41</p>
</li>
<li><p>Enter Name Load Slot</p>
<p>03:42</p>
</li>
<li><p>Taken Load Slot</p>
<p>05:07</p>
</li>
<li><p>Load Menu</p>
<p>11:40</p>
</li>
<li><p>MVVM</p>
<p>07:45</p>
</li>
<li><p>Changes Needed for 5.3+</p>
<p>34:30</p>
</li>
<li><p>View Model Class</p>
<p>13:21</p>
</li>
<li><p>Constructing a View Model</p>
<p>19:31</p>
</li>
<li><p>Load Slot View Model</p>
<p>24:19</p>
</li>
<li><p>Switching the Widget Switcher</p>
<p>19:38</p>
</li>
<li><p>Save Game Object</p>
<p>15:10</p>
</li>
<li><p>Binding Variables to ViewModels</p>
<p>11:15</p>
</li>
<li><p>Load Slot Status</p>
<p>17:19</p>
</li>
<li><p>Enabling the Select Slot Button</p>
<p>09:12</p>
</li>
<li><p>Enabling Play and Delete Buttons</p>
<p>08:34</p>
</li>
<li><p>Are You Sure Widget</p>
<p>24:17</p>
</li>
<li><p>Deleting a Slot</p>
<p>16:48</p>
</li>
<li><p>Map Name Field Notify</p>
<p>16:21</p>
</li>
<li><p>Saving the Map Name</p>
<p>04:17</p>
</li>
<li><p>Traveling to the Saved Map</p>
<p>13:42</p>
</li>
</ul>
<h2 id="30-Checkpoints-检查点"><a href="#30-Checkpoints-检查点" class="headerlink" title="30.Checkpoints &#x2F; 检查点"></a>30.Checkpoints &#x2F; 检查点</h2><ul>
<li><p>15 个讲座·3 小时 42 分钟 &#x2F; 15 Lectures · 3 Hours 42 Minutes</p>
</li>
<li><p>Choosing the Player Start</p>
<p>09:34</p>
</li>
<li><p>Setting the Default Player Start</p>
<p>12:50</p>
</li>
<li><p>Save the Player Start Tag</p>
<p>07:49</p>
</li>
<li><p>Checkpoints</p>
<p>21:18</p>
</li>
<li><p>Interface Function for Saving Progress</p>
<p>19:45</p>
</li>
<li><p>Saving Player Data</p>
<p>08:33</p>
</li>
<li><p>Loading Player Data</p>
<p>15:34</p>
</li>
<li><p>Initializing Attributes From Disk</p>
<p>24:30</p>
</li>
<li><p>Showing Player Level in Load Screen</p>
<p>06:19</p>
</li>
<li><p>Saving Abilities</p>
<p>14:46</p>
</li>
<li><p>Notes on this lecture</p>
<p>00:05</p>
</li>
<li><p>Loading Abilities</p>
<p>29:41</p>
</li>
<li><p>Data Structures for Saving Data</p>
<p>13:15</p>
</li>
<li><p>Saving World State</p>
<p>21:47</p>
</li>
<li><p>Loading World State</p>
<p>15:46</p>
</li>
</ul>
<h2 id="31-Map-Entrance-地图入口"><a href="#31-Map-Entrance-地图入口" class="headerlink" title="31.Map Entrance &#x2F; 地图入口"></a>31.Map Entrance &#x2F; 地图入口</h2><ul>
<li><p>17 个讲座·4 小时 53 分钟 &#x2F; 17 Lectures · 4 Hours 53 Minutes</p>
</li>
<li><p>Different Highlight Colors</p>
<p>10:10</p>
</li>
<li><p>Highlight Interface</p>
<p>06:47</p>
</li>
<li><p>Targeting Status</p>
<p>23:49</p>
</li>
<li><p>Highlighting Non-Enemies</p>
<p>06:15</p>
</li>
<li><p>Set Move-To Location</p>
<p>15:50</p>
</li>
<li><p>Beacons</p>
<p>15:49</p>
</li>
<li><p>Map Entrance</p>
<p>31:09</p>
</li>
<li><p>Dungeon Stair Entrance</p>
<p>14:04</p>
</li>
<li><p>Dungeon Entrance Blueprints</p>
<p>14:50</p>
</li>
<li><p>Polish Menu</p>
<p>04:58</p>
</li>
<li><p>Spawn Volumes</p>
<p>24:54</p>
</li>
<li><p>Player Death</p>
<p>18:10</p>
</li>
<li><p>Loot Tiers</p>
<p>38:41</p>
</li>
<li><p>Loot Effects</p>
<p>21:06</p>
</li>
<li><p>Loot Drop Curve</p>
<p>12:41</p>
</li>
<li><p>Pickup Sounds</p>
<p>12:46</p>
</li>
<li><p>Quit Button</p>
<p>20:51</p>
</li>
</ul>
<h2 id="32-Course-Conclusion-课程总结"><a href="#32-Course-Conclusion-课程总结" class="headerlink" title="32.Course Conclusion &#x2F; 课程总结"></a>32.Course Conclusion &#x2F; 课程总结</h2><ul>
<li><p>2 个讲座·8 分钟 &#x2F; 2 Lectures · 8 Minutes</p>
</li>
<li><p>Quest - Levels</p>
<p>01:20</p>
</li>
<li><p>Conclusion - Bonus Video</p>
<p>06:24</p>
</li>
</ul>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal Engine</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>C++</tag>
        <tag>Unreal Engine</tag>
        <tag>GAS</tag>
        <tag>学习报告</tag>
      </tags>
  </entry>
  <entry>
    <title>《基于MR的海洋塑料污染物扩散模拟与交互可视化》毕业设计</title>
    <url>/2025/05/14/%E3%80%8A%E5%9F%BA%E4%BA%8EMR%E7%9A%84%E6%B5%B7%E6%B4%8B%E5%A1%91%E6%96%99%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E4%B8%8E%E4%BA%A4%E4%BA%92%E5%8F%AF%E8%A7%86%E5%8C%96%E3%80%8B%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[ <embed src="/pdf/毕业设计/基于MR的海洋塑料污染物扩散模拟与交互可视化.pdf" width="100%" height="10000" type="application/pdf">

]]></content>
      <categories>
        <category>本科项目</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>毕业设计</tag>
      </tags>
  </entry>
</search>
