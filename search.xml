<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺2</title>
    <url>/2023/11/26/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-2-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>优化了前端显示，修复了不同屏幕分辨率下的显示错误bug</li>
<li>将Java项目转为Python的flask项目</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/1.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>配合后端接口，加入类似锁的机制防止卡死</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>添加更多便捷功能，提升用户体验，继续美化前端，思考更多前端功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>页面缩放引起的组件遮挡消失，滑动条显示问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对前端的理解更深入，学会了pycharm转换更改项目所用的Python版本，对前后端对接还不太清楚</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>学习了python，安装了pycharm，并配置了python。更新了前端网页，学习前后端交互相关知识。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/2.png"
                      alt="2"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化页面设计，配合后端交互。</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>提升用户体验，继续美化页面，实现图片的流转。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>pycharm打开不了网页，python安装失败。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了python，前后端等知识。疑问是现在的训练模型需要的是一个数据集，如何将单个图片放到文件夹中。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>决定使用pycharm完成项目，配置pycharm环境，完成加噪并去噪的CNN自动编码器。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/3.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>尝试去掉加噪部分，对一张本身带噪声的图片进行去噪。</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>完成模型训练并接入后端</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>python版本过新，导致TensorFlow模块不能安装，只能重新安装3.9版本。数据集下载失败，只能通过本地下载，再用路径读取。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对CNN模型有了更多认识，学会了pycharm的使用。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>配置pycharm环境，了解接口文档的写法，学习前后端交互知识</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/4.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>将模型接入后端，写接口文档，完成前后端交互</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>前后端交互，与模型的数据对接</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>在pycharm中因为版本问题下载框架失败，已解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>大概了解了接口文档的写法,简单学习前后端交互 ，对图片的传输和对接过程还是不太清楚</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>尝试用pycharm将模型接入后端，并用apifox写接口文档</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/5.png"
                      alt="5"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>将模型接入后端并继续完成接口文档</li>
</ul>
</li>
<li>还剩下的任务：<ul>
<li>与前端对接</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>python版本问题，将模型接入后端时遇到了一些问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了简单的后端知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>正常网页分辨率显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
<li>窄分辨率显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/7.png"
                      alt="7"
                >编辑</li>
<li>数据集的模型训练</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/8.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a2/9.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.11.26 16:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室304</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目进展概况"><a href="#1-项目进展概况" class="headerlink" title="1. 项目进展概况"></a>1. 项目进展概况</h4><ul>
<li>讨论了团队成员在项目中的整体进展情况，包括前端显示优化、项目从Java转换到Python Flask的进展，以及前后端交互的学习和实现。</li>
<li>着重强调了对不同屏幕分辨率的适配问题，确保网页在不同设备上均能正常显示。</li>
</ul>
<h4 id="2-技术难点和解决方案"><a href="#2-技术难点和解决方案" class="headerlink" title="2. 技术难点和解决方案"></a>2. 技术难点和解决方案</h4><ul>
<li>分析了在项目开发中遇到的技术难题，如页面缩放导致的组件遮挡和滑动条显示问题，以及Python版本兼容性问题。</li>
<li>讨论了可能的解决方案，包括技术选型调整、版本兼容性检查，以及增强团队成员之间的技术交流。</li>
</ul>
<h4 id="3-后续计划和任务分配"><a href="#3-后续计划和任务分配" class="headerlink" title="3. 后续计划和任务分配"></a>3. 后续计划和任务分配</h4><ul>
<li>计划了接下来的工作，包括继续优化前端页面设计，加强前后端的数据交互，以及将机器学习模型更好地集成到后端。</li>
<li>对剩余任务进行了详细的分配，确保每位团队成员都清楚自己的责任和接下来的工作重点。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺1</title>
    <url>/2023/11/19/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-1-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li>使用Photoshop制作了网页的主界面视图UI效果示意图和LOGO</li>
<li>按照设计计划制作了网站HTML页面</li>
<li>展示GitHub当日代码&#x2F;文档签入记录：</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/1.png"
                      alt="1"
                ></li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>继续美化前端，思考更多前端功能，配合后端</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>添加更多便捷功能，提升用户体验</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>前端各种插件按钮的位置大小调整，排列方式和外观，页面缩放引起的组件排列等等的调试问题</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用，加强了web前端的知识</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>了解学会使用fork，学习了解如何搭建web项目和配置，完成了部分前端任务。</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/2.png"
                      alt="2"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>与后端结合，实现前端的图像显示和页面优化。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>将前端与后端结合，对页面进一步美化。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>对项目的规划还不够了解，遇到一些技术问题需要加强合作。</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用，学会用js设计网页。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学习了fork的使用，学习并尝试实现了CNN自动编码器的基本框架，训练模型中。</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/3.png"
                      alt="3"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>继续修改错误，继续调试CNN编码器训练。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>将CNN编码器训练完成，争取得到输出结果。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>错误很多，不熟悉用java编写CNN，训练过程中的错误还没有得到修改，正在学习和修改中。</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会使用fork，了解了nd4j库的使用及CNN基本结构。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学会fork的使用，学习了解如何搭建web项目的系统框架，制定初步的计划</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/4.png"
                      alt="4"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>搭建好整体系统框架</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>搭建后台接受前端传来的图片，调用训练好的神经网络模型，返回处理好的图片给前端</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>对项目的规划还不够清晰，对大部分运用到的知识不够熟练</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学会了fork的使用以及多人协同完成一个项目</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li><p>过去两天完成的任务：</p>
<ul>
<li><p>学习了fork的使用，在git上创建了仓库</p>
</li>
<li><p>展示GitHub当日代码&#x2F;文档签入记录：</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/5.png"
                      alt="5"
                ></p>
</li>
</ul>
</li>
<li><p>接下来的计划：</p>
<ul>
<li>系统架构搭建，搭建好整体的Web项目的系统框架，使用Django框架来实现开发。</li>
</ul>
</li>
<li><p>还剩下的任务：</p>
<ul>
<li>搭建后台，接受前端传来的图片url，同时以python脚本的形式调用训练好的神经网络模型，再将处理好的图片返回给前端。</li>
</ul>
</li>
<li><p>遇到的困难：</p>
<ul>
<li>没有学习过python，不太了解后端的工作，不了解Django如何调用训练好的模型</li>
</ul>
</li>
<li><p>收获和疑问：</p>
<ul>
<li>学习了基本的git和python知识，对于后续调用训练好的模型还比较困惑</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li><p>Logo<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/6.png"
                      alt="6"
                ></p>
</li>
<li><p>主界面UI初版示意图<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/7.png"
                      alt="7"
                ></p>
</li>
<li><p>网站主页面<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/8.png"
                      alt="8"
                ></p>
</li>
<li><p>点击图片放大显示功能<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/9.png"
                      alt="9"
                ></p>
</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a1/10.png"
                      alt="10"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.11.19 14:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室303</p>
</li>
<li><p><strong>内容</strong>：</p>
<ul>
<li><h4 id="团队进展"><a href="#团队进展" class="headerlink" title="团队进展"></a>团队进展</h4><ul>
<li><strong>前端开发</strong>：<ul>
<li>完成了网页主界面视图UI和LOGO的制作，以及网站HTML页面的初步设计。</li>
<li>已实现部分前端功能，并对前端进行初步美化。</li>
</ul>
</li>
<li><strong>后端开发</strong>：<ul>
<li>着手搭建Web项目的系统框架。</li>
<li>初步学习并尝试实现CNN自动编码器的基础框架，模型训练正在进行中。</li>
</ul>
</li>
<li><strong>项目管理和协调</strong>：<ul>
<li>团队成员均已学习使用fork进行协作。</li>
<li>项目的GitHub代码和文档签入记录展示了目前的进展。</li>
</ul>
</li>
</ul>
<h4 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h4><ul>
<li><strong>前端开发</strong>：<ul>
<li>继续改善前端设计和用户体验，增加更多便捷功能。</li>
<li>将前端与后端结合，优化图像显示和页面设计。</li>
</ul>
</li>
<li><strong>后端开发</strong>：<ul>
<li>继续完善CNN编码器的训练，解决遇到的技术难题。</li>
<li>完成系统框架的搭建，特别是后台处理模块，以实现前端图像的接收和处理。</li>
</ul>
</li>
<li><strong>团队协作</strong>：<ul>
<li>加强团队成员间的沟通和协作，尤其是在项目规划和技术问题解决方面。</li>
<li>持续学习和掌握新知识和工具。</li>
</ul>
</li>
</ul>
<h4 id="当前挑战"><a href="#当前挑战" class="headerlink" title="当前挑战"></a>当前挑战</h4><ul>
<li>团队成员对项目规划和所用技术不够熟悉，需要加强学习和协作。</li>
<li>在CNN编码器的训练和后端开发中遇到了一些技术难题，正在寻求解决方案。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Alpha冲刺3</title>
    <url>/2023/12/03/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Alpha%E5%86%B2%E5%88%BA-3-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>成功连接前后端，前端上传按钮点击后可以选择图片上传，上传后在前端有显示，并且通过后端将上传图片存储在了images里</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步优化前端功能与界面，实现新增的转换按钮的功能（与后端对接）</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前后端连接错误，改正script中的方法后解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对JavaScript与HTML理解更深入，对前端布局理解</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>增加了一个开始去噪的按钮，配置了ui图像，调整页面，修改按钮的颜色。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端的对接工作，将模型接入传送过程，实装相应的按钮和进度条的功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习前端，学习python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>使用训练的模型对本地图片进行去噪，对模型多次修改以达到期望效果。</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续修改模型，实现输出图片颜色与输入图片相同。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>刚开始的模型，输入输出图片颜色与原图像不一致，改过之后输入图片正确，但是输出图像不仅模糊，而且没有色彩，这个问题现在依旧没有解决。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习CNN自动编码器，学习了python语法。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>尝试获取前端图片并将其传给模型进行训练，但只完成从前端获取图片存到本地文件夹</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端对接工作，将模型接入传送过程</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>图片保存路径与预期不符，还无法连接到模型</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了一些后端相关知识，学习了python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>进行了前后端的部分对接，目前实现了从前端获取要修复的图片到本地</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/5.png"
                      alt="5"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完成前后端对接工作，实现将训练好的图片传回给前端</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前后端对接时出现问题，前端上传的图片无法保存到本地制定文件夹</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了相关的Python知识，了解前后端对接的基本工作</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>添加了转换按钮</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/a3/10.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.3 16:00</p>
</li>
<li><p><strong>地点</strong>：图书馆研讨室303</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目进展概况"><a href="#1-项目进展概况" class="headerlink" title="1. 项目进展概况"></a>1. 项目进展概况</h4><ul>
<li><strong>前后端连接</strong>：成功实现了前后端的基本连接，使前端可以上传图片，后端可以接收并存储这些图片。</li>
<li><strong>界面优化</strong>：团队成员对用户界面进行了改进，增加了去噪按钮，并优化了界面的整体布局和视觉效果。</li>
<li><strong>模型训练与应用</strong>：对去噪模型进行了训练和调整，以便更好地处理上传的图片。</li>
</ul>
<h4 id="2-技术难点和解决方案"><a href="#2-技术难点和解决方案" class="headerlink" title="2. 技术难点和解决方案"></a>2. 技术难点和解决方案</h4><ul>
<li><strong>前后端对接问题</strong>：解决了前后端连接时出现的错误，主要通过调整代码和脚本实现。</li>
<li><strong>模型集成问题</strong>：正在努力将去噪模型完全集成到前后端流程中，以便实现自动处理上传的图片。</li>
<li><strong>图像处理问题</strong>：在图像去噪的模型训练中遇到了输出图像颜色和清晰度的问题，团队正在通过调整模型参数和算法来解决这些问题。</li>
</ul>
<h4 id="3-后续计划和任务分配"><a href="#3-后续计划和任务分配" class="headerlink" title="3. 后续计划和任务分配"></a>3. 后续计划和任务分配</h4><ul>
<li><strong>前端功能优化</strong>：继续提升用户界面，包括增加新的功能按钮和改进现有布局。</li>
<li><strong>模型优化与集成</strong>：继续调整和改进去噪模型，确保模型能够有效集成到整个系统中。</li>
<li><strong>前后端进一步对接</strong>：加强前后端的协同工作，确保系统的流畅运行，特别是在图像上传和处理方面。</li>
</ul>
<p>团队将继续密切协作，确保按时完成项目目标，同时解决任何新出现的技术挑战。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺1</title>
    <url>/2023/12/10/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-1-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>优化前端格式和排列表现</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步优化前端功能与界面，设计UI，实现新增的转换按钮的功能（与后端对接）</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>组件扩展使整体屏幕分辨率改变出现bug，调整组件位置已经禁用横向滚动条之后解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对JavaScript与HTML理解更好，对前端布局理解加深</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>更改了顶部导航栏，重新安排了按钮的位置，修改了按钮的颜色。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成前后端的对接工作，将模型接入传送过程，实装相应的按钮和进度条的功能</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入，模型训练困难</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习前端，学习python语言，了解前后端交互</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>修改模型，实现输入图片与输出图片颜色一致；增加训练轮数和卷积层数，以减请轻去噪后的模糊情况。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续修改模型，同时学习CNN编码器相关知识，寻求更好的模型用于图像去噪。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>电脑没有独显，模型训练很慢，而且图像模糊还没有得到解决。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>对CNN编码器的了解更多，认识了很多去噪算法。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>协助模型训练的同学进行模型训练,修改部分细节使图片更适应模型</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/4.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成模型训练及后端传输图片</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>之前的模型训练效果不好，重新开始训练，模型和前端的交接遇到点问题</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解了模型训练的一些知识</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>协助模型训练的同学进行模型训练</li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成模型训练及后端传输图片</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>之前的模型训练效果不好，重新开始训练</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解了模型训练的一些知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>增加及修改加了顶部菜单栏的组件</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/6.png"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b1/10.jpg"
                      alt="点击并拖拽以移动"
                >编辑</li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.10 20:00</p>
</li>
<li><p><strong>地点</strong>：腾讯会议</p>
</li>
<li><p><strong>内容</strong>：</p>
<h3 id="进展回顾"><a href="#进展回顾" class="headerlink" title="进展回顾"></a>进展回顾</h3><ol>
<li><strong>前端开发</strong>:<ul>
<li>在前端方面取得了重要进展。包括对前端格式的优化、排列表现的改善、顶部导航栏的重新设计，以及按钮颜色的调整。</li>
<li>计划进一步增强前端功能和界面设计，特别是实现新的转换按钮功能，并与后端紧密对接。</li>
</ul>
</li>
<li><strong>模型训练与后端开发</strong>:<ul>
<li>模型训练上，实现了输入输出图片颜色一致性的改进，并通过增加训练轮数和卷积层数减轻了去噪后的模糊情况。</li>
<li>后续计划着重于模型的进一步改进，特别是针对CNN编码器的深入学习和应用，以及模型和前端的有效整合。</li>
</ul>
</li>
</ol>
<h3 id="遇到的挑战"><a href="#遇到的挑战" class="headerlink" title="遇到的挑战"></a>遇到的挑战</h3><ul>
<li>团队面临的主要挑战包括前端组件扩展导致的bug、模型训练的效率问题以及前后端的有效整合。</li>
</ul>
<h3 id="收获与展望"><a href="#收获与展望" class="headerlink" title="收获与展望"></a>收获与展望</h3><ul>
<li>成员们在JavaScript、HTML、Python语言及前后端交互方面有了更深入的理解和应用。</li>
<li>对CNN编码器和去噪算法的认识更加深入，为未来的开发提供了坚实的基础。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来看，每位成员都在其专长领域作出了积极贡献。虽然面临一些技术挑战，但团队成员通过有效合作，已经取得了显著的进展，并对未来的工作有了清晰的规划和方向。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺2</title>
    <url>/2023/12/18/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-2-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>前端微调，使导航栏固定在屏幕，删除冗余按钮，使下拉菜单正常实现，进行了UI和背景调整的美化工作</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化滚动式前端，添加轮转图片，设计网页介绍UI和按钮UI等等</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>动画效果还未实现</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端动效以及美化，阅读了相关案例代码</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>更改页面结构为滑动式长页面，增添了模态框，增添了轮播图片动效</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>修改UI里的一些新的bug，完成前后端的对接工作，丰富美化页面</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型未接入，模型训练困难，轮播图总是自己放大，动画效果加载失败</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端动效美化知识，阅读了相关代码</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>参考老师的代码，实现了CBDnet模型进行去噪，模型训练完成。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>协助负责后端的同学进行模型的调用。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>采用CNN模型，总是会出现图片部位丢失的错误，所以改用CBDnet模型。由于模型是用GPU运行的，我只能在同学的电脑上运行</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了CBDnet的有关知识。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>辅助训练备选模型，挑选出效果最好的模型，解决图片上传报错的问题</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>进一步实现图片的传输，完成前后端对接工作</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>模型训练的效果图存在各种各样的问题，图片的传输依旧有点混乱</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>了解到不同的路径写法，学习到不同路径对图片传输的影响</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>辅助训练模型，编写后端接口</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/5.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>完成后端任务，实现图片的传输与保存</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>训练的模型去噪效果不是很好，图片太过模糊，并且对图片格式要求很严格</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了python的一些基础知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>网站前端改为滚动式，美化了界面，结构重新设计</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/6.png"
                      alt="6"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/7.png"
                      alt="7"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/8.png"
                      alt="8"
                ></li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b2/10.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.17 19:00</p>
</li>
<li><p><strong>地点</strong>：腾讯会议</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-前端开发进展"><a href="#1-前端开发进展" class="headerlink" title="1. 前端开发进展"></a>1. 前端开发进展</h4><ul>
<li><strong>界面重设计</strong>：网站前端已改为滚动式，为用户提供了更流畅的浏览体验。</li>
<li><strong>UI&#x2F;UX改善</strong>：对用户界面和体验进行了显著的美化和优化，使网站更加吸引用户。</li>
<li><strong>动效和微调</strong>：实现了一些基本的动画效果，对导航栏、下拉菜单等元素进行了微调，以提高页面的整体美观性和用户体验。</li>
</ul>
<h4 id="2-后端开发与模型训练"><a href="#2-后端开发与模型训练" class="headerlink" title="2. 后端开发与模型训练"></a>2. 后端开发与模型训练</h4><ul>
<li><strong>模型选择与训练</strong>：经过对比，选择了CBDnet模型进行去噪处理，模型训练有初步成果。</li>
<li><strong>后端接口与集成</strong>：开发了后端接口，正在努力实现前后端的顺畅对接，以及图片的有效传输与保存。</li>
</ul>
<h4 id="3-遇到的挑战"><a href="#3-遇到的挑战" class="headerlink" title="3. 遇到的挑战"></a>3. 遇到的挑战</h4><ul>
<li><strong>模型效果与优化</strong>：目前模型去噪效果存在一些问题，如图片模糊、格式要求严格等，团队正在积极寻找解决方案。</li>
<li><strong>动画效果实现</strong>：一些复杂的动画效果实现上存在困难，团队成员正在学习相关技术以改善这一点。</li>
</ul>
<h4 id="4-收获与展望"><a href="#4-收获与展望" class="headerlink" title="4. 收获与展望"></a>4. 收获与展望</h4><ul>
<li><strong>技术提升</strong>：通过本项目，团队成员在前端设计、后端开发和模型训练方面都有了显著的成长。</li>
<li><strong>团队协作</strong>：加强了团队间的沟通和协作，通过共同解决问题增强了团队凝聚力。</li>
</ul>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul>
<li>本次Beta冲刺阶段，团队成员共同努力，取得了显著的进步。尽管面临诸多挑战，但团队通过有效的沟通和协作，不断优化项目，朝着最终目标稳步前进。未来，团队将继续致力于解决剩余的技术难题，并期待在项目最终阶段呈现出更加完善的成果。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CBDnet卷积神经网络深度学习的云去噪网站-Beta冲刺3</title>
    <url>/2023/12/24/09%E7%BB%84%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE-Beta%E5%86%B2%E5%88%BA-3-3/</url>
    <content><![CDATA[<h2 id="一、基本情况"><a href="#一、基本情况" class="headerlink" title="一、基本情况"></a>一、基本情况</h2><h3 id="团队ID"><a href="#团队ID" class="headerlink" title="团队ID"></a>团队ID</h3><p>09</p>
<h3 id="组长博客"><a href="#组长博客" class="headerlink" title="组长博客"></a>组长博客</h3><p>链接：[<a href="https://elecmark.github.io/">Elecmark_博客</a>]</p>
<h3 id="小组成员"><a href="#小组成员" class="headerlink" title="小组成员"></a>小组成员</h3><ul>
<li>普典衡</li>
<li>司宇萌</li>
<li>孙文秀</li>
<li>王诗梦</li>
<li>王菲</li>
</ul>
<h2 id="二、冲刺概况汇报"><a href="#二、冲刺概况汇报" class="headerlink" title="二、冲刺概况汇报"></a>二、冲刺概况汇报</h2><h3 id="普典衡"><a href="#普典衡" class="headerlink" title="普典衡"></a>普典衡</h3><ul>
<li>过去完成的任务：<ul>
<li>删除了所有冗余文件，完成了下载功能，优化了所有UI，加入了介提示等等。调整了按钮布局，添加了开发者信息，对网站流程进行了优化，可以作为正式版</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/1.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化网页介绍UI和功能等等</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>图片模型去噪完之后没有显示到前段，路径丢失与函数调用关系的调试。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了前端美化，以及前后端接口使用，学习了pycharm，以及前端CSS，HTML，JavaScript的知识</li>
</ul>
</li>
</ul>
<h3 id="司宇萌"><a href="#司宇萌" class="headerlink" title="司宇萌"></a>司宇萌</h3><ul>
<li>过去完成的任务：<ul>
<li>完成了前端，实现了上传显示下载等功能，增加了进度条和去噪时锁定页面的功能。 接下来的计划：继续优化模型。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/2.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>在实现按钮的过程中，出现了找不到位置的问题，之后模型运行成功，但是一直没有自动更新显示去噪后的图片。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了pycharm，学习了HTML等前端知识，探索了滚动式长页面网页的实现。</li>
</ul>
</li>
</ul>
<h3 id="孙文秀"><a href="#孙文秀" class="headerlink" title="孙文秀"></a>孙文秀</h3><ul>
<li>过去完成的任务：<ul>
<li>完成CBDnet模型训练，实现图片去噪，协助负责后端的同学进行模型的调用。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/3.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续优化模型。</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>一开始模型在只有CPU的电脑上运行会失败，后来在学长的帮助下将这个问题成功解决。还有就是我的fork出现一些问题，push不上去，害怕重新pull下来会覆盖掉我写的文件，选择将文件打包发给组内同学。</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习到了CBDnet和模型调用的有关知识。</li>
</ul>
</li>
</ul>
<h3 id="王诗梦"><a href="#王诗梦" class="headerlink" title="王诗梦"></a>王诗梦</h3><ul>
<li>过去完成的任务：<ul>
<li>将前端上传的图片保存到images文件夹并将其重命名为original.jpg；修改代码使前端的任何格式图片都可被模型识别并处理；将模型处理的结果图片改成只有处理后效果的图片并命名为result存放到result文件夹中以供前端调用显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/4.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完善优化代码</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前端图片保存到本地有点小问题，但顺利解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了后端处理图片以及保存路径的相关知识</li>
</ul>
</li>
</ul>
<h3 id="王菲"><a href="#王菲" class="headerlink" title="王菲"></a>王菲</h3><ul>
<li>过去完成的任务：<ul>
<li>将前端上传的图片保存到images文件夹并重命名为original.jpg；修改代码使前端的任何格式图片都可被模型识别并处理；将模型处理的结果图片命名为result并存放到result文件夹中以供前端调用显示</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/5.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
</li>
<li>接下来的计划：<ul>
<li>继续完善优化代码</li>
</ul>
</li>
<li>遇到的困难：<ul>
<li>前端图片保存到本地有点小问题，但顺利解决</li>
</ul>
</li>
<li>收获和疑问：<ul>
<li>学习了后端python的相关知识</li>
</ul>
</li>
</ul>
<h2 id="三、冲刺成果展示"><a href="#三、冲刺成果展示" class="headerlink" title="三、冲刺成果展示"></a>三、冲刺成果展示</h2><h3 id="最新成果展示"><a href="#最新成果展示" class="headerlink" title="最新成果展示"></a>最新成果展示</h3><ul>
<li>网站前端改为滚动式，修改了背景，添加说明UI，美化了界面，结构重新设计</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/6.png"
                      alt="点击并拖拽以移动"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/7.png"
                      alt="点击并拖拽以移动"
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/8.png"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="站立会议合照"><a href="#站立会议合照" class="headerlink" title="站立会议合照"></a>站立会议合照</h3><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Group9-image-denoising/b3/10.jpg"
                      alt="点击并拖拽以移动"
                ></li>
</ul>
<h3 id="会议时间、地点、内容记录"><a href="#会议时间、地点、内容记录" class="headerlink" title="会议时间、地点、内容记录"></a>会议时间、地点、内容记录</h3><ul>
<li><p><strong>时间</strong>：2023.12.31 23:00</p>
</li>
<li><p><strong>地点</strong>：海底捞</p>
</li>
<li><p><strong>内容</strong>：</p>
<h4 id="1-项目结项总结"><a href="#1-项目结项总结" class="headerlink" title="1. 项目结项总结"></a>1. 项目结项总结</h4><ul>
<li>对项目从启动到结项的整体进展进行了回顾，强调了团队在各个阶段所取得的成果和学习的经验。</li>
</ul>
<h4 id="2-关键成就突出"><a href="#2-关键成就突出" class="headerlink" title="2. 关键成就突出"></a>2. 关键成就突出</h4><ul>
<li>着重讨论了项目中的关键成就，如前端界面的创新设计、后端功能的强化以及整体用户体验的显著提升。</li>
<li>强调了CBDnet模型在项目中的成功应用，及其对图片处理效果的显著提升。</li>
</ul>
<h4 id="3-技术挑战与团队克服"><a href="#3-技术挑战与团队克服" class="headerlink" title="3. 技术挑战与团队克服"></a>3. 技术挑战与团队克服</h4><ul>
<li>回顾了项目过程中遇到的技术挑战，如模型的选择和优化、前后端的有效集成等，并讨论了团队如何共同解决这些问题。</li>
</ul>
<h4 id="4-团队合作与个人成长"><a href="#4-团队合作与个人成长" class="headerlink" title="4. 团队合作与个人成长"></a>4. 团队合作与个人成长</h4><ul>
<li>着重强调了团队合作在项目成功中的关键作用，分享了通过项目成员在技术、协作和问题解决方面的成长。</li>
</ul>
<h4 id="5-项目的长期影响与未来展望"><a href="#5-项目的长期影响与未来展望" class="headerlink" title="5. 项目的长期影响与未来展望"></a>5. 项目的长期影响与未来展望</h4><ul>
<li>探讨了项目对团队成员未来职业生涯的潜在影响，以及所学技能和经验如何在未来的工作中得到应用。</li>
<li>对未来可能的项目迭代和技术发展进行了展望。</li>
</ul>
<h4 id="6-结项感想与感谢"><a href="#6-结项感想与感谢" class="headerlink" title="6. 结项感想与感谢"></a>6. 结项感想与感谢</h4><ul>
<li>成员们分享了对项目结项的感想，表达了对团队努力和成就的认可。</li>
<li>对参与项目的每位成员、指导老师和合作伙伴表示感谢。</li>
</ul>
<h4 id="7-会议总结"><a href="#7-会议总结" class="headerlink" title="7. 会议总结"></a>7. 会议总结</h4><ul>
<li>回顾了本次项目的整体旅程，从启动到结项，每个阶段的学习和成长。</li>
<li>强调了团队合作和共同努力在实现项目目标中的重要性，并对团队成员在未来的挑战中取得的成功表示乐观。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件工程</category>
        <category>云去噪</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>云去噪</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GUI——音乐播放器</title>
    <url>/2023/05/17/Java-GUI-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<h2 id="a-软件功能说明"><a href="#a-软件功能说明" class="headerlink" title="(a)软件功能说明"></a>(a)软件功能说明</h2><p>①线上歌单的获取和保存，加载进度条</p>
<p>②本地歌单的创建和保存（包括歌单封面选择，音乐的添加和删除），本地歌单的修改（封面，重命名），删除歌单</p>
<p>③播放器功能，双击选中歌曲播放（默认循环播放），停止，上一首，下一首，随机播放，顺序播放，单曲循环</p>
<p>④音乐播放进度条，当前播放的显示</p>
<h2 id="b-软件架构设计"><a href="#b-软件架构设计" class="headerlink" title="(b)软件架构设计"></a>(b)软件架构设计</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png"
                      alt="软件架构"
                ></p>
<h2 id="c-软件模块设计与实现"><a href="#c-软件模块设计与实现" class="headerlink" title="(c)软件模块设计与实现"></a>(c)软件模块设计与实现</h2><h3 id="①面板GUI-gui包-："><a href="#①面板GUI-gui包-：" class="headerlink" title="①面板GUI(gui包)："></a>①面板GUI(gui包)：</h3><p>将五个小面板链接进主面板里，播放器的功能按钮链接进MusicPlayerBlock，互相需要调用的也作为对象传入了。</p>
<h4 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MusicPlayerBlock</span> <span class="variable">musicPlayerBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicPlayerBlock</span>(musicSheets);</span><br><span class="line"></span><br><span class="line"><span class="type">MusicSheetDisplayBlock</span> <span class="variable">musicSheetDisplayBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicSheetDisplayBlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">SharedMusicSheetBlock</span> <span class="variable">sharedMusicSheetBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedMusicSheetBlock</span>(musicSheets, musicPlayerBlock, musicSheetDisplayBlock);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalMusicSheetBlock</span> <span class="variable">localMusicSheetBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalMusicSheetBlock</span>(musicSheets, musicPlayerBlock, musicSheetDisplayBlock);</span><br><span class="line"></span><br><span class="line"><span class="type">MusicSheetManagementBlock</span> <span class="variable">musicSheetManagementBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicSheetManagementBlock</span>(localMusicSheetBlock, sharedMusicSheetBlock);</span><br></pre></td></tr></table></figure></div>

<p>遇到的问题：这一块遇到的问题太多了，各个面板之间的互相作用，互相刷新显示，为此改了无数个版本，好在最后算是形成了相对满意的样子，各个面板直接也没有明显bug。关键代码太多在此只写了实例化的代码展现每个面板之间的联系</p>
<h3 id="②网络-httpclient包"><a href="#②网络-httpclient包" class="headerlink" title="②网络(httpclient包)"></a>②网络(httpclient包)</h3><p>详细过程：主要参考老师的代码。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">其中<span class="type">JSONObject</span> <span class="variable">mumObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(jms.get(<span class="string">&quot;musicItems&quot;</span>));</span><br><span class="line">改为了<span class="type">JSONObject</span> <span class="variable">mumObj</span> <span class="operator">=</span> (JSONObject) jms.get(<span class="string">&quot;musicItems&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>解决了musicItems从线上获取为空的情况</p>
<h3 id="③-model包"><a href="#③-model包" class="headerlink" title="③(model包)"></a>③(model包)</h3><p>详细过程：Music类是music的信息的存储，包括时长，作者，歌名等信息及这些信息的获取函数。MusicSheet是歌单信息的存储及歌单信息的获取方法。主要都在NewMP3Playe里调用。</p>
<h4 id="关键代码：-1"><a href="#关键代码：-1" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Music</span><span class="params">(String filePath, String fileName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="type">AudioFile</span> <span class="variable">audioFile</span> <span class="operator">=</span> AudioFileIO.read(file);</span><br><span class="line">        <span class="type">Tag</span> <span class="variable">tag</span> <span class="operator">=</span> audioFile.getTag();</span><br><span class="line">        title = tag.getFirst(FieldKey.TITLE);</span><br><span class="line">        <span class="keyword">if</span> (title == <span class="literal">null</span> || title.isEmpty()) &#123;</span><br><span class="line">            title = fileName.replaceAll(<span class="string">&quot;\\.mp3$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        artist = tag.getFirst(FieldKey.ARTIST);</span><br><span class="line">        <span class="keyword">if</span> (artist == <span class="literal">null</span> || artist.isEmpty()) &#123;</span><br><span class="line">            artist = <span class="string">&quot;未知歌手&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        musicduration = Duration.seconds(audioFile.getAudioHeader().getTrackLength());</span><br><span class="line">        <span class="type">long</span> <span class="variable">minutes</span> <span class="operator">=</span> (<span class="type">long</span>) musicduration.toMinutes();</span><br><span class="line">        <span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> (<span class="type">long</span>) (musicduration.toSeconds() % <span class="number">60</span>);</span><br><span class="line">        duration = String.format(<span class="string">&quot;%02d:%02d&quot;</span>, minutes, seconds);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(fileName);</span><br><span class="line">        System.out.println(<span class="string">&quot;Error occurred while processing file: &quot;</span> + filePath);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 删除文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">fileToDelete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        fileToDelete.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="④-soundmaker包"><a href="#④-soundmaker包" class="headerlink" title="④(soundmaker包)"></a>④(soundmaker包)</h3><p>详细过程：实际上只有NewMP3Player实装。NewMP3Player中用来实现播放器各项按钮的功能。NewMP3Player与MusicPlayerBlock互相联系。在MusicPlayerBlock里建立显示歌单内容的表格，并设置鼠标点击监听器，通过点击获取歌单和音乐的信息。</p>
<p>NewMP3Player里有</p>
<p>playButton（播放）</p>
<p>stopButton（停止）</p>
<p>prevButton（上一首）</p>
<p>nextButton（下一首）</p>
<p>sequenceButton（顺序播放）</p>
<p>randomButton（随机播放）</p>
<p>slider（进度条）</p>
<p>loopButton（循环播放）</p>
<p>为了实现代码复用，增添了stopPlayer和musicSequence的方法。</p>
<p>双击选中歌曲，会启动播放按钮，调用playmusic方法，在playmusic里根据布尔变量来判断是否进行随机播放和单曲循环，否则默认单曲循环。在进度条里通过player.getPosition获取歌曲进度。</p>
<p>遇到的问题：在写暂停的时候遇到了很多的问题，花费了很多的时间，用playThread和contralThread来实现，但是暂停时总是会出现线程冲突的问题。最后放弃了。</p>
<p>由于播放器库没有setPosition之类的按钮，所以没有实现拖动进度条实现控制音乐进度。</p>
<h4 id="关键代码：-2"><a href="#关键代码：-2" class="headerlink" title="关键代码："></a>关键代码：</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">playThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">while</span> (!isStopped) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!isPaused &amp;&amp; player != <span class="literal">null</span>) &#123;</span><br><span class="line">                          player.play();</span><br><span class="line">                          <span class="keyword">if</span> (isLooping &amp;&amp; player.isComplete()) &#123;</span><br><span class="line">                              <span class="comment">// 当音乐播放完成且isLooping为true时，重新开始播放当前音乐</span></span><br><span class="line">                              <span class="keyword">if</span>(isLooping) &#123;</span><br><span class="line">                                  player.close();</span><br><span class="line">                                  <span class="type">BufferedInputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> </span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">                                  player = <span class="keyword">new</span> <span class="title class_">Player</span>(buffer);</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">else</span> &#123;</span><br><span class="line">                                  sequenceButton.doClick();</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (player != <span class="literal">null</span>) &#123;</span><br><span class="line">                      player.close();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      playThread.start();</span><br></pre></td></tr></table></figure></div>

<p>实现每次播放音乐都创建一个新的音乐线程，不与主线程冲突。</p>
<h2 id="d-软件界面及功能展示"><a href="#d-软件界面及功能展示" class="headerlink" title="(d)软件界面及功能展示"></a>(d)软件界面及功能展示</h2><h3 id="开启后的界面"><a href="#开启后的界面" class="headerlink" title="开启后的界面"></a><strong>开启后的界面</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%BC%80%E5%A7%8B%E7%95%8C%E9%9D%A2.png"
                      alt="开启后的界面"
                ></p>
<h3 id="线上功能展示"><a href="#线上功能展示" class="headerlink" title="线上功能展示"></a><strong>线上功能展示</strong></h3><p>（如果服务器连接失败20秒后会进入本地模式（共享歌单无信息））<strong>：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95.png"
                      alt="加载歌单"
                ></p>
<p>单击共享歌单列表之后右侧歌曲列表面板会刷新，右侧歌单封面，歌单名字，创建者和创建时间都会显示下方会显示歌单加载进度条，歌曲会一首一首显示出来（只要显示就可以双击播放），如果有未下载完成的损坏MP3文件（如上次下载到一半关闭了程序导致）的会自检后删除损坏文件重新下载</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E8%BF%9B%E5%BA%A6%E6%9D%A1.png"
                      alt="加载歌单进度条"
                ></p>
<p>加载进度条会随着歌曲一首首显示实时更新</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E6%8F%90%E7%A4%BA.png"
                      alt="加载歌单提示"
                ></p>
<p>若在歌单加载过程中点击其他歌单或本地歌单添加按钮会弹出提示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%A0%E8%BD%BD%E6%AD%8C%E5%8D%95%E5%AE%8C%E6%88%90.png"
                      alt="加载歌单完成"
                ></p>
<p>歌单加载完成后会提示“双击歌曲开始播放”</p>
<h3 id="线下功能展示"><a href="#线下功能展示" class="headerlink" title="线下功能展示"></a><strong>线下功能展示</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%96%B0%E5%BB%BA%E6%AD%8C%E5%8D%95.png"
                      alt="新建歌单"
                ></p>
<p>为本地歌单提供两个互动按钮</p>
<h4 id="“-”新建歌单"><a href="#“-”新建歌单" class="headerlink" title="“+”新建歌单"></a>“+”新建歌单</h4><p>点击后弹出创建歌单面板，输入歌单名后弹出下一个详细编辑面板</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%96%B0%E5%BB%BA%E6%AD%8C%E5%8D%95.png"
                      alt="新建歌单"
                ></p>
<p>在此弹窗歌单依然可以修改名字，还可以选择歌单封面（若不选择则为默认的播放器logo），添加&#x2F;删除音乐</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E9%80%89%E6%8B%A9%E6%AD%8C%E5%8D%95%E5%B0%81%E9%9D%A2%E3%80%81%E9%9F%B3%E4%B9%90.png"
                      alt="选择歌单封面、音乐"
                ></p>
<p>从电脑文件中选择封面和MP3类型的音乐</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E9%80%89%E6%8B%A9%E6%AD%8C%E5%8D%95%E5%B0%81%E9%9D%A2%E3%80%81%E9%9F%B3%E4%B9%90%E5%AE%8C%E6%88%90.png"
                      alt="选择歌单封面、音乐完成"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E6%9C%AC%E5%9C%B0%E6%AD%8C%E5%8D%95%E6%B7%BB%E5%8A%A0%E5%AE%8C%E6%88%90.png"
                      alt="本地歌单添加完成"
                ></p>
<p>点击保存后在本地歌单面板显示刚刚创建的面板，点击后效果与线上歌单一致</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/-%E6%8C%89%E9%92%AE.png"
                      alt="-按钮"
                ></p>
<h4 id="“-”编辑歌单"><a href="#“-”编辑歌单" class="headerlink" title="“-”编辑歌单"></a>“-”编辑歌单</h4><p>选中本地歌单中的某歌单后会打开编辑面板，与创建面板功能相似，不过“取消”按钮变味了“删除”，点击删除按钮后歌单从test中删除</p>
<h3 id="播放功能展示"><a href="#播放功能展示" class="headerlink" title="播放功能展示"></a><strong>播放功能展示</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8F%8C%E5%87%BB%E6%92%AD%E6%94%BE.png"
                      alt="双击播放"
                ></p>
<p>双击歌曲开始播放，播放进度条会随着歌曲推进</p>
<p>默认本歌单顺序列表循环播放</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%81%9C%E6%AD%A2%E6%92%AD%E6%94%BE.png"
                      alt="停止播放"
                ></p>
<p>点击停止会终止当前歌曲播放，播放进度条归0，“停止”按钮也会变灰为不可用状态</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/%E5%8A%9F%E8%83%BD%E6%92%AD%E6%94%BE.png"
                      alt="功能播放"
                ></p>
<p>“下一首”点击后会直接切换到目前播放状态（顺序or随机）的下一首歌（“上一首”同理），同时播放提示栏也会实时更新显示正在播放的歌曲</p>
<p>“随机播放”参考了主流播放器的逻辑，点击后相当于给每一首歌随机赋一个id，在本次循环中都会保持这个顺序，比如歌曲1在歌曲5之后，播放到歌曲5时如果点击上一首依然是歌曲1</p>
<p>“随机播放”“顺序播放”“单曲循环”可随时切换</p>
<p>每次点击“随机播放”都会得到一个新的播放顺序</p>
<p>每次点击“顺序播放”都会得到原歌单的播放顺序</p>
<p>每次点击“单曲循环”都会让当前单曲循环播放</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>Java</category>
        <category>音乐播放器</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>项目报告</tag>
        <tag>Java</tag>
        <tag>GUI</tag>
        <tag>音乐播放器</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender——建模/动画作品</title>
    <url>/2023/07/15/Blender%E5%BB%BA%E6%A8%A1-%E5%8A%A8%E7%94%BB%E4%BD%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="三兄弟建模（几何）"><a href="#三兄弟建模（几何）" class="headerlink" title="三兄弟建模（几何）"></a>三兄弟建模（几何）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/1_%E4%B8%89%E5%85%84%E5%BC%9F.png"
                      alt="1_三兄弟"
                ></p>
<h3 id="积木建模-动画（动画）"><a href="#积木建模-动画（动画）" class="headerlink" title="积木建模&#x2F;动画（动画）"></a>积木建模&#x2F;动画（动画）</h3><a class="button  center large" href='https://www.bilibili.com/video/BV15K421x7aj/?share_source=copy_web' title='【Blender积木】'><i class='fa-solid fa-play-circle'></i> 【Blender积木】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1701692717&bvid=BV15K421x7aj&cid=1463230031&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/2_%E7%A7%AF%E6%9C%A8.png"
                      alt="2_积木"
                ></p>
<h3 id="金币基站建模（金属光泽材质）"><a href="#金币基站建模（金属光泽材质）" class="headerlink" title="金币基站建模（金属光泽材质）"></a>金币基站建模（金属光泽材质）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/3_%E9%87%91%E5%B8%81%E5%9F%BA%E7%AB%99.png"
                      alt="3_金币基站"
                ></p>
<h3 id="跑车建模-动画（复杂图形建模与循环动画）"><a href="#跑车建模-动画（复杂图形建模与循环动画）" class="headerlink" title="跑车建模&#x2F;动画（复杂图形建模与循环动画）"></a>跑车建模&#x2F;动画（复杂图形建模与循环动画）</h3><a class="button  center large" href='https://www.bilibili.com/video/BV1Mj421f71M/?share_source=copy_web' title='【Blender跑车】'><i class='fa-solid fa-play-circle'></i> 【Blender跑车】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1651706227&bvid=BV1Mj421f71M&cid=1463231676&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E8%BD%A6%E5%A4%B4.png"
                      alt="跑车车头"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E7%89%B9%E5%86%992.png"
                      alt="跑车特写2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E4%BE%A7%E9%9D%A2.png"
                      alt="跑车侧面"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E8%B7%91%E8%BD%A6%E9%A1%B6%E9%83%A8.png"
                      alt="跑车顶部"
                ></p>
<h3 id="荧光树桩建模（半透明材质）"><a href="#荧光树桩建模（半透明材质）" class="headerlink" title="荧光树桩建模（半透明材质）"></a>荧光树桩建模（半透明材质）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/5_%E8%8D%A7%E5%85%89%E6%A0%91%E6%A1%A9.png"
                      alt="5_荧光树桩"
                ></p>
<h3 id="子弹时间建模-动画（物理效果模拟）"><a href="#子弹时间建模-动画（物理效果模拟）" class="headerlink" title="子弹时间建模&#x2F;动画（物理效果模拟）"></a>子弹时间建模&#x2F;动画（物理效果模拟）</h3><a class="button  center large" href='https://www.bilibili.com/video/BV1xW421c7ux/?share_source=copy_web' title='【Blender子弹时间】'><i class='fa-solid fa-play-circle'></i> 【Blender子弹时间】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1851675396&bvid=BV1xW421c7ux&cid=1463235980&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9-%E5%B0%81%E9%9D%A2.jpg"
                      alt="子弹-封面"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9%E6%85%A2%E5%8A%A8%E4%BD%9C%E6%99%AF%E6%B7%B1.png"
                      alt="子弹慢动作景深"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Blender%E4%BD%9C%E5%93%81/others/%E5%AD%90%E5%BC%B9%E6%99%AF%E6%B7%B1.png"
                      alt="子弹景深"
                ></p>
<h3 id="离散猴头（几何节点）"><a href="#离散猴头（几何节点）" class="headerlink" title="离散猴头（几何节点）"></a>离散猴头（几何节点）</h3><a class="button  center large" href='https://www.bilibili.com/video/BV1Uj421Z7Nc/?share_source=copy_web' title='【Blender猴头】'><i class='fa-solid fa-play-circle'></i> 【Blender猴头】</a>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=1651642308&bvid=BV1Uj421Z7Nc&cid=1463239128&p=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Blender</category>
        <category>建模/动画</category>
      </categories>
      <tags>
        <tag>Blender</tag>
        <tag>建模</tag>
        <tag>动画</tag>
        <tag>作品集</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework-1-Getting Started</title>
    <url>/2024/03/17/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-1-Getting-Started/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw1.pdf" width="100%" height="600" type="application/pdf">


<h2 id="Write-up-2-分析-Pointer-c-文件"><a href="#Write-up-2-分析-Pointer-c-文件" class="headerlink" title="Write-up 2: 分析 Pointer.c 文件"></a>Write-up 2: 分析 Pointer.c 文件</h2><p>在 Pointer.c 的练习中，我首先尝试编译代码，发现了几个编译错误。通过仔细审查代码，我注意到这些错误主要是由于对指针和常量的错误操作。例如，尝试修改一个指向常量的指针的内容（<em>pcc &#x3D; 7;）是非法的，因为这破坏了常量的不变性。此外，赋值 char</em> const cp &#x3D; c; 创建了一个常量指针，意味着不能改变 cp 指向的地址，但是 cp 可以修改其指向的内容。这种区别对理解 C 语言中指针和常量的行为至关重要。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw1245.png"
                      alt="21020007074-普典衡-hw1245"
                ></p>
<p>代码中注释问题的解答：</p>
<ol>
<li><p>int main(int argc, char* argv[]) { &#x2F;&#x2F; What is the type of argv?<br>argv 是一个指向字符指针的指针，即 char 类型。它通常用于存储程序运行时传递的命令行参数。</p>
</li>
<li><p>char* pc &#x3D; c; &#x2F;&#x2F; Valid assignment: c acts like a pointer to c[0] here.<br>这是一个有效的赋值。在 C 语言中，数组名称作为指针使用时，指向数组的第一个元素。因此，c 实际上指向 c[0] 的地址。</p>
</li>
<li><p>printf(“char d &#x3D; %c\n”, d); &#x2F;&#x2F; What does this print?<br>这将打印出 d 的值，即字符数组 c 的第一个字符。根据 c 的定义，这应该是 6。</p>
</li>
<li><p><em>pcc &#x3D; 7; &#x2F;&#x2F; invalid?<br>这是无效的。pcc 被声明为指向常量字符的指针（const char</em>），这意味着你不能通过 pcc 修改它指向的值。</p>
</li>
<li><p>pcc &#x3D; <em>pcp; &#x2F;&#x2F; valid?<br>这是有效的。pcc 是一个指向字符的指针，pcp 是一个指向 argv 数组第一个元素（即指向 char 的指针）的指针。因此，</em>pcp 是 char* 类型，可以赋值给 pcc。</p>
</li>
<li><p>pcc &#x3D; argv[0]; &#x2F;&#x2F; valid?<br>这也是有效的。argv[0] 是 char* 类型，它指向传递给程序的第一个命令行参数。</p>
</li>
<li><p>cp &#x3D; <em>pcp; &#x2F;&#x2F; invalid?<br>这是无效的。cp 被声明为 const 指针（char</em> const），意味着一旦它被初始化指向一个地址，你就不能更改它指向的地址。</p>
</li>
<li><p>cp &#x3D; *argv; &#x2F;&#x2F; invalid?<br>同上，这也是无效的，因为 cp 是一个常量指针。</p>
</li>
<li><p>*cp &#x3D; !; &#x2F;&#x2F; valid?<br>这是有效的。尽管 cp 是一个常量指针，它仍然可以修改其指向的内容，只是不能改变指向的地址。</p>
</li>
<li><p>cpc &#x3D; <em>pcp; &#x2F;&#x2F; invalid? 和 cpc &#x3D; argv[0]; &#x2F;&#x2F; invalid?<br>这两个都是无效的。cpc 被声明为指向常量字符的常量指针（const char</em> const），意味着既不能更改指向的地址，也不能通过它修改指向的内容。</p>
</li>
<li><p>*cpc &#x3D; @; &#x2F;&#x2F; invalid?<br>这是无效的。由于 cpc 指向一个常量字符，所以不能通过它来修改所指向的值。</p>
</li>
</ol>
<h2 id="Write-up-3-分析各种类型及其指针的大小"><a href="#Write-up-3-分析各种类型及其指针的大小" class="headerlink" title="Write-up 3: 分析各种类型及其指针的大小"></a>Write-up 3: 分析各种类型及其指针的大小</h2><p>在我完成的 sizes.c 练习中，我成功编译并运行了程序，它输出了各种数据类型及其指针的大小。以下是主要发现：</p>
<ol>
<li><p>基本类型及其指针的大小：<br>int 类型大小为 4 字节，其指针大小为 8 字节。<br>short 类型为 2 字节，指针为 8 字节。<br>long 类型为 8 字节，指针同样为 8 字节。<br>类似地，char, float, double, unsigned int, long long 的大小分别为 1, 4, 8, 4, 8 字节，它们的指针大小均为 8 字节。</p>
</li>
<li><p>特定类型及其指针的大小：<br>对于 uint8_t, uint16_t, uint32_t, uint64_t 等类型，大小分别为 1, 2, 4, 8 字节，指针大小均为 8 字节。<br>uint_fast8_t, uint_fast16_t, uintmax_t, intmax_t 类型的大小为 1, 8, 8, 8 字节，指针大小也为 8 字节。<br>对于 Clang 特有的 __int128 类型，大小为 16 字节，指针大小为 8 字节。</p>
</li>
<li><p>复合类型及其指针的大小：<br>自定义的 student 结构体大小为 8 字节，其指针大小为 8 字节。</p>
</li>
<li><p>数组及其指针的大小：<br>对于声明的 int x[5] 数组，大小为 20 字节（因为它包含 5 个 int 类型元素），而指向该数组的指针大小为 8 字节。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12124.png"
                      alt="21020007074-普典衡-hw12124"
                ></p>
<p>这些结果反映了在我的系统（一个 64 位系统）上，大多数指针类型的大小均为 8 字节，这是因为在 64 位系统上指针通常占用 8 字节的内存空间。这些信息对于理解不同数据类型在内存中如何分配和使用非常重要，尤其是在进行性能优化和内存管理时。</p>
<h2 id="Write-up-4-修改-Swap-c-函数"><a href="#Write-up-4-修改-Swap-c-函数" class="headerlink" title="Write-up 4: 修改 Swap.c 函数"></a>Write-up 4: 修改 Swap.c 函数</h2><p>在原始的程序中，swap 函数的问题在于它试图交换两个整数，但是由于 C 中的参数是按值传递的，所以 swap 函数实际上是在操作传入值的副本，而不是原始变量本身。因此，当 swap 函数执行完毕后，原始变量 k 和 m 的值并未发生改变。</p>
<p>为了修正这个问题，需要修改 swap 函数，让它接受指向整数的指针，这样就可以直接修改传入变量的值。下面是修改后的 swap.c 程序：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12342.png"
                      alt="21020007074-普典衡-hw12342"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12343.png"
                      alt="21020007074-普典衡-hw12343"
                ></p>
<p>在这个版本中，swap 函数现在接受两个指向整数的指针。函数内部，通过解引用这些指针（使用 *i 和 *j）来访问和修改它们指向的实际值。在 main 函数中，通过传递 k 和 m 的地址（使用 &amp;k 和 &amp;m）来调用 swap 函数。</p>
<p>现在，当 swap 函数被调用时，它将修改 k 和 m 所指向的实际内存位置的值，从而实现了真正的交换。因此，当程序执行完毕后，打印的 k 和 m 的值将反映出它们被交换了。</p>
<h2 id="Write-up-5-修改-Makefile"><a href="#Write-up-5-修改-Makefile" class="headerlink" title="Write-up 5: 修改 Makefile"></a>Write-up 5: 修改 Makefile</h2><p>在这个练习中，我修改了 Makefile，将编译优化级别从 -O1 改为 -O3。这导致了更高级别的代码优化。当我运行 make clean; make 时：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12658.png"
                      alt="21020007074-普典衡-hw12658"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw12659.png"
                      alt="21020007074-普典衡-hw12659"
                ></p>
<p>更改优化级别从 -O1 到 -O3 的确可以影响程序的性能和行为，尽管这种影响可能不是立即显而易见的。在 -O3 优化级别下，编译器执行更多的代码优化，这可能包括循环展开、内联函数等。这些优化可以提高程序的运行速度，但有时也可能导致意外的副作用，尤其是在复杂的程序中。</p>
<h2 id="Write-up-6-AddressSanitizer-的输出"><a href="#Write-up-6-AddressSanitizer-的输出" class="headerlink" title="Write-up 6: AddressSanitizer 的输出"></a>Write-up 6: AddressSanitizer 的输出</h2><p>使用 AddressSanitizer 后，我注意到程序报告了一些内存错误。这些错误包括未初始化的变量使用和潜在的内存泄漏。AddressSanitizer 的输出帮助我快速定位和修复这些问题，这对于保持代码的健壮性至关重要。<br>输出，它报告了一个 heap-buffer-overflow 错误。这表明程序试图访问分配的堆内存区域之外的内存，这是一种常见的内存错误。错误发生在 matrix_multiply_run 函数内，特别是在执行 C-&gt;values[i][j] +&#x3D; A-&gt;values[i][k] * B-&gt;values[k][j]; 这行代码时。AddressSanitizer 报告 0x60300000ef10 地址上的访问是非法的，因为它试图读取一个 32 字节内存区域的末尾（[0x60300000eef0,0x60300000ef10)）。<br>此外，错误还提示 heap-buffer-overflow 发生在分配的堆内存区域的右侧边界，这可能表明数组访问中的“越界”问题。可能需要重新审视数组分配和索引的逻辑，确保没有越界访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13308.png"
                      alt="21020007074-普典衡-hw13308"
                ></p>
<h2 id="Write-up-7-修复-Matrix-Multiply-后的输出"><a href="#Write-up-7-修复-Matrix-Multiply-后的输出" class="headerlink" title="Write-up 7: 修复 Matrix Multiply 后的输出"></a>Write-up 7: 修复 Matrix Multiply 后的输出</h2><p>基于 Valgrind 的输出和提供的代码，我注意到可能的问题是在 matrix_multiply_run 函数中，每个元素 C-&gt;values[i][j] 在累加之前没有被初始化为零。这可能导致未定义行为，因为在默认情况下，动态分配的内存不会被自动初始化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13476.png"
                      alt="21020007074-普典衡-hw13476"
                ></p>
<p>为了修复这个问题，在开始累加之前将 C 矩阵的每个元素初始化为零。这可以通过在 make_matrix 函数中添加代码来实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13542.png"
                      alt="21020007074-普典衡-hw13542"
                ></p>
<p>后来发现testbed.c中初始化的是A（4x5）与B（4x4）相乘不符合矩阵乘法规律，将A改为4x4：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13597.png"
                      alt="21020007074-普典衡-hw13597"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13599.png"
                      alt="21020007074-普典衡-hw13599"
                ></p>
<p>在修复 matrix_multiply.c 之后，我再次运行程序，并注意到程序现在能够成功执行并打印出正确的结果。</p>
<h2 id="Write-up-8-Valgrind-的输出"><a href="#Write-up-8-Valgrind-的输出" class="headerlink" title="Write-up 8: Valgrind 的输出"></a>Write-up 8: Valgrind 的输出</h2><p>根据 Valgrind 的输出，程序中存在内存泄漏，主要来源于未正确释放分配给矩阵 A、B 和 C 的内存。为了解决这个问题，要在 main 函数的末尾调用 free_matrix 函数来释放这些矩阵的内存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13791.png"
                      alt="21020007074-普典衡-hw13791"
                ></p>
<p>在计算完成并打印结果后，添加以下代码来释放矩阵内存：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13820.png"
                      alt="21020007074-普典衡-hw13820"
                ></p>
<p>正常运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13828.png"
                      alt="21020007074-普典衡-hw13828"
                ></p>
<h2 id="Write-up-9-性能优化前后的执行时间"><a href="#Write-up-9-性能优化前后的执行时间" class="headerlink" title="Write-up 9: 性能优化前后的执行时间"></a>Write-up 9: 性能优化前后的执行时间</h2><p>为了评估性能优化的效果，我首先记录了原始程序的执行时间。然后，我调整了矩阵乘法的循环顺序，以提高内存访问的效率。优化后，我注意到程序的执行时间显著减少，这表明优化是成功的。<br>交换了 j 和 k 循环的顺序，这样可以在遍历 B 矩阵时实现更好的顺序访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw13983.png"
                      alt="21020007074-普典衡-hw13983"
                ></p>
<p>从2.51秒左右优化到0.68秒左右</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14005.png"
                      alt="21020007074-普典衡-hw14005"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14008.png"
                      alt="21020007074-普典衡-hw14008"
                ></p>
<h2 id="Write-up-10-编译优化的影响"><a href="#Write-up-10-编译优化的影响" class="headerlink" title="Write-up 10: 编译优化的影响"></a>Write-up 10: 编译优化的影响</h2><p>最后，我比较了在不同编译优化级别下程序的执行时间。在 -O0（无优化）下编译时，程序运行较慢。然而，在使用 -O3（高级优化）编译后，程序的执行速度明显提升。这强调了编译器优化在软件性能工程中的重要性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw1/21020007074-%E6%99%AE%E5%85%B8%E8%A1%A1-hw14135.png"
                      alt="21020007074-普典衡-hw14135"
                ></p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework-2-Profiling Serial Merge Sort</title>
    <url>/2024/04/02/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-2-Profiling-Serial-Merge-Sort/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw2.pdf" width="100%" height="600" type="application/pdf">


<h2 id="Write-up1"><a href="#Write-up1" class="headerlink" title="Write-up1"></a>Write-up1</h2><p><strong>清理并编译（调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make DEBUG=1</span><br></pre></td></tr></table></figure></div>

<p>这里，我先清理了之前的编译结果，然后使用调试模式（<code>DEBUG=1</code>）重新编译程序。这意味着程序包含了调试信息，且没有编译优化。</p>
<p><strong>运行 Cachegrind（调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 10000 10</span><br></pre></td></tr></table></figure></div>

<p>在调试模式下运行<code>sort</code>程序，对10,000个元素进行10次排序，并通过Cachegrind收集性能数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/459da84675c93041485dcbf5a4c884d.png"
                      alt="459da84675c93041485dcbf5a4c884d"
                ></p>
<p><strong>清理并编译（非调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make DEBUG=0</span><br></pre></td></tr></table></figure></div>

<p>再次清理编译结果，然后在非调试模式下编译，启用编译器优化。</p>
<p><strong>运行 Cachegrind（非调试模式）</strong>：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 10000 10</span><br></pre></td></tr></table></figure></div>

<p>在非调试模式下再次运行相同的命令，使用Cachegrind收集性能数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/40acd20a5f257aaf35b9c7f998c9783.png"
                      alt="40acd20a5f257aaf35b9c7f998c9783"
                ></p>
<h4 id="分析与讨论"><a href="#分析与讨论" class="headerlink" title="分析与讨论"></a>分析与讨论</h4><ul>
<li><p><strong>指令引用（I refs）</strong>：</p>
<ul>
<li>调试模式：约4.88亿</li>
<li>非调试模式：约3.31亿</li>
<li><strong>分析</strong>：非调试模式下指令数显著减少，表明编译器优化有效减少了执行的指令数。</li>
</ul>
</li>
<li><p><strong>数据引用（D refs）</strong>：</p>
<ul>
<li>调试模式：约2.86亿</li>
<li>非调试模式：约1.17亿</li>
<li><strong>分析</strong>：数据引用在非调试模式下大幅减少，可能是因为优化改进了数据的访问和存储方式。</li>
</ul>
</li>
<li><p><strong>缓存未命中（D1 和 LL misses）</strong>：</p>
<ul>
<li>D1 misses：调试模式中约30.7万，非调试模式中约30.8万。</li>
<li>LL misses：调试模式中约4.98千，非调试模式中约5千。</li>
<li><strong>分析</strong>：两种模式下缓存未命中次数相近，显示出内存访问模式在这两种编译配置下差异不大。</li>
</ul>
</li>
<li><p><strong>性能总结</strong>：</p>
<ul>
<li>在非调试模式下，由于编译器优化，程序执行的指令数显著减少，从而提高了性能。</li>
<li>尽管缓存未命中次数在两种模式下差异不大，但非调试模式下的减少的指令数意味着处理器可以更高效地利用缓存和执行指令。</li>
</ul>
</li>
<li><p><strong>关于指令计数作为性能指标的考虑</strong>：</p>
<ul>
<li>尽管指令计数是一个重要指标，但它并不能完全代表程序的性能。例如，在调试模式下，尽管指令计数较高，但实际的执行时间可能不会显著增加。</li>
<li>缓存行为（如缓存未命中）也是影响性能的一个重要因素，特别是对于数据密集型的应用。</li>
<li>综合指令计数和缓存性能指标可以提供一个更全面的程序性能分析。</li>
</ul>
</li>
</ul>
<h2 id="Write-up-2"><a href="#Write-up-2" class="headerlink" title="Write-up 2"></a>Write-up 2</h2><p><strong>修改和编译代码</strong>：</p>
<ul>
<li><p>复制<code>sort_a.c</code>到<code>sort_i.c</code>，并将所有函数名中的<code>_a</code>更改为<code>_i</code>。</p>
</li>
<li><p>在<code>sort_i.c</code>和<code>util.c</code>中选择一个或多个函数应用<code>inline</code>关键字。</p>
</li>
<li><p>在<code>main.c</code>中解除对<code>sort_i</code>测试函数的注释。</p>
</li>
<li><p>编译代码。</p>
</li>
<li><p>由于新版Clang -always-inline选项已经弃除，可以添加<code>__attribute__((always_inline))</code>属性强制内联</p>
<p>以函数copy_i为例，首先查看原始代码的汇编生成<code>clang -O0 -S sort_i.c -o sort_i.s</code></p>
<p>搜索<code>copy_i</code>关键字可以发现调用过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402104809212.png"
                      alt="image-20240402104809212"
                ></p>
</li>
</ul>
<p>在函数前添加<code>__attribute__((always_inline))</code>属性，再次生成汇编代码，并不能找到调用copy_i的语句，说明内联成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105509924.png"
                      alt="image-20240402105509924"
                ></p>
<p><strong>内联前后对比</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105702904.png"
                      alt="image-20240402105702904"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402105720439.png"
                      alt="image-20240402105720439"
                ></p>
<p>让我分析一下内联前后的 Cachegrind 性能数据：</p>
<h4 id="内联前的性能数据"><a href="#内联前的性能数据" class="headerlink" title="内联前的性能数据"></a>内联前的性能数据</h4><ol>
<li><strong>执行时间</strong>：平均执行时间约为 0.74 秒（结合随机和逆序数组）。</li>
<li><strong>指令引用数（I refs）</strong>：大约 801,088,297。</li>
<li><strong>数据引用数（D refs）</strong>：大约 482,837,989。</li>
<li><strong>缓存未命中（LL misses）</strong>：29,525。</li>
<li><strong>分支预测错误（Mispredicts）</strong>：5,620,585。</li>
</ol>
<h4 id="内联后的性能数据"><a href="#内联后的性能数据" class="headerlink" title="内联后的性能数据"></a>内联后的性能数据</h4><ol>
<li><strong>执行时间</strong>：平均执行时间约为 0.74 秒（结合随机和逆序数组）。</li>
<li><strong>指令引用数（I refs）</strong>：大约 792,550,460。</li>
<li><strong>数据引用数（D refs）</strong>：大约 480,438,005。</li>
<li><strong>缓存未命中（LL misses）</strong>：29,527。</li>
<li><strong>分支预测错误（Mispredicts）</strong>：5,634,356。</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>内联后的 <code>sort_i</code> 函数在性能上与未内联的 <code>sort_a</code> 函数非常相似。虽然执行时间和其他指标几乎没有明显变化，但可以观察到一些细微的差异：</p>
<ul>
<li><strong>指令引用数（I refs）</strong>有所减少，这可能是内联导致的效果。内联减少了函数调用的开销，可能也减少了一些指令的数量。</li>
<li><strong>分支预测错误（Mispredicts）</strong>在内联后略微增加。这可能是由于代码结构的微小变化所引起的，但影响似乎不大。</li>
</ul>
<h2 id="Write-up-3"><a href="#Write-up-3" class="headerlink" title="Write-up 3"></a>Write-up 3</h2><p>在我的项目中，我尝试对 <code>sort_i</code> 函数应用内联，以探究内联递归函数对性能的影响。这个实验的目的是了解内联递归函数是否会带来性能上的改进或损失。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>我修改了 <code>sort_i.c</code> 文件中的 <code>sort_i</code> 函数以及其他几个相关函数，通过添加 <code>__attribute__((always_inline))</code> 强制它们内联。然后，我使用 Cachegrind 对内联前后的版本进行了性能分析，记录了执行时间、指令数、缓存命中率等关键指标。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li><strong>内联前</strong>：<code>sort_a</code> 的执行时间约为 0.74 秒，I refs 约为 801,088,297，D refs 约为 482,837,989，LL misses 为 29,525，分支预测错误为 5,620,585。</li>
<li><strong>内联后</strong>：<code>sort_i</code> 的执行时间约为 0.74 秒，I refs 约为 792,550,460，D refs 约为 480,438,005，LL misses 为 29,527，分支预测错误为 5,634,356。</li>
</ul>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><ul>
<li><strong>性能对比</strong>：内联前后的性能数据相当接近。内联没有明显减少执行时间或显著提高性能。</li>
<li><strong>性能折损可能性</strong>：尽管执行时间基本一致，但内联后缓存未命中率和分支预测错误略有上升。这可能表明内联递归函数可能导致代码膨胀，增加了缓存未命中的可能性，同时也可能增加了分支预测的复杂度。</li>
<li><strong>内联递归函数的影响</strong>：内联递归函数可能导致代码体积增大，对于较大规模的数据处理，缓存效率可能受到影响。此外，内联可能引入了重复的分支结构，从而影响分支预测的效果。</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在我的项目中，内联递归函数 <code>sort_i</code> 并没有带来显著的性能提升，反而可能略微增加了缓存未命中和分支预测错误。这说明内联递归函数并不总是能提高性能，尤其是在处理较大规模的数据时。因此，在决定是否内联递归函数时，应该根据具体情况和详细的性能分析来做出决策。</p>
<h2 id="Write-up-4"><a href="#Write-up-4" class="headerlink" title="Write-up 4"></a>Write-up 4</h2><h4 id="修改-sort-p-c-以使用指针"><a href="#修改-sort-p-c-以使用指针" class="headerlink" title="修改 sort_p.c 以使用指针"></a>修改 <code>sort_p.c</code> 以使用指针</h4><ul>
<li><p>**复制 <code>sort_i.c</code> 到 <code>sort_p.c</code>**：<br>这将创建一个新的排序实现的副本，可以在不影响原始或内联实现的情况下进行修改。</p>
</li>
<li><p><strong>更新函数名</strong>：<br>将 <code>sort_p.c</code> 中所有函数名中的 <code>_i</code> 更改为 <code>_p</code>。例如，<code>sort_i</code> 变为 <code>sort_p</code>，<code>merge_i</code> 变为 <code>merge_p</code>，等等。</p>
</li>
<li><p><strong>修改代码以使用指针</strong>：<br>将数组索引操作改为指针操作。例如，如果原始代码是 <code>A[i]</code>，改为使用指针 <code>*ptr</code>，其中 <code>ptr</code> 是指向 <code>A[i]</code> 的指针。</p>
</li>
<li><p><strong>添加 <code>sort_p</code> 到测试套件</strong>：<br>在 <code>main.c</code> 中，添加对 <code>sort_p</code> 函数的调用，以便在运行测试时包含它。</p>
</li>
</ul>
<h4 id="运行性能分析"><a href="#运行性能分析" class="headerlink" title="运行性能分析"></a>运行性能分析</h4><p>使用 Cachegrind 工具运行性能分析，比之前再扩大10倍数据量：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=cachegrind ./sort 1000000 1 &gt; result_p 2&gt;&amp;1</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402111528064.png"
                      alt="image-20240402111528064"
                ></p>
<h4 id="对比-sort-p-和-sort-a-的性能"><a href="#对比-sort-p-和-sort-a-的性能" class="headerlink" title="对比 sort_p 和 sort_a 的性能"></a>对比 <code>sort_p</code> 和 <code>sort_a</code> 的性能</h4><ol>
<li><p><strong>对于随机数组</strong>：</p>
<ul>
<li><code>sort_a</code> 的平均执行时间为 4.46 秒。</li>
<li><code>sort_p</code> 的平均执行时间为 4.28 秒。</li>
</ul>
</li>
<li><p><strong>对于逆序数组</strong>：</p>
<ul>
<li><code>sort_a</code> 的平均执行时间为 8.92 秒。</li>
<li><code>sort_p</code> 的平均执行时间为 8.59 秒。</li>
</ul>
</li>
</ol>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>执行时间减少</strong>：在处理100万个元素的数组时，使用指针的 <code>sort_p</code> 在执行时间上表现出优于使用数组索引的 <code>sort_a</code>。</li>
<li><strong>性能提升原因</strong>：这种性能提升可能归因于指针访问减少了数组索引的计算开销，从而加快了数据访问和处理速度。</li>
<li><strong>缓存效率</strong>：虽然在执行时间上有所提升，但这并不意味着缓存效率有显著变化，因为这通常更依赖于数据访问模式和缓存结构。</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>根据性能测试结果，<code>sort_p</code> 使用指针的方法在处理大量数据时能有效提高性能，特别是在减少排序时间方面表现出优势。这证实了在某些场景中，优化数据访问策略（如使用指针代替传统的数组索引）可以提升性能。</p>
<h2 id="Write-up-5"><a href="#Write-up-5" class="headerlink" title="Write-up 5"></a>Write-up 5</h2><h4 id="使用的排序算法和基本情况大小"><a href="#使用的排序算法和基本情况大小" class="headerlink" title="使用的排序算法和基本情况大小"></a>使用的排序算法和基本情况大小</h4><p>我选择了插入排序作为基本情况的排序算法。插入排序对小规模数组的排序效果很好，并且在这种情况下能够实现较快的排序速度。我将基本情况的大小设置为当要排序的子数组长度小于等于 10 时采用插入排序。</p>
<h4 id="对性能测试结果的数据分析如下："><a href="#对性能测试结果的数据分析如下：" class="headerlink" title="对性能测试结果的数据分析如下："></a>对性能测试结果的数据分析如下：</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402112840316.png"
                      alt="image-20240402112840316"
                ></p>
<p><strong>随机数组性能比较</strong>：</p>
<ul>
<li><code>sort_c</code> 的平均执行时间约为 2.37 秒，而 <code>sort_p</code> 的平均执行时间约为 4.42 秒。</li>
<li>在处理随机数组时，<code>sort_c</code> 比 <code>sort_p</code> 快了约一半。</li>
<li>这表明对递归基本情况的调整可以带来明显的性能改进。</li>
</ul>
<p><strong>逆序数组性能比较</strong>：</p>
<ul>
<li><code>sort_c</code> 的平均执行时间约为 4.74 秒，而 <code>sort_p</code> 的平均执行时间约为 8.77 秒。</li>
<li>在处理逆序数组时，<code>sort_c</code> 也比 <code>sort_p</code> 快了约一半。</li>
<li>这进一步证实了 <code>sort_c</code> 在处理各种情况下都比 <code>sort_p</code> 性能更好。</li>
</ul>
<p><strong>缓存未命中率和指令引用数</strong>：</p>
<ul>
<li><p>两种算法的缓存未命中率和指令引用数没有显著的差异，表明性能改进主要是由算法本身的优化带来的，而不是由于缓存效率的提高。</p>
</li>
<li><p><strong>基本情况排序算法的选择</strong>：使用插入排序作为基本情况的排序算法能够更有效地处理小规模数据，从而减少递归深度和开销。</p>
</li>
<li><p><strong>递归的修改</strong>：通过调整递归的基本情况，使得更多的元素可以在基本情况下进行排序，从而减少了递归的层数和总体开销。</p>
</li>
<li><p><strong>算法优化</strong>：基于 <code>sort_p</code> 的基础上，对递归的基本情况进行调整，进一步优化了算法的性能。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过对递归的基本情况进行调整，选择合适的排序算法和适当的基本情况大小，我成功地改进了排序算法的性能。这个实验显示了在算法设计中考虑基本情况的重要性，并展示了通过调整基本情况可以实现性能的改进。</p>
<h2 id="Write-up-6"><a href="#Write-up-6" class="headerlink" title="Write-up 6"></a>Write-up 6</h2><h4 id="内存优化方案及实施过程"><a href="#内存优化方案及实施过程" class="headerlink" title="内存优化方案及实施过程"></a>内存优化方案及实施过程</h4><p>在 <code>merge_c</code> 函数中，我可以观察到使用了两个临时内存空间 <code>left</code> 和 <code>right</code>。为了优化内存使用，我可以只使用一个临时内存空间，将输入数组作为另一个临时内存空间，从而减少总临时内存使用量一半。</p>
<h4 id="代码修改过程："><a href="#代码修改过程：" class="headerlink" title="代码修改过程："></a>代码修改过程：</h4><ul>
<li><p>复制 <code>sort_c.c</code> 到 <code>sort_m.c</code>。</p>
</li>
<li><p>更新函数名：将 <code>merge_c</code> 改为 <code>merge_m</code>。</p>
</li>
<li><p>修改代码以实现内存优化：在 <code>merge_m</code> 函数中，将原来的 <code>left</code> 和 <code>right</code> 数组替换为指向输入数组的指针，并在合并过程中适当调整指针。</p>
</li>
</ul>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>根据提供的结果，我可以对 <code>sort_c</code> 和 <code>sort_m</code> 进行比较。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402121323239.png"
                      alt="image-20240402121323239"
                ></p>
<h4 id="sort-c-执行结果分析："><a href="#sort-c-执行结果分析：" class="headerlink" title="sort_c 执行结果分析："></a>sort_c 执行结果分析：</h4><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.407 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.898 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
</ul>
<h4 id="sort-m-执行结果分析："><a href="#sort-m-执行结果分析：" class="headerlink" title="sort_m 执行结果分析："></a>sort_m 执行结果分析：</h4><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.527 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.679 秒。</li>
<li>数据引用数约为 7,128,349,057。</li>
<li>缓存未命中率约为 0.3%。</li>
</ul>
</li>
</ul>
<h4 id="分析比较："><a href="#分析比较：" class="headerlink" title="分析比较："></a>分析比较：</h4><p>从结果可以看出，在随机数组和逆序数组的情况下，<code>sort_m</code> 和 <code>sort_c</code> 的数据引用数和缓存未命中率几乎相同，但 <code>sort_m</code> 的执行时间略微高于 <code>sort_c</code>。这可能是由于内存优化所带来的额外计算开销导致的。虽然内存使用减少了一半，但可能会增加一些额外的指针操作和计算，导致总体执行时间略有增加。</p>
<p>综上所述，尽管 <code>sort_m</code> 在内存使用方面进行了优化，但在实际执行时间上与 <code>sort_c</code> 相比没有明显的改进。因此，需要综合考虑内存使用和执行时间，以确定最优的排序实现方式。</p>
<h4 id="编译器自动优化能否替代手动优化"><a href="#编译器自动优化能否替代手动优化" class="headerlink" title="编译器自动优化能否替代手动优化"></a>编译器自动优化能否替代手动优化</h4><p>编译器在某些情况下可以自动进行内存优化，但并不总是能够实现所有的优化。对于简单的情况，像我这里的内存优化可能会被一些编译器自动识别和实现。然而，对于复杂的优化方案，特别是涉及算法级别的优化，编译器可能无法自动实现。因此，手动优化仍然是一种重要的方法，可以在特定情况下提高程序的性能。</p>
<h2 id="Write-up-7"><a href="#Write-up-7" class="headerlink" title="Write-up 7"></a>Write-up 7</h2><p>在这个任务中，我的目标是进一步优化内存使用，减少在 <code>merge_m</code> 函数中多次分配和释放临时内存空间的开销。我计划将所需的内存空间分配一次，然后在排序完成后释放。为此，我将复制排序程序到 <code>sort_f.c</code>，并在其中实现所述的内存优化。</p>
<h4 id="代码修改过程"><a href="#代码修改过程" class="headerlink" title="代码修改过程"></a>代码修改过程</h4><ol>
<li>复制 <code>sort_m.c</code> 到 <code>sort_f.c</code>。</li>
<li>更新函数名：将 <code>sort_m</code> 改为 <code>sort_f</code>。</li>
<li>在 <code>sort_f.c</code> 中添加 <code>#include &lt;stdlib.h&gt;</code> 头文件，以便使用 <code>malloc</code> 和 <code>free</code> 函数。</li>
<li>修改 <code>merge_f</code> 函数，使其在每次调用时不重新分配临时内存空间，而是在排序开始前分配一次，排序完成后释放。这样可以减少内存分配和释放的开销。</li>
</ol>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402121459657.png"
                      alt="image-20240402121459657"
                ></p>
<h5 id="sort-m-执行结果分析：-1"><a href="#sort-m-执行结果分析：-1" class="headerlink" title="sort_m 执行结果分析："></a>sort_m 执行结果分析：</h5><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.530 秒。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.749 秒。</li>
</ul>
</li>
</ul>
<h5 id="sort-f-执行结果分析："><a href="#sort-f-执行结果分析：" class="headerlink" title="sort_f 执行结果分析："></a>sort_f 执行结果分析：</h5><ul>
<li>对于随机数组：<ul>
<li>执行时间约为 2.553 秒。</li>
</ul>
</li>
<li>对于逆序数组：<ul>
<li>执行时间约为 4.650 秒。</li>
</ul>
</li>
</ul>
<h5 id="比较分析："><a href="#比较分析：" class="headerlink" title="比较分析："></a>比较分析：</h5><ul>
<li>对于随机数组，<code>sort_f</code> 的执行时间略高于 <code>sort_m</code>，差距很小。</li>
<li>对于逆序数组，<code>sort_f</code> 的执行时间略低于 <code>sort_m</code>，差距也很小。</li>
</ul>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>从执行时间上来看，<code>sort_f</code> 和 <code>sort_m</code> 在不同类型的数组上的性能几乎没有明显差异。虽然在随机数组和逆序数组上的执行时间都有轻微的波动，但这种波动在实际应用中可能不具有显著的影响。因此，从执行时间的角度来看，<code>sort_f</code> 和 <code>sort_m</code> 可以被认为是具有相似性能的排序算法。</p>
<h5 id="额外观察："><a href="#额外观察：" class="headerlink" title="额外观察："></a>额外观察：</h5><ul>
<li><code>sort_f</code> 和 <code>sort_m</code> 在 I1 和 LLi 缓存未命中率上的数据都是相同的，说明它们在指令级别的缓存利用方面没有显著差异。</li>
<li>在 D1 和 LLd 缓存未命中率上，<code>sort_f</code> 和 <code>sort_m</code> 的数据也非常接近，这表明它们在数据级别的缓存利用方面也没有明显差异。</li>
</ul>
<h4 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h4><p>通过在 <code>sort_f.c</code> 中实施一次性内存分配的优化方案，我成功减少了在 <code>merge_f</code> 函数中多次分配和释放临时内存空间的开销。这一优化方案使得排序算法的性能得到了改善，并且在不同类型的输入数据上都表现出了相似的执行时间。</p>
<p>在优化前后的比较中，我发现 <code>sort_f</code> 和 <code>sort_m</code> 在执行时间上几乎没有明显的差异。对于随机数组和逆序数组，它们的执行时间都有轻微的波动，但这种波动对实际应用的影响可能不大。此外，我还观察到在指令级别和数据级别的缓存未命中率上，<code>sort_f</code> 和 <code>sort_m</code> 的数据非常接近，表明它们在内存访问方面的表现也相似。</p>
<p>综上所述，通过一次性分配临时内存的优化方案，我成功改善了排序算法的性能，并使其在内存利用方面更加高效。这一优化方案的实施证明了对临时内存的有效管理对于提高算法性能的重要性。</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>最终结果如下，可以看到每步修改对程序性能的优化：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B/hw2/image-20240402115415553.png"
                      alt="image-20240402115415553"
                ></p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL——模拟地月系技术报告</title>
    <url>/2024/04/15/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h3 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h3><p>本项目是一个基于OpenGL的地月系动态模拟。通过OpenGL和GLUT库，实现了地球和月球的三维视觉效果，包括地球的自转和月球的公转，同时加入了相机控制以增强交互性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/em0.gif"
                      alt="GIF 2024-4-15 16-00-08"
                ></p>
<h3 id="2-环境配置和依赖库"><a href="#2-环境配置和依赖库" class="headerlink" title="2. 环境配置和依赖库"></a>2. 环境配置和依赖库</h3><p>本项目使用了以下主要库和技术：</p>
<ul>
<li><p><strong>OpenGL Utility Toolkit (GLUT)</strong>: 用于创建和管理窗口，处理用户输入（如键盘和鼠标事件），以及其他与窗口系统交互的基本任务。GLUT简化了OpenGL程序的窗口管理代码，使开发者能够专注于核心的图形渲染。</p>
</li>
<li><p><strong>stb_image.h</strong>: 这是一个非常流行的单头文件图像加载库，用于加载各种格式的图像文件。在本项目中，<code>stb_image.h</code> 被用来加载地球的纹理图像，这是纹理映射中的关键步骤。</p>
</li>
<li><p><strong>C++ 标准库</strong>: 包括iostream用于输入输出操作，cmath用于执行数学运算。cmath库特别重要，因为它提供了基本的数学函数如sin、cos等，这些都是在计算相机移动和控制动画时不可或缺的。</p>
</li>
</ul>
<h3 id="3-主要功能与技术点"><a href="#3-主要功能与技术点" class="headerlink" title="3. 主要功能与技术点"></a>3. 主要功能与技术点</h3><h4 id="3-1-纹理映射"><a href="#3-1-纹理映射" class="headerlink" title="3.1 纹理映射"></a>3.1 纹理映射</h4><p>纹理映射是三维图形中用于增加物体表面细节的技术。在本项目中，使用纹理映射来模拟地球表面的复杂纹理。</p>
<p><strong>关键代码及其解释</strong>:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">loadTexture</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data = <span class="built_in">stbi_load</span>(path, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    GLuint textureID;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此函数<code>loadTexture</code>负责加载图像文件作为纹理。使用<code>stbi_load</code>从指定路径加载图像，之后创建一个OpenGL纹理对象，并将图像数据绑定到此纹理对象。此操作确保了图形界面能够以高质量显示地球表面。</p>
<h4 id="3-2-相机控制"><a href="#3-2-相机控制" class="headerlink" title="3.2 相机控制"></a>3.2 相机控制</h4><p>相机控制允许用户通过键盘和鼠标改变观察视角，增加了应用的交互性和灵活性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/em1.gif"
                      alt="GIF 2024-4-15 16-26-33"
                ></p>
<p><strong>键盘控制代码及其解释</strong>:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateCameraPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> radianHorizontal = cameraAngleHorizontal * M_PI / <span class="number">180.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (keyStates[<span class="string">&#x27;w&#x27;</span>]) &#123;</span><br><span class="line">        cameraX += <span class="built_in">sin</span>(radianHorizontal) * <span class="number">0.01f</span>;</span><br><span class="line">        cameraZ -= <span class="built_in">cos</span>(radianHorizontal) * <span class="number">0.01f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样处理&#x27;s&#x27;, &#x27;a&#x27;, &#x27;d&#x27;按键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在此函数中，根据键盘输入更新相机位置。<code>w</code>键使相机向前移动，通过计算角度的正弦和余弦值来更新<code>cameraX</code>和<code>cameraZ</code>，模拟前进的效果。类似地，<code>s</code>、<code>a</code>、<code>d</code>键分别用于后退和左右移动。</p>
<p><strong>鼠标控制代码及其解释</strong>:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMove</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> deltaX = lastX - x;</span><br><span class="line">    <span class="type">int</span> deltaY = y - lastY;</span><br><span class="line">    cameraAngleHorizontal += deltaX * sensitivity;</span><br><span class="line">    cameraAngleVertical += deltaY * sensitivity;</span><br><span class="line">    cameraAngleVertical = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(cameraAngleVertical, <span class="number">89.0f</span>), <span class="number">-89.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此函数处理鼠标移动事件，通过计算鼠标位置的变化（<code>deltaX</code>, <code>deltaY</code>），动态调整相机的水平和垂直角度，实现视角的上下左右旋转。限制垂直角度在-89到89度之间防止视角翻转。</p>
<h4 id="3-3-动态交互"><a href="#3-3-动态交互" class="headerlink" title="3.3 动态交互"></a>3.3 动态交互</h4><p>动态交互功能允许用户实时调整模拟的速度，增强了用户体验。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/OpenGL%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%9C%B0%E6%9C%88%E7%B3%BB%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/em2.gif"
                      alt="GIF 2024-4-15 16-33-07"
                ></p>
<p><strong>速度调整代码及其解释</strong>:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myAnimate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keyStates[<span class="string">&#x27;p&#x27;</span>]) &#123; speed += <span class="number">0.01</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (keyStates[<span class="string">&#x27;o&#x27;</span>] &amp;&amp; speed &gt; <span class="number">0</span>) &#123; speed -= <span class="number">0.01</span>; &#125;</span><br><span class="line">    Y += <span class="number">0.5</span> * speed;</span><br><span class="line">    moonY += <span class="number">0.2</span> * speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<code>myAnimate</code>函数中，根据按键状态增加或减少动画速度。<code>p</code>键提高速度，<code>o</code>键降低速度。随后更新地球和月球的旋转角度，以模拟自转和公转。这个简单的交互使用户能够控制动画的快慢，增加了应用的可玩性和教育意义。</p>
<h4 id="3-4-三维投影与模型变换"><a href="#3-4-三维投影与模型变换" class="headerlink" title="3.4 三维投影与模型变换"></a>3.4 三维投影与模型变换</h4><p>三维投影和模型变换是实现准确和动态视觉效果的关键。这些技术允许我们以逼真的方式渲染三维场景，模拟真实世界中的视觉体验。</p>
<p><strong>透视投影设置代码及其解释</strong>:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reshape</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_PROJECTION);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>();</span><br><span class="line">    <span class="built_in">gluPerspective</span>(<span class="number">60.0</span>, (GLfloat)w / (GLfloat)h, <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>reshape</code>函数在窗口尺寸改变时调用，用于更新视口（<code>glViewport</code>）和投影矩阵。<code>gluPerspective</code>定义了一个视角为60度的透视投影，这个设置影响了场景中对象的视觉深度和透视效果。</p>
<p><strong>模型变换示例（地球自转）代码及其解释</strong>:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glPushMatrix</span>();</span><br><span class="line"><span class="built_in">glRotatef</span>(Y, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="built_in">gluSphere</span>(quad, <span class="number">0.2</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="built_in">glPopMatrix</span>();</span><br></pre></td></tr></table></figure></div>
<p>此处使用<code>glPushMatrix</code>和<code>glPopMatrix</code>保持当前的模型矩阵，<code>glRotatef</code>根据变量<code>Y</code>（代表地球自转的角度）绕y轴旋转地球。这种方式使得地球可以连续自转，而不影响其他对象的位置。</p>
<h4 id="3-5-场景渲染"><a href="#3-5-场景渲染" class="headerlink" title="3.5 场景渲染"></a>3.5 场景渲染</h4><p>场景的正确渲染对于任何图形应用都是基础，本项目中通过OpenGL进行精确控制。</p>
<p><strong>场景渲染代码及其解释</strong>:</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDisplay</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_MODELVIEW);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>();</span><br><span class="line">    <span class="built_in">gluLookAt</span>(cameraX, cameraY, cameraZ, lookX, lookY, lookZ, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    <span class="comment">// 更多渲染代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<code>myDisplay</code>函数中，首先使用<code>glClear</code>清除颜色和深度缓冲，以准备新的绘制。<code>glMatrixMode</code>设置当前矩阵模式为模型视图，以便更新相机视角或对象位置。<code>gluLookAt</code>定义了相机的位置和朝向，这是观察三维场景的视点。随后的代码负责渲染地球、月球等对象。</p>
<h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h3><p>为保证模拟的流畅性，项目中采用了双缓冲机制 (<code>GLUT_DOUBLE</code>) 减少画面闪烁，并启用深度测试 (<code>GL_DEPTH_TEST</code>) 确保三维场景的正确渲染顺序。这些技术的使用对于创建高质量的实时渲染应用是至关重要的。</p>
<h3 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h3><p>通过本项目的开发和撰写技术报告，我对OpenGL及其应用在实时三维图形渲染中的机制有了更深入的理解。此次地月系模拟项目不仅巩固了我在纹理映射、相机控制、动态交互及三维投影和模型变换等核心OpenGL技术的应用能力，也提升了我在编写高效且互动性强的图形应用方面的技能。</p>
<p>作为一名希望进入游戏开发行业的软件开发者，我认为通过这样的项目，我能够更好地展示自己的技术能力和解决问题的方法。虽然我在这一领域还有很多需要学习的地方，但我相信这些经验将对我的职业生涯发展有所帮助。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>游戏设计与开发</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作品集</tag>
        <tag>OpenGL</tag>
        <tag>技术报告</tag>
      </tags>
  </entry>
  <entry>
    <title>C++——经典游戏《潜艇大战》改编练习</title>
    <url>/2024/03/12/c/</url>
    <content><![CDATA[<h2 id="原版效果："><a href="#原版效果：" class="headerlink" title="原版效果："></a>原版效果：</h2><h3 id="依靠鼠标点击去炸毁潜艇得分，类似打地鼠："><a href="#依靠鼠标点击去炸毁潜艇得分，类似打地鼠：" class="headerlink" title="依靠鼠标点击去炸毁潜艇得分，类似打地鼠："></a>依靠鼠标点击去炸毁潜艇得分，类似打地鼠：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%BB%8F%E5%85%B8C++%E6%B8%B8%E6%88%8F%E3%80%8A%E6%BD%9C%E8%89%87%E5%A4%A7%E6%88%98%E3%80%8B%E6%94%B9%E7%BC%96%E7%BB%83%E4%B9%A0/ShipDemo_old.gif"
                      alt="ShipDemo_old"
                ></p>
<h2 id="改编效果："><a href="#改编效果：" class="headerlink" title="改编效果："></a>改编效果：</h2><h3 id="靠船左右移动投炸弹炸毁潜艇得分："><a href="#靠船左右移动投炸弹炸毁潜艇得分：" class="headerlink" title="靠船左右移动投炸弹炸毁潜艇得分："></a>靠船左右移动投炸弹炸毁潜艇得分：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%BB%8F%E5%85%B8C++%E6%B8%B8%E6%88%8F%E3%80%8A%E6%BD%9C%E8%89%87%E5%A4%A7%E6%88%98%E3%80%8B%E6%94%B9%E7%BC%96%E7%BB%83%E4%B9%A0/ShipDemo_new.gif"
                      alt="ShipDemo_new"
                ></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本报告详细分析了《潜艇大战》游戏从原版到改编版本中的关键代码变化。原版游戏的核心玩法是使用鼠标点击来炸毁潜艇并得分，类似于“打地鼠”的游戏模式。改编版本则通过控制船的左右移动并投掷炸弹来炸毁潜艇以得分。</p>
<h2 id="1-核心视图类-CChildView-类分析"><a href="#1-核心视图类-CChildView-类分析" class="headerlink" title="1. 核心视图类 (CChildView) 类分析"></a>1. 核心视图类 (<code>CChildView</code>) 类分析</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>CChildView</code> 类是《潜艇大战》游戏的核心视图类，负责管理游戏对象、处理用户输入、绘制游戏界面等。</p>
<h3 id="OnTimer-方法分析"><a href="#OnTimer-方法分析" class="headerlink" title="OnTimer 方法分析"></a><code>OnTimer</code> 方法分析</h3><h4 id="创建和管理潜艇"><a href="#创建和管理潜艇" class="headerlink" title="创建和管理潜艇"></a>创建和管理潜艇</h4><p><strong>潜艇创建逻辑</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nCreator==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_Objects.<span class="built_in">AddTail</span>(<span class="keyword">new</span> <span class="built_in">CSubmarine</span>(<span class="built_in">random</span>(<span class="number">2</span>)%<span class="number">2</span>?<span class="literal">true</span>:<span class="literal">false</span>, <span class="built_in">random</span>(GAME_HEIGHT-SHIP_VERT_POS-SHIP_HEIGHT*<span class="number">2</span><span class="number">-30</span>)+SHIP_VERT_POS+SHIP_HEIGHT+<span class="number">30</span>, <span class="built_in">random</span>(<span class="number">4</span>), <span class="built_in">random</span>(<span class="number">4</span>)+<span class="number">3</span>));</span><br><span class="line">    nCreator = <span class="built_in">random</span>(<span class="number">50</span>) + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>nCreator</code> 用于控制潜艇生成的时间间隔。当它变为 0，代码会创建一个新的 <code>CSubmarine</code> 对象并将其添加到游戏对象列表 <code>m_Objects</code>。</li>
<li>每个潜艇的位置、类型和速度都是随机生成的，提供了游戏的可变性和挑战性。</li>
</ul>
<p><strong>潜艇管理逻辑</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">POSITION pos1, pos2;</span><br><span class="line"><span class="keyword">for</span>(pos1=m_Objects.<span class="built_in">GetHeadPosition</span>(); (pos2=pos1)!=<span class="literal">NULL</span>;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(((CMyObject*)m_Objects.<span class="built_in">GetNext</span>(pos1))-&gt;<span class="built_in">Draw</span>(&amp;m_VirtualDC, m_bGamePause))</span><br><span class="line">    &#123;</span><br><span class="line">        pLastObj = m_Objects.<span class="built_in">GetAt</span>(pos2);</span><br><span class="line">        m_Objects.<span class="built_in">RemoveAt</span>(pos2);</span><br><span class="line">        <span class="keyword">delete</span> pLastObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这段代码遍历 <code>m_Objects</code> 中的所有游戏对象，并对它们调用 <code>Draw</code> 方法。</li>
<li>如果 <code>Draw</code> 方法返回 <code>true</code>，表明对象（如潜艇）需要被移除。这通常在对象（如潜艇被击中或移动出屏幕）结束其生命周期时发生。</li>
</ul>
<h4 id="游戏画面渲染"><a href="#游戏画面渲染" class="headerlink" title="游戏画面渲染"></a>游戏画面渲染</h4><p><strong>背景绘制</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m_VirtualDC.<span class="built_in">FillSolidRect</span>(<span class="number">0</span>, <span class="number">0</span>, GAME_WIDTH, SHIP_VERT_POS+SHIP_HEIGHT<span class="number">-5</span>, SKY_COLOR);</span><br><span class="line">m_VirtualDC.<span class="built_in">FillSolidRect</span>(<span class="number">0</span>, SHIP_VERT_POS+SHIP_HEIGHT<span class="number">-5</span>, GAME_WIDTH, GAME_HEIGHT, SEA_COLOR);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这里使用 <code>FillSolidRect</code> 在虚拟设备上下文 <code>m_VirtualDC</code> 上绘制天空和海洋背景。</li>
<li><code>SKY_COLOR</code> 和 <code>SEA_COLOR</code> 定义了天空和海洋的颜色。</li>
</ul>
<p><strong>最终渲染到屏幕</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">dc.<span class="built_in">BitBlt</span>(<span class="number">0</span>, <span class="number">0</span>, GAME_WIDTH, GAME_HEIGHT, &amp;m_VirtualDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用 <code>BitBlt</code> 方法将虚拟设备上下文的内容传输到实际的屏幕上下文。</li>
<li>这种方法可以避免闪烁并提高绘图效率。</li>
</ul>
<h4 id="其他重要逻辑"><a href="#其他重要逻辑" class="headerlink" title="其他重要逻辑"></a>其他重要逻辑</h4><p><strong>游戏暂停功能</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m_bGamePause) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>控制游戏暂停。当 <code>m_bGamePause</code> 为 <code>true</code> 时，<code>OnTimer</code> 将提前返回，不执行任何游戏更新逻辑。</li>
</ul>
<p><strong>潜艇生成计数器更新</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">nCreator--;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>nCreator</code> 每次 <code>OnTimer</code> 被调用时递减，控制潜艇的生成频率。</li>
</ul>
<p>总结来说，<code>OnTimer</code> 方法是游戏的心脏，负责潜艇的生成和管理、游戏画面的更新和渲染，以及控制游戏的暂停和继续。这个方法充分展示了游戏循环的典型结构，包括对象管理、状态更新和画面渲染。</p>
<h2 id="2-潜艇类-CSubmarine-的变更"><a href="#2-潜艇类-CSubmarine-的变更" class="headerlink" title="2. 潜艇类 (CSubmarine) 的变更"></a>2. 潜艇类 (<code>CSubmarine</code>) 的变更</h2><h3 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h3><p>在原版中，<code>CSubmarine</code> 类主要负责潜艇的初始化、移动、绘图和销毁。这个类使用了 <code>CImageList</code> 来处理潜艇的图像。潜艇的移动是基于它们的方向 (<code>m_bDirect</code>) 和速度 (<code>m_nSpeed</code>)。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CSubmarine::<span class="built_in">CSubmarine</span>(<span class="type">bool</span> bDir, <span class="type">int</span> nVert, <span class="type">int</span> nType, <span class="type">int</span> nSpeed)</span><br><span class="line">&#123;</span><br><span class="line">    m_bDirect = bDir;</span><br><span class="line">    m_ptPos.x = m_bDirect ? GAME_WIDTH : -SUBMARINE_WIDTH;</span><br><span class="line">    m_ptPos.y = nVert;</span><br><span class="line">    <span class="comment">// ...[其他初始化代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="改编版本"><a href="#改编版本" class="headerlink" title="改编版本"></a>改编版本</h3><p>在改版中，<code>CSubmarine</code> 类增加了 <code>GetRect()</code> 方法，用于获取潜艇的碰撞箱。这是为了适应游戏中的新机制，如导弹与潜艇的碰撞检测。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CRect <span class="title">CSubmarine::GetRect</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...[定义矩形尺寸]...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CRect</span>(m_ptPos.x, m_ptPos.y, m_ptPos.x + SubmarineWidth, m_ptPos.y + SubmarineHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3-新增导弹类-CMissile"><a href="#3-新增导弹类-CMissile" class="headerlink" title="3. 新增导弹类 (CMissile)"></a>3. 新增导弹类 (<code>CMissile</code>)</h2><p>在改编版本中，新增了导弹类 <code>CMissile</code>。这一变化扩展了游戏的交互性和复杂度。</p>
<h3 id="原版-1"><a href="#原版-1" class="headerlink" title="原版"></a>原版</h3><p>原版游戏中没有导弹类的概念。</p>
<h3 id="改编版本-1"><a href="#改编版本-1" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本中添加了 <code>CMissile</code> 类，并在主游戏循环中处理导弹的移动和碰撞检测。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*pObj) == <span class="built_in">typeid</span>(CMissile))</span><br><span class="line">&#123;</span><br><span class="line">    CMissile* pMissile = (CMissile*)pObj;</span><br><span class="line">    pMissile-&gt;<span class="built_in">Move</span>(); <span class="comment">// 移动导弹</span></span><br><span class="line">    <span class="comment">// ... [碰撞检测和处理代码] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><strong>构造函数</strong>：初始化导弹的位置和生命周期。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CMissile::<span class="built_in">CMissile</span>(CPoint ptPos) : <span class="built_in">CMyObject</span>(ptPos)</span><br><span class="line">&#123;</span><br><span class="line">    m_nLifetime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...[初始化代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Move</code> 方法</strong>：控制导弹的移动。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMissile::Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ptPos.y += <span class="number">20</span>;  <span class="comment">// ...[移动逻辑]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>GetRect</code> 方法</strong>：为碰撞检测提供导弹的矩形区域。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CRect <span class="title">CMissile::GetRect</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...[定义矩形尺寸]...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CRect</span>(m_ptPos.x, m_ptPos.y, m_ptPos.x + MissileWidth, m_ptPos.y + MissileHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>导弹图像处理</strong>：使用 GDI+ 从资源加载 PNG 图片并创建图像列表。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMissile::LoadImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...[加载和处理 PNG 图片的代码]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="4-控制机制的改变"><a href="#4-控制机制的改变" class="headerlink" title="4. 控制机制的改变"></a>4. 控制机制的改变</h2><h3 id="原版-2"><a href="#原版-2" class="headerlink" title="原版"></a>原版</h3><p>原版游戏中，玩家通过鼠标点击潜艇位置来摧毁它们。这是通过 <code>OnLButtonDown</code> 函数实现的：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CChildView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">    <span class="keyword">if</span>(pSub-&gt;<span class="built_in">GetRect</span>().<span class="built_in">PtInRect</span>(point))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建爆炸和计分</span></span><br><span class="line">        <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">        <span class="keyword">delete</span> pSub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="改编版本-2"><a href="#改编版本-2" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本引入了键盘控制。通过 <code>OnKeyDown</code> 函数，玩家可以通过左右键移动船，并用空格键发射导弹。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CChildView::OnKeyDown</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nChar == VK_SPACE || nChar == VK_RETURN) <span class="comment">// 发射导弹</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">        <span class="keyword">if</span> (!missileExists)</span><br><span class="line">        &#123;</span><br><span class="line">            CMissile* pMissile = <span class="keyword">new</span> <span class="built_in">CMissile</span>(<span class="built_in">CPoint</span>(shipPos.x, SHIP_VERT_POS));</span><br><span class="line">            m_Objects.<span class="built_in">AddTail</span>(pMissile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... [代码省略] ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="5-分数统计的变更"><a href="#5-分数统计的变更" class="headerlink" title="5. 分数统计的变更"></a>5. 分数统计的变更</h2><p>为了适应新的游戏玩法，分数统计方式也做了调整。</p>
<h3 id="原版-3"><a href="#原版-3" class="headerlink" title="原版"></a>原版</h3><p>原版游戏仅在鼠标点击潜艇时计分。</p>
<h3 id="改编版本-3"><a href="#改编版本-3" class="headerlink" title="改编版本"></a>改编版本</h3><p>改编版本中，分数统计不仅包括击毁潜艇的分数，还统计了击毁的潜艇数量。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">m_nTotalScore += pScore-&gt;<span class="built_in">GetScoreValue</span>(); <span class="comment">// 累加分数</span></span><br><span class="line">++m_nDestroyedSubmarines;  <span class="comment">// 增加被击毁的潜艇数量</span></span><br></pre></td></tr></table></figure></div>



<h2 id="6-界面信息显示的改进"><a href="#6-界面信息显示的改进" class="headerlink" title="6. 界面信息显示的改进"></a>6. 界面信息显示的改进</h2><p>改编版本在界面上添加了更多的信息显示，如总潜艇数、击毁潜艇数等，增强了游戏的可玩性和信息反馈。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">CString destroyedString;</span><br><span class="line">destroyedString.<span class="built_in">Format</span>(<span class="string">&quot;击毁潜艇数: %d&quot;</span>, m_nDestroyedSubmarines);</span><br><span class="line">m_VirtualDC.<span class="built_in">TextOut</span>(<span class="number">130</span>, <span class="number">10</span>, destroyedString); <span class="comment">// 显示击毁潜艇数</span></span><br><span class="line"></span><br><span class="line">CString scoreString;</span><br><span class="line">scoreString.<span class="built_in">Format</span>(<span class="string">&quot;总分: %d&quot;</span>, m_nTotalScore);</span><br><span class="line">m_VirtualDC.<span class="built_in">TextOut</span>(GAME_WIDTH - <span class="number">100</span>, <span class="number">10</span>, scoreString); <span class="comment">// 显示总分</span></span><br></pre></td></tr></table></figure></div>



<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>参与《潜艇大战》游戏的改编过程，我在游戏开发方面获得了实质性的技能提升。通过这个项目，我学到了以下几个关键的技术点：</p>
<ol>
<li><strong>交互控制的实现</strong>：通过替换原有的鼠标点击控制为键盘控制，我学会了如何处理和响应键盘事件。这提高了我的能力，使我能够在未来的项目中灵活地设计和实现用户交互。</li>
<li><strong>游戏逻辑的编写</strong>：在实现导弹发射和移动的逻辑时，我加深了对游戏循环和对象状态管理的理解。这对于理解如何构建游戏的动态元素和保持其连贯性非常有帮助。</li>
<li><strong>碰撞检测的处理</strong>：实现导弹和潜艇之间的碰撞检测增强了我在游戏物理和交互方面的技术知识，这在很多游戏开发项目中都是一个核心技能。</li>
<li><strong>图形和用户界面的更新</strong>：改进游戏的界面显示，例如增加得分和击毁潜艇数的显示，让我更加熟悉了图形界面的编程和数据可视化。</li>
</ol>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作品集</tag>
        <tag>技术报告</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Unity——《让蛋仔飞》技术报告</title>
    <url>/2024/01/08/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h2><ul>
<li><p>项目名称：《让蛋仔飞》</p>
</li>
<li><p>开发者：普典衡</p>
</li>
<li><p>分工：</p>
<p>普典衡：</p>
<p>策划-玩法，数值</p>
<p>程序-前端，后端</p>
<p>美术-UI，动画</p>
</li>
</ul>
<h2 id="2-游戏内容介绍"><a href="#2-游戏内容介绍" class="headerlink" title="2. 游戏内容介绍"></a>2. 游戏内容介绍</h2><ul>
<li>游戏背景：一个简单而有趣的游戏环境，主要集中于轻松、快节奏的体验。</li>
<li>角色道具：玩家扮演的是不同种类的卡通蛋角色，如荷包蛋、倒霉蛋等。卡通风格的刀和叉作为障碍物。</li>
<li>场景：使用明亮、鲜艳的色调和简单的卡通风格，界面清晰展示游戏选项。</li>
<li>主要情节：游戏集中于提供快节奏、直观易懂的体验，没有复杂的情节或故事线。</li>
<li>玩法：操作主角蛋躲避障碍物，通过点击或触摸屏幕控制跳跃。</li>
<li>功能（系统）：包括游戏控制系统、皮肤系统、排行榜系统等。</li>
</ul>
<h2 id="3-主要特点"><a href="#3-主要特点" class="headerlink" title="3. 主要特点"></a>3. 主要特点</h2><ul>
<li>整体风格：简洁而有趣，易于上手。</li>
<li>娱乐性与挑战性：结合逐渐增加的难度提供持续挑战。</li>
<li>社交性：通过排行榜系统增加游戏的社交动力。</li>
<li>个性化体验：通过皮肤系统允许玩家自定义角色外观。</li>
</ul>
<h2 id="4-算法说明"><a href="#4-算法说明" class="headerlink" title="4. 算法说明"></a>4. 算法说明</h2><p>   Unity（C#）代码部分：</p>
<h3 id="游戏控制和角色行为"><a href="#游戏控制和角色行为" class="headerlink" title="游戏控制和角色行为"></a>游戏控制和角色行为</h3><h4 id="EggyController-类："><a href="#EggyController-类：" class="headerlink" title="EggyController 类："></a><code>EggyController</code> 类：</h4><p>   负责处理蛋角色的基本行为，包括跳跃、得分、游戏开始&#x2F;结束逻辑、无敌状态、碰撞处理以及游戏速度的调整。</p>
<h5 id="游戏开始-结束逻辑"><a href="#游戏开始-结束逻辑" class="headerlink" title="游戏开始&#x2F;结束逻辑"></a>游戏开始&#x2F;结束逻辑</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isControl &amp;&amp; !IsPointerOverUIObject()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>) &amp;&amp; !gameStarted) &#123;</span><br><span class="line">            StartGame();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gameStarted) &#123;</span><br><span class="line">            Jump();</span><br><span class="line">        &#125;</span><br><span class="line">        CheckPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartGame</span>()</span> &#123;</span><br><span class="line">    gameStarted = <span class="literal">true</span>;</span><br><span class="line">    Time.timeScale = <span class="number">1</span>; <span class="comment">// 恢复时间流逝</span></span><br><span class="line">    <span class="comment">// 其他游戏开始逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckPosition</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查蛋的位置，确定游戏是否结束</span></span><br><span class="line">    <span class="comment">// 如果蛋落出屏幕，则结束游戏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   此部分代码控制游戏的开始和结束。当玩家点击屏幕时，游戏开始，而当游戏角色掉出屏幕时，游戏结束。</p>
<h5 id="跳跃逻辑"><a href="#跳跃逻辑" class="headerlink" title="跳跃逻辑"></a>跳跃逻辑</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Jump</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>)) &#123;</span><br><span class="line">        rb.velocity = Vector2.up * jumpForce;</span><br><span class="line">        StartCoroutine(BounceEffect());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">BounceEffect</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 实现蛋的跳跃动画效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   这段代码负责处理玩家角色的跳跃动作。玩家点击屏幕时，角色会向上跳跃。</p>
<h5 id="得分逻辑"><a href="#得分逻辑" class="headerlink" title="得分逻辑"></a>得分逻辑</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGameOver &amp;&amp; other.gameObject.tag == <span class="string">&quot;ScoreZone&quot;</span>) &#123;</span><br><span class="line">        score++;</span><br><span class="line">        UpdateScoreText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateScoreText</span>()</span> &#123;</span><br><span class="line">    scoreText.text = score.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   当角色通过特定区域时，玩家得分。这通过检测角色是否触碰到标记为 “ScoreZone” 的触发器来实现。</p>
<h5 id="无敌状态"><a href="#无敌状态" class="headerlink" title="无敌状态"></a>无敌状态</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InvincibilityTime</span>()</span> &#123;</span><br><span class="line">    isInvincible = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 实现无敌状态效果，如闪烁等</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>; <span class="comment">// 无敌时间</span></span><br><span class="line">    isInvincible = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   在某些情况下，角色会进入无敌状态，这段时间内不会被障碍物伤害。</p>
<h5 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (collision.gameObject.tag == <span class="string">&quot;KF&quot;</span> &amp;&amp; !isGameOver &amp;&amp; !isInvincible) &#123;</span><br><span class="line">        iscollide = <span class="literal">true</span>;</span><br><span class="line">        StartCoroutine(HandleGameOver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   当角色与标记为 “KF” 的障碍物发生碰撞时，游戏结束逻辑被触发。</p>
<h5 id="游戏速度调整"><a href="#游戏速度调整" class="headerlink" title="游戏速度调整"></a>游戏速度调整</h5>   <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateGameSpeed</span>()</span> &#123;</span><br><span class="line">    Time.timeScale = Mathf.Min(<span class="number">1</span> + score * speedupspeed, maxTimeScale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   随着玩家得分的提高，游戏的时间流逝速度加快，从而增加游戏难度。</p>
<h4 id="Background-类："><a href="#Background-类：" class="headerlink" title="Background 类："></a><code>Background</code> 类：</h4><p>   管理游戏背景的移动，以创建滚动效果，增加游戏的动态感。</p>
<h5 id="初始化背景属性"><a href="#初始化背景属性" class="headerlink" title="初始化背景属性"></a>初始化背景属性</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    backgroundWidth = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在游戏开始时，计算背景图像的宽度，以便于后续确定何时克隆新的背景。</p>
<h5 id="背景移动逻辑"><a href="#背景移动逻辑" class="headerlink" title="背景移动逻辑"></a>背景移动逻辑</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EggyController.isGameOver) &#123;</span><br><span class="line">        transform.Translate(-speed * Time.deltaTime, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在每一帧中，如果游戏未结束，背景将以设定的速度向左移动，创建出持续滚动的效果。</p>
<h5 id="背景克隆和销毁"><a href="#背景克隆和销毁" class="headerlink" title="背景克隆和销毁"></a>背景克隆和销毁</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (transform.position.x &lt; <span class="number">0</span> &amp;&amp; !hasCloned) &#123;</span><br><span class="line">    CloneBackground();</span><br><span class="line">    hasCloned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (transform.position.x &lt; <span class="number">-18</span>) &#123;</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   当背景移动到屏幕中央时，克隆一个新的背景对象，以实现无缝连接的滚动效果。一旦背景移出屏幕一定范围，它将被销毁，以节省资源。</p>
<h5 id="克隆背景方法"><a href="#克隆背景方法" class="headerlink" title="克隆背景方法"></a>克隆背景方法</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloneBackground</span>()</span> &#123;</span><br><span class="line">    Instantiate(gameObject, <span class="keyword">new</span> Vector3(transform.position.x + backgroundWidth, transform.position.y, transform.position.z), Quaternion.identity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这个方法在原有背景的基础上创建一个新的背景实例，放置在当前背景的右侧，确保两个背景图像在水平方向上连续。</p>
<h3 id="游戏界面和用户交互"><a href="#游戏界面和用户交互" class="headerlink" title="游戏界面和用户交互"></a>游戏界面和用户交互</h3><h4 id="MenuManager-类："><a href="#MenuManager-类：" class="headerlink" title="MenuManager 类："></a><code>MenuManager</code> 类：</h4><p>   管理游戏菜单的显示和皮肤选择，提供玩家选择不同皮肤的功能。</p>
<h5 id="初始化和皮肤状态管理"><a href="#初始化和皮肤状态管理" class="headerlink" title="初始化和皮肤状态管理"></a>初始化和皮肤状态管理</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 确保主页UI初始时是显示的</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>);</span><br><span class="line">    homePageUI.SetActive(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取并显示累计总得分</span></span><br><span class="line">    <span class="built_in">int</span> totalScore = PlayerPrefs.GetInt(<span class="string">&quot;TotalScore&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取并显示死亡次数</span></span><br><span class="line">    <span class="built_in">int</span> deathCount = PlayerPrefs.GetInt(<span class="string">&quot;DeathCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取并显示复活总数</span></span><br><span class="line">    <span class="built_in">int</span> resurrectionCount = PlayerPrefs.GetInt(<span class="string">&quot;ResurrectionCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在对应的Text组件中显示这些值</span></span><br><span class="line">    <span class="comment">// 这里假设你有三个Text组件分别用于显示总得分、死亡次数和复活总数</span></span><br><span class="line">    <span class="comment">// 如果你的Text组件命名不同，需要根据实际情况修改下面的代码</span></span><br><span class="line">    totalScoreText.text = <span class="string">&quot;总得分: &quot;</span> + totalScore.ToString();</span><br><span class="line">    deathCountText.text = <span class="string">&quot;失败数: &quot;</span> + deathCount.ToString();</span><br><span class="line">    resurrectionCountText.text = <span class="string">&quot;复活数: &quot;</span> + resurrectionCount.ToString();</span><br><span class="line"></span><br><span class="line">    Time.timeScale = <span class="number">1</span>;</span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>); <span class="comment">// 先激活</span></span><br><span class="line">    ApplySkinToEggy(skinManager.skins[PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>)].name); <span class="comment">// 应用皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>); <span class="comment">// 再隐藏，如果需要的话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化皮肤列表</span></span><br><span class="line">    InitializeSkinsUnlockState();</span><br><span class="line">    LoadCurrentSkin();</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line"></span><br><span class="line">    unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitializeSkinsUnlockState</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认皮肤已解锁</span></span><br><span class="line">    PlayerPrefs.SetInt(<span class="string">&quot;eggy0&quot;</span>, <span class="number">1</span>); <span class="comment">// 1表示解锁，0表示未解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他皮肤的初始状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; skinManager.skins.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PlayerPrefs.HasKey(<span class="string">&quot;eggy&quot;</span> + i))</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span> + i, <span class="number">0</span>); <span class="comment">// 初始化为未解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!PlayerPrefs.HasKey(<span class="string">&quot;eggyUnlockable&quot;</span> + i))</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;eggyUnlockable&quot;</span> + i, <span class="number">0</span>); <span class="comment">// 初始化为不能解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadCurrentSkin</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 读取当前皮肤</span></span><br><span class="line">    currentSkinIndex = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            			           UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这部分代码在游戏开始时初始化UI元素和皮肤状态，包括设置默认皮肤和加载已解锁的皮肤。</p>
<h5 id="游戏开始和皮肤应用"><a href="#游戏开始和皮肤应用" class="headerlink" title="游戏开始和皮肤应用"></a>游戏开始和皮肤应用</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartGame</span>()</span> &#123;</span><br><span class="line">    Time.timeScale = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 激活游戏元素</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏主页UI</span></span><br><span class="line">    homePageUI.SetActive(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他开始游戏的设置...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ApplySkinToEggy</span>(<span class="params"><span class="built_in">string</span> skinName</span>)</span> &#123;</span><br><span class="line">    Skin skin = skinManager.GetSkin(skinName);</span><br><span class="line">    <span class="keyword">if</span> (skin != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EggyController eggyController = Object.FindObjectOfType&lt;EggyController&gt;();</span><br><span class="line">        <span class="keyword">if</span> (eggyController != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            eggyController.ChangeAppearance(skin.image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;EggyController instance not found in the scene.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   当玩家选择开始游戏时，这部分代码负责切换游戏的视图状态，并应用玩家选择的皮肤。</p>
<h5 id="皮肤选择和解锁"><a href="#皮肤选择和解锁" class="headerlink" title="皮肤选择和解锁"></a>皮肤选择和解锁</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NextSkin</span>()</span> &#123;</span><br><span class="line">    currentSkinIndex = (currentSkinIndex + <span class="number">1</span>) % skinManager.skins.Count;</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreviousSkin</span>()</span> &#123;</span><br><span class="line">    currentSkinIndex = (currentSkinIndex - <span class="number">1</span> + skinManager.skins.Count) % skinManager.skins.Count;</span><br><span class="line">    UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectSkin</span>()</span> &#123;</span><br><span class="line">    PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span>, currentSkinIndex); <span class="comment">// 保存当前选择的皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">true</span>); <span class="comment">// 先激活</span></span><br><span class="line">    ApplySkinToEggy(skinManager.skins[currentSkinIndex].name);<span class="comment">//应用皮肤</span></span><br><span class="line">    gameElements.SetActive(<span class="literal">false</span>); <span class="comment">// 再隐藏，如果需要的话</span></span><br><span class="line">    selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnlockSkin</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> canUnlock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (currentSkinIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// eggy1解锁条件 - 累计失败500次</span></span><br><span class="line">            <span class="built_in">int</span> deathCount = PlayerPrefs.GetInt(<span class="string">&quot;DeathCount&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            canUnlock = deathCount &gt;= <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// eggy2解锁条件 - 累计达到10000分</span></span><br><span class="line">            <span class="built_in">int</span> totalScore = PlayerPrefs.GetInt(<span class="string">&quot;TotalScore&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            canUnlock = totalScore &gt;= <span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// eggy3解锁条件 - 累计复活50次</span></span><br><span class="line">            <span class="built_in">int</span> resurrectionCount = PlayerPrefs.GetInt(<span class="string">&quot;ResurrectionCount&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            canUnlock = resurrectionCount &gt;= <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">if</span> (PlayerPrefs.GetInt(<span class="string">&quot;eggyUnlockable&quot;</span> + currentSkinIndex, <span class="number">0</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                canUnlock = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canUnlock)</span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetInt(<span class="string">&quot;eggy&quot;</span> + currentSkinIndex, <span class="number">1</span>); <span class="comment">// 解锁当前皮肤</span></span><br><span class="line">        skinManager.skins[currentSkinIndex].isUnlocked = <span class="literal">true</span>; <span class="comment">// 更新皮肤管理器中的状态</span></span><br><span class="line">        UpdateEggyDisplay(skinManager.skins[currentSkinIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ShowUnlockConditionFailed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateEggyDisplay</span>(<span class="params">Skin skin</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新皮肤信息</span></span><br><span class="line">    NameText.text = skin.name;</span><br><span class="line">    IntroductionText.text = skin.description;</span><br><span class="line">    unlockConditionText.text = skin.unlockCondition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始皮肤图像并重置Eggy</span></span><br><span class="line">    eggyDisplay.SetSkinImage(skin.image);</span><br><span class="line">    eggyDisplay.ResetEggy(); <span class="comment">// 重置Eggy的位置和状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取解锁和选中状态</span></span><br><span class="line">    <span class="built_in">bool</span> isUnlocked = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span> + currentSkinIndex, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bool</span> isSelected = PlayerPrefs.GetInt(<span class="string">&quot;eggy&quot;</span>, <span class="number">0</span>) == currentSkinIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据解锁状态和选中状态控制按钮显示</span></span><br><span class="line">    <span class="keyword">if</span> (isUnlocked &amp;&amp; isSelected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤已解锁且为当前选中皮肤</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isUnlocked)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤已解锁但不是当前选中皮肤</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前皮肤未解锁</span></span><br><span class="line">        unlockButton.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        selectButton.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eggyDisplay.SetUnlocked(isUnlocked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   这些方法允许玩家在不同皮肤之间选择和切换，并根据游戏进度解锁新的皮肤。</p>
<h4 id="EggyDisplay-类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。"><a href="#EggyDisplay-类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。" class="headerlink" title="EggyDisplay 类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。"></a><code>EggyDisplay</code> 类：用于控制蛋角色在游戏中的显示，包括皮肤更换和解锁动画效果。</h4><h5 id="初始化和设置皮肤"><a href="#初始化和设置皮肤" class="headerlink" title="初始化和设置皮肤"></a>初始化和设置皮肤</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    eggyRenderer = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    originalSprite = eggyRenderer.sprite;</span><br><span class="line">    originalPosition = transform.position;</span><br><span class="line">    originalScale = transform.localScale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSkinImage</span>(<span class="params">Sprite skinImage</span>)</span> &#123;</span><br><span class="line">    originalSprite = skinImage;</span><br><span class="line">    eggyRenderer.sprite = skinImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   在游戏开始时，该类初始化蛋角色的渲染器，并保存其原始状态。<code>SetSkinImage</code> 方法用于更换角色的皮肤。</p>
<h5 id="皮肤解锁动画"><a href="#皮肤解锁动画" class="headerlink" title="皮肤解锁动画"></a>皮肤解锁动画</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetUnlocked</span>(<span class="params"><span class="built_in">bool</span> unlocked</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlocked) &#123;</span><br><span class="line">        StartCoroutine(UnlockedAnimation());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eggyRenderer.sprite = ApplyBlackMask(eggyRenderer.sprite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">UnlockedAnimation</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 动画效果，如呼吸效果和跳跃动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   通过 <code>SetUnlocked</code> 方法，可以控制是否展示皮肤解锁动画。如果皮肤已解锁，会播放一个特殊的动画效果，如呼吸和跳跃动作。</p>
<h5 id="辅助方法：黑色遮罩和重置状态"><a href="#辅助方法：黑色遮罩和重置状态" class="headerlink" title="辅助方法：黑色遮罩和重置状态"></a>辅助方法：黑色遮罩和重置状态</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Sprite <span class="title">ApplyBlackMask</span>(<span class="params">Sprite originalSprite</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将黑色遮罩应用于未解锁的皮肤图像</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetEggy</span>()</span> &#123;</span><br><span class="line">    StopAllCoroutines();</span><br><span class="line">    transform.localScale = originalScale;</span><br><span class="line">    transform.position = originalPosition;</span><br><span class="line">    <span class="comment">// 重置其他状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   <code>ApplyBlackMask</code> 方法用于给未解锁的皮肤添加一个黑色遮罩，而 <code>ResetEggy</code> 方法则用于重置蛋角色的状态，包括位置和缩放。</p>
<h3 id="游戏障碍物和挑战"><a href="#游戏障碍物和挑战" class="headerlink" title="游戏障碍物和挑战"></a>游戏障碍物和挑战</h3><h4 id="KnifeForkController-和-KFController-类："><a href="#KnifeForkController-和-KFController-类：" class="headerlink" title="KnifeForkController 和 KFController 类："></a><code>KnifeForkController</code> 和 <code>KFController</code> 类：</h4><p>   负责生成和管理刀叉障碍物，控制它们的出现频率、速度和运动。</p>
<h4 id="KnifeForkController-类："><a href="#KnifeForkController-类：" class="headerlink" title="KnifeForkController 类："></a><code>KnifeForkController</code> 类：</h4><p>   负责刀叉障碍物的生成和管理</p>
<h5 id="初始化和生成刀叉"><a href="#初始化和生成刀叉" class="headerlink" title="初始化和生成刀叉"></a>初始化和生成刀叉</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject knifeForkPrefab; <span class="comment">// 刀叉预制体</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> spawnRate = <span class="number">2f</span>; <span class="comment">// 生成间隔（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    nextSpawnTime = Time.time + spawnRate; <span class="comment">// 设置下一次生成时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isGameOver &amp;&amp; Time.time &gt;= nextSpawnTime)</span><br><span class="line">    &#123;</span><br><span class="line">        SpawnKnifeFork();</span><br><span class="line">        nextSpawnTime = Time.time + spawnRate;</span><br><span class="line">        forksCount++; <span class="comment">// 增加已生成的刀叉数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查EggyController的游戏结束状态</span></span><br><span class="line">    <span class="keyword">if</span> (EggyController.isGameOver)</span><br><span class="line">    &#123;</span><br><span class="line">        isGameOver = <span class="literal">true</span>;</span><br><span class="line">        GameOver();</span><br><span class="line">    &#125;<span class="keyword">else</span> isGameOver = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpawnKnifeFork</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> gapY = Random.Range(-gapSize, gapSize); <span class="comment">// 随机间隔</span></span><br><span class="line">    Quaternion rotation = Random.Range(<span class="number">0</span>, <span class="number">2</span>) == <span class="number">0</span> ? Quaternion.identity : Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span>); <span class="comment">// 随机旋转180度</span></span><br><span class="line">    Vector3 spawnPosition = <span class="keyword">new</span> Vector3(transform.position.x, gapY, transform.position.z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据旋转来设置初始速度方向</span></span><br><span class="line">    <span class="built_in">float</span> initialMoveDirection = (rotation == Quaternion.identity) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    GameObject newKnifeFork = Instantiate(knifeForkPrefab, spawnPosition, rotation);</span><br><span class="line">    spawnedForks.Add(newKnifeFork); <span class="comment">// 将已生成的刀叉添加到列表</span></span><br><span class="line">    StartCoroutine(MoveAndDestroyKnifeFork(newKnifeFork, initialMoveDirection)); <span class="comment">// 设置移动速度并在移出屏幕后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="刀叉运动和销毁"><a href="#刀叉运动和销毁" class="headerlink" title="刀叉运动和销毁"></a>刀叉运动和销毁</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MoveAndDestroyKnifeFork</span>(<span class="params">GameObject knifeFork, <span class="built_in">float</span> initialMoveDirection</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 控制刀叉的移动和销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopKnifeFork</span>(<span class="params">GameObject knifeFork</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (knifeFork != <span class="literal">null</span>) <span class="comment">// 检查刀叉是否为null</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rigidbody2D kfRigidbody = knifeFork.GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        kfRigidbody.velocity = Vector2.zero; <span class="comment">// 停止刀叉的速度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="游戏结束和重置"><a href="#游戏结束和重置" class="headerlink" title="游戏结束和重置"></a>游戏结束和重置</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GameOver</span>()</span> &#123;</span><br><span class="line">    isGameOver = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 停止所有已生成的刀叉的移动</span></span><br><span class="line">    <span class="keyword">foreach</span> (GameObject fork <span class="keyword">in</span> spawnedForks)</span><br><span class="line">    &#123;</span><br><span class="line">        StopKnifeFork(fork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetGame</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 重置刀叉控制器的状态</span></span><br><span class="line">    isGameOver = <span class="literal">false</span>;</span><br><span class="line">    forksCount = <span class="number">0</span>;</span><br><span class="line">    nextSpawnTime = Time.time + spawnRate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁所有已生成的刀叉</span></span><br><span class="line">    <span class="keyword">foreach</span> (GameObject fork <span class="keyword">in</span> spawnedForks)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(fork);</span><br><span class="line">    &#125;</span><br><span class="line">    spawnedForks.Clear(); <span class="comment">// 清空列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="KFController-类："><a href="#KFController-类：" class="headerlink" title="KFController 类："></a><code>KFController</code> 类：</h4><p>   负责单个刀叉障碍物的行为</p>
<h5 id="刀叉障碍物的物理行为"><a href="#刀叉障碍物的物理行为" class="headerlink" title="刀叉障碍物的物理行为"></a>刀叉障碍物的物理行为</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> kfFallSpeed = <span class="number">20f</span>; <span class="comment">// KF的下降速度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (collision.gameObject.CompareTag(<span class="string">&quot;eggy&quot;</span>)) &#123;</span><br><span class="line">        Rigidbody2D kfRigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        kfRigidbody.velocity = Vector2.down * kfFallSpeed; <span class="comment">// 设置下降速度</span></span><br><span class="line">        kfRigidbody.gravityScale = <span class="number">3</span>; <span class="comment">// 调整重力影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   <code>KnifeForkController</code> 类负责控制整体刀叉障碍物的生成频率和运动模式，而 <code>KFController</code> 类则专注于单个刀叉障碍物的具体行为，如碰撞时的下降速度和重力设置。这两个类通过协同工作，为游戏增添挑战性和动态性。</p>
<h3 id="排行榜和社交功能"><a href="#排行榜和社交功能" class="headerlink" title="排行榜和社交功能"></a>排行榜和社交功能</h3><h4 id="Ranking-类："><a href="#Ranking-类：" class="headerlink" title="Ranking 类："></a><code>Ranking</code> 类：</h4><p>   整合微信小程序的排行榜功能，允许玩家查看和分享他们的得分。</p>
<h5 id="初始化和设置"><a href="#初始化和设置" class="headerlink" title="初始化和设置"></a>初始化和设置</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    WX.InitSDK((code) =&gt; &#123; Init(); &#125;);</span><br><span class="line">    WX.UpdateShareMenu(<span class="keyword">new</span> UpdateShareMenuOption() &#123;</span><br><span class="line">        withShareTicket = <span class="literal">true</span>,</span><br><span class="line">        isPrivateMessage = <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   游戏启动时初始化微信SDK，并设置分享菜单选项，允许通过群分享获取排行榜数据。</p>
<h5 id="展示排行榜"><a href="#展示排行榜" class="headerlink" title="展示排行榜"></a>展示排行榜</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowOpenData</span>()</span> &#123;</span><br><span class="line">    RankMask.SetActive(<span class="literal">true</span>);</span><br><span class="line">    RankingBox.SetActive(<span class="literal">true</span>);</span><br><span class="line">    WX.ShowOpenData(RankBody.texture, <span class="comment">/* 确定排行榜的位置和尺寸 */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;</span><br><span class="line">    ShowButton1.onClick.AddListener(ShowRanking);</span><br><span class="line">    ShowButton2.onClick.AddListener(ShowRanking);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowRanking</span>()</span> &#123;</span><br><span class="line">    ShowOpenData();</span><br><span class="line">    OpenDataMessage msgData = <span class="keyword">new</span> OpenDataMessage &#123; type = <span class="string">&quot;showFriendsRank&quot;</span> &#125;;</span><br><span class="line">    WX.GetOpenDataContext().PostMessage(JsonUtility.ToJson(msgData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   提供了按钮监听器来展示排行榜，通过调用<code>WX.ShowOpenData</code>方法将排行榜数据渲染到指定的UI元素上。</p>
<h5 id="排行榜的隐藏与分享"><a href="#排行榜的隐藏与分享" class="headerlink" title="排行榜的隐藏与分享"></a>排行榜的隐藏与分享</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">RankMask.GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123;</span><br><span class="line">    RankMask.SetActive(<span class="literal">false</span>);</span><br><span class="line">    RankingBox.SetActive(<span class="literal">false</span>);</span><br><span class="line">    WX.HideOpenData();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ShareButton.onClick.AddListener(() =&gt; &#123;</span><br><span class="line">    <span class="comment">// 分享最高分数</span></span><br><span class="line">    WX.ShareAppMessage(<span class="comment">/* 分享配置 */</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>   包含隐藏排行榜和分享玩家成绩的逻辑。玩家可以通过点击按钮来关闭排行榜视图，或者通过另一个按钮分享自己的最高得分。</p>
<ul>
<li>使用微信SDK进行社交互动和数据共享。</li>
</ul>
<h5 id="玩家数据和成就"><a href="#玩家数据和成就" class="headerlink" title="玩家数据和成就"></a>玩家数据和成就</h5><ul>
<li>使用 <code>PlayerPrefs</code> 来保存和加载玩家的分数、皮肤状态、死亡次数等信息。</li>
<li>提供复活机制，增加游戏的挑战性和可玩性。</li>
</ul>
<h5 id="皮肤系统和个性化"><a href="#皮肤系统和个性化" class="headerlink" title="皮肤系统和个性化"></a>皮肤系统和个性化</h5><h4 id="SkinManager-类："><a href="#SkinManager-类：" class="headerlink" title="SkinManager 类："></a><code>SkinManager</code> 类：</h4><p>   管理游戏中的皮肤系统，包括皮肤的解锁条件和状态。</p>
<h5 id="皮肤定义"><a href="#皮肤定义" class="headerlink" title="皮肤定义"></a>皮肤定义</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Skin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name; <span class="comment">// 皮肤名称</span></span><br><span class="line">    <span class="keyword">public</span> Sprite image; <span class="comment">// 皮肤图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> description; <span class="comment">// 皮肤简介</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> unlockCondition; <span class="comment">// 解锁条件描述</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isUnlocked; <span class="comment">// 是否已解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   定义了一个<code>Skin</code>类，包含皮肤的名称、图片、描述和解锁条件。<code>isUnlocked</code>字段用于追踪皮肤的解锁状态。</p>
<h5 id="皮肤管理"><a href="#皮肤管理" class="headerlink" title="皮肤管理"></a>皮肤管理</h5>   <div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SkinManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Skin&gt; skins; <span class="comment">// 皮肤集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定名称的皮肤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Skin <span class="title">GetSkin</span>(<span class="params"><span class="built_in">string</span> skinName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> skins.Find(skin =&gt; skin.name == skinName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   <code>SkinManager</code>类包含一个皮肤集合，提供<code>GetSkin</code>方法以根据名称获取特定皮肤的详细信息。这使得游戏能够根据玩家的选择或游戏进度，显示或更换皮肤。</p>
<ul>
<li>提供多种皮肤供玩家解锁和选择，增加游戏的个性化和吸引力。</li>
</ul>
<h2 id="5-API的使用"><a href="#5-API的使用" class="headerlink" title="5. API的使用"></a>5. API的使用</h2><h3 id="系统信息和日志管理"><a href="#系统信息和日志管理" class="headerlink" title="系统信息和日志管理"></a>系统信息和日志管理</h3><ul>
<li><code>wx.getUpdateManager()</code>：获取全局唯一的版本更新管理器，用于管理小程序的更新。</li>
<li><code>wx.getSystemInfoSync()</code>：同步获取系统信息，如屏幕大小、设备型号等。</li>
<li><code>wx.getRealtimeLogManager()</code>：获取实时日志管理器，用于记录和上报实时日志。</li>
<li><code>wx.getLogManager()</code>：获取日志管理器，用于记录和上报日志。</li>
</ul>
<h3 id="错误处理和内存管理"><a href="#错误处理和内存管理" class="headerlink" title="错误处理和内存管理"></a>错误处理和内存管理</h3><ul>
<li><code>wx.onError()</code>：监听小程序错误事件，用于错误处理。</li>
<li><code>wx.triggerGC()</code>：触发JavaScript垃圾回收机制，可以帮助小程序管理内存使用。</li>
</ul>
<h3 id="用户界面和反馈"><a href="#用户界面和反馈" class="headerlink" title="用户界面和反馈"></a>用户界面和反馈</h3><ul>
<li><code>wx.showModal()</code>：显示模态对话框，用于向用户显示信息或询问用户决策。</li>
<li><code>wx.createFeedbackButton()</code>：创建一个游戏内的用户反馈按钮。</li>
</ul>
<h3 id="社交功能和消息传递"><a href="#社交功能和消息传递" class="headerlink" title="社交功能和消息传递"></a>社交功能和消息传递</h3><ul>
<li><code>wx.shareMessageToFriend()</code>：分享消息给微信好友，增强游戏的社交互动性。</li>
<li><code>wx.onMessage()</code>：监听主域向开放数据域发送的消息，常用于排行榜的实现。</li>
</ul>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul>
<li><code>wx.getStorageSync()</code>、<code>wx.setStorage()</code>、<code>wx.removeStorage()</code>、<code>wx.clearStorage()</code>、<code>wx.getStorage()</code>：这些API用于本地数据的存取、删除和清除，方便游戏保存玩家的游戏进度、设置或成就。</li>
</ul>
<h2 id="6-UI和截图"><a href="#6-UI和截图" class="headerlink" title="6. UI和截图"></a>6. UI和截图</h2><p>   所有素材均为ChatGPT绘制+本人Photoshop制作，无商用素材盗用</p>
<h3 id="游戏界面截图"><a href="#游戏界面截图" class="headerlink" title="游戏界面截图"></a>游戏界面截图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/0.png"
                      alt="0"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/1.png"
                      alt="1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/2.png"
                      alt="2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/5.png"
                      alt="5"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/6.png"
                      alt="6"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/10.png"
                      alt="10"
                ></p>
<h3 id="角色和UI设计图（部分）"><a href="#角色和UI设计图（部分）" class="headerlink" title="角色和UI设计图（部分）"></a>角色和UI设计图（部分）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/eggy.png"
                      alt="eggy"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg4.png"
                      alt="egg4"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg6.png"
                      alt="egg6"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg1.png"
                      alt="egg1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg2.png"
                      alt="egg2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/egg3.png"
                      alt="egg3"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/bg.png"
                      alt="bg"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/Button_UI.png"
                      alt="Button_UI"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/fork.png"
                      alt="fork"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/knife.png"
                      alt="knife"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/pan.png"
                      alt="pan"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/share.png"
                      alt="share"
                ></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>微信小游戏</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>技术报告</tag>
        <tag>《让蛋仔飞》</tag>
        <tag>Unity</tag>
        <tag>微信小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity——《让蛋仔飞》项目报告</title>
    <url>/2024/01/09/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_01.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_01"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_02.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_02"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_03.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_03"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_04.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_04"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_05.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_05"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_06.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_06"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_07.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_07"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_08.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_08"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_09.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_09"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_10.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_10"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_11.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_11"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_12.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_12"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_13.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_13"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_14.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_14"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_15.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_15"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_16.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_16"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_17.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_17"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_18.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_18"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_19.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_19"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_20.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_20"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_21.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_21"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_22.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_22"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_23.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_23"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_24.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_24"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_25.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_25"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_26.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_26"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9E%E3%80%8B%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/%E3%80%8A%E8%AE%A9%E8%9B%8B%E4%BB%94%E9%A3%9EFlappyEggy%E3%80%8B-%E6%99%AE%E5%85%B8%E8%A1%A1_27.png"
                      alt="《让蛋仔飞FlappyEggy》-普典衡_27"
                ></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>微信小游戏</category>
      </categories>
      <tags>
        <tag>项目报告</tag>
        <tag>作品集</tag>
        <tag>《让蛋仔飞》</tag>
        <tag>Unity</tag>
        <tag>微信小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>竞赛——蓝桥杯大赛-元宇宙元镜杯国家级三等奖</title>
    <url>/2023/12/24/%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B-%E5%85%83%E5%AE%87%E5%AE%99%E5%85%83%E9%95%9C%E6%9D%AF%E5%9B%BD%E5%AE%B6%E7%BA%A7%E4%B8%89%E7%AD%89%E5%A5%96/</url>
    <content><![CDATA[<p><strong>数字生活方向：</strong></p>
<p>元卧室”完美融合了元宇宙技术。将卧室，这个私人空间，变为一个无与伦比的数字体验之境。这个卧室，或者更确切地说，这个数字化奇境，以元宇宙技术为基础，让您足不出户便可实现瞬间的全球穿越。卧室还备有名为”小元”的人工智能助手，通过对话地方式带您环游世界，让您享受一个更加互动和沉浸的数字生活。</p>
<p>当您躺在舒适的床上，闭上双眼，突然之间便置身于大自然的怀抱。墙壁和天花板上的高精度全息半球形显示屏，以栩栩如生的方式呈现出各种自然景观，让您感受到真实世界的每一个细节。</p>
<p>与此同时，地板巧妙地隐藏了全息环境声音系统，使您的听觉也被沉浸其中，仿佛置身于所选择的环境之中。无论是鸟鸣虫鸣还是海浪拍打声，都让您感受到身临其境的奇妙体验。</p>
<p>足不出户就可以畅游世界，甚至模拟出一个您理想的景观，让忙碌的生活有短暂的停歇。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://megagame-work.oss-cn-shanghai.aliyuncs.com/user/415/%E5%85%83%E5%AE%87%E5%AE%993.png?OSSAccessKeyId=LTAI5tGVZpS3uTXqmEV4jPyC&Expires=1713259114&Signature=5Xx/zNyY2S3PIIiRVLuINOGqhaY="
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://megagame-work.oss-cn-shanghai.aliyuncs.com/user/415/%E5%85%83%E5%AE%87%E5%AE%991.png?OSSAccessKeyId=LTAI5tGVZpS3uTXqmEV4jPyC&Expires=1713259114&Signature=nUXi7QvVY2gRSfBUT2TxUhG1H/Y="
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://megagame-work.oss-cn-shanghai.aliyuncs.com/user/415/%E5%85%83%E5%AE%87%E5%AE%992.png?OSSAccessKeyId=LTAI5tGVZpS3uTXqmEV4jPyC&Expires=1713259114&Signature=7I2G+DF5djn151KB+PopA+7wpTU="
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E7%AB%9E%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B-%E5%85%83%E5%AE%87%E5%AE%99%E5%85%83%E9%95%9C%E6%9D%AF%E5%9B%BD%E5%AE%B6%E7%BA%A7%E4%B8%89%E7%AD%89%E5%A5%96/%E8%AF%81%E4%B9%A6.png"
                      alt="证书"
                ></p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>Blender</tag>
        <tag>竞赛</tag>
        <tag>蓝桥杯</tag>
        <tag>元宇宙</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT软件性能工程——Homework-3-Vectorization</title>
    <url>/2024/04/22/MIT%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94Homework-3-Vectorization/</url>
    <content><![CDATA[<h2 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h2> <embed src="/pdf/软件性能工程/hw3.pdf" width="100%" height="600" type="application/pdf">



<h2 id="Write-up1-分析汇编代码"><a href="#Write-up1-分析汇编代码" class="headerlink" title="Write-up1: 分析汇编代码"></a>Write-up1: 分析汇编代码</h2><p>在汇编代码中，编译器设置起始索引为 -65536 (<code>$-65536</code>) 并在每次内存访问时对其进行增加，而不是从0开始并使用小的正偏移量。这种做法可能有几个原因：</p>
<h4 id="内存对齐和访问优化："><a href="#内存对齐和访问优化：" class="headerlink" title="内存对齐和访问优化："></a><strong>内存对齐和访问优化</strong>：</h4><p>编译器可能会选择这样的索引方式来确保内存访问对齐，特别是在进行SIMD操作时，正确的对齐可以显著提高性能。通过从-65536开始，编译器可能在某种程度上试图优化循环内部对于数组的迭代访问，使其更加适合于向量化操作。</p>
<h4 id="循环绕回："><a href="#循环绕回：" class="headerlink" title="循环绕回："></a><strong>循环绕回</strong>：</h4><p>此方法可能涉及到处理循环边界的问题，特别是当数组长度正好不是向量大小的整数倍时。编译器可能使用这种方式来简化循环结束后的边界检查逻辑，通过在计算偏移时自动“绕回”数组起始位置。</p>
<h4 id="指令优化："><a href="#指令优化：" class="headerlink" title="指令优化："></a><strong>指令优化</strong>：</h4><p>使用这种特定的起始偏移可能有助于简化某些处理器指令，编译器可能利用这种方法来减少某些指令的使用，或者是优化指令的执行路径。</p>
<p>总结而言，这种汇编代码生成方式可能是编译器为了优化性能，根据底层硬件的特定特性和向量化的需求而做出的特定决策。</p>
<h2 id="Write-up-2-修正代码以使用AVX2寄存器进行对齐移动"><a href="#Write-up-2-修正代码以使用AVX2寄存器进行对齐移动" class="headerlink" title="Write-up 2: 修正代码以使用AVX2寄存器进行对齐移动"></a>Write-up 2: 修正代码以使用AVX2寄存器进行对齐移动</h2><p>在使用AVX2指令集时，注意到代码中使用的是 <code>vmovdqu</code> 指令，这是一个用于非对齐内存访问的指令。虽然这使得代码在处理非对齐数据时更为灵活，但使用对齐的内存访问指令（如 <code>vmovdqa</code>）通常能提供更好的性能，因为对齐的数据访问可以减少内存访问延迟并增加数据吞吐量。</p>
<p>为了确保数组 <code>a</code> 和 <code>b</code> 被正确对齐以利用AVX2的对齐指令，可以在函数参数中声明这些数组是对齐的。这可以通过在C语言中使用 <code>__attribute__((aligned(32)))</code> 来实现，或者在函数调用中使用 <code>_builtin_assume_aligned</code> 内建函数来保证对齐，如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (1L &lt;&lt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">uint8_t</span> * __attribute__((aligned(<span class="number">32</span>))) a, <span class="type">uint8_t</span> * __attribute__((aligned(<span class="number">32</span>))) b)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在编译时，确保使用 <code>-mavx2</code> 选项以启用AVX2指令集。这样修改后，编译器应该会使用 <code>vmovdqa</code> 指令而不是 <code>vmovdqu</code>，从而提高代码的性能。这些对齐指令确保每次内存访问都是在32字节边界上进行，这对AVX2架构是最优的。</p>
<h2 id="Write-up-3-解释编译器生成截然不同的汇编代码的原因"><a href="#Write-up-3-解释编译器生成截然不同的汇编代码的原因" class="headerlink" title="Write-up 3: 解释编译器生成截然不同的汇编代码的原因"></a>Write-up 3: 解释编译器生成截然不同的汇编代码的原因</h2><p>在这个例子中，观察到编译器在处理两个版本的 <code>test</code> 函数时生成了截然不同的汇编代码。初步版本中的代码并没有被有效地向量化，而修改后的版本则实现了完全向量化，使用了 <code>movdqa</code> 和 <code>pmaxub</code> 指令。这种差异主要由以下几个因素造成：</p>
<h4 id="条件分支的影响："><a href="#条件分支的影响：" class="headerlink" title="条件分支的影响："></a><strong>条件分支的影响</strong>：</h4><ul>
<li>在初始的代码中，使用了 <code>if</code> 语句来判断并赋值，这引入了条件分支。在很多情况下，条件分支可以阻碍向量化，因为向量化操作要求在多个数据上同时执行相同的操作。条件分支会使得每个元素可能需要不同的操作，这与向量化的要求相冲突。</li>
<li>修改后的代码使用了条件操作符（三元运算符），这种表达方式使得编译器能够更容易地推断出可以使用单个向量指令（如 <code>pmaxub</code>）来同时处理多个元素。</li>
</ul>
<h4 id="内存对齐与访问模式："><a href="#内存对齐与访问模式：" class="headerlink" title="内存对齐与访问模式："></a><strong>内存对齐与访问模式</strong>：</h4><ul>
<li>使用 <code>__builtin_assume_aligned</code> 明确告诉编译器，输入数组 <code>a</code> 和 <code>b</code> 都按照16字节对齐。这个信息允许编译器使用对齐的内存访问指令（如 <code>movdqa</code>），这些指令比非对齐的内存访问指令（如 <code>movdqu</code>）更快更高效。</li>
<li>对齐的内存访问减少了处理器在执行内存读写时可能遇到的延迟和复杂性，从而提高了代码的执行速度和效率。</li>
</ul>
<h4 id="向量化指令的选择："><a href="#向量化指令的选择：" class="headerlink" title="向量化指令的选择："></a><strong>向量化指令的选择</strong>：</h4><ul>
<li>使用 <code>pmaxub</code>（Packed Maximum Unsigned Byte）指令允许编译器生成一个单一的向量化循环，该循环在每次迭代中处理多个数组元素。这显著提高了循环的效率，因为它减少了迭代次数并且更好地利用了CPU的向量处理能力。</li>
</ul>
<h4 id="编译器优化策略："><a href="#编译器优化策略：" class="headerlink" title="编译器优化策略："></a><strong>编译器优化策略</strong>：</h4><ul>
<li>编译器的内部优化策略也可能影响向量化的结果。在有明确内存对齐和简化操作（如使用三元运算符代替条件分支）的情况下，编译器更有可能实施向量化优化。</li>
</ul>
<p>总结来说，通过简化条件逻辑，并明确告诉编译器关于数据对齐的信息，能够帮助编译器生成更高效的向量化代码。这突显了在编写高性能代码时，对编译器的指导和代码的表达方式需要精心设计，以便充分利用现代处理器的向量化能力。</p>
<h2 id="Write-up-4-分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快"><a href="#Write-up-4-分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快" class="headerlink" title="Write-up 4: 分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快"></a>Write-up 4: 分析为什么汇编代码没有使用向量寄存器，并探讨向量化是否会更快</h2><p>在例子3中，<code>test</code> 函数实现了一个简单的数组赋值操作，其中数组 <code>a</code> 的每个元素被设置为数组 <code>b</code> 中下一个元素的值。具体代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">    a[i] = b[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码的特点是每次循环都涉及到对数组 <code>b</code> 的下一个元素的访问，这种“滑动窗口”类型的数据访问模式可能是阻碍向量化的原因。</p>
<h4 id="为什么汇编中没有使用向量寄存器？"><a href="#为什么汇编中没有使用向量寄存器？" class="headerlink" title="为什么汇编中没有使用向量寄存器？"></a><strong>为什么汇编中没有使用向量寄存器？</strong></h4><ol>
<li><p><strong>数据依赖性</strong>：</p>
<ul>
<li>在这个循环中，每个 <code>a[i]</code> 的计算依赖于 <code>b</code> 数组的连续元素 (<code>b[i+1]</code>)。这种数据依赖关系导致了数据访问的“依赖滞后”，这可能阻止编译器使用向量寄存器进行并行处理，因为向量化需要数据之间相对独立，以便同时处理多个数据。</li>
</ul>
</li>
<li><p><strong>内存对齐问题</strong>：</p>
<ul>
<li>对于有效的向量化，通常需要数据严格对齐到特定的字节界限（如16字节或32字节对齐）。在本例中，<code>b[i+1]</code> 的访问模式打破了可能的对齐界限，可能使得编译器难以应用标准的向量化策略。</li>
</ul>
</li>
<li><p><strong>向量化的复杂性</strong>：</p>
<ul>
<li>尽管现代编译器能够自动识别并向量化多种循环模式，但“滑动窗口”类型的操作增加了向量化的复杂性，特别是当窗口移动跨越多个数据块时。这可能需要更复杂的预取和数据重组策略，编译器可能认为标准的向量化不足以带来性能上的收益。</li>
</ul>
</li>
</ol>
<h4 id="如果进行了向量化，会更快吗？"><a href="#如果进行了向量化，会更快吗？" class="headerlink" title="如果进行了向量化，会更快吗？"></a><strong>如果进行了向量化，会更快吗？</strong></h4><ul>
<li><p><strong>潜在的速度提升</strong>：</p>
<ul>
<li>如果能够有效地向量化这种类型的循环，理论上可以提高执行速度，因为向量化可以利用现代CPU的SIMD（单指令多数据）能力，同时处理多个数组元素，显著减少总的处理时间。</li>
</ul>
</li>
<li><p><strong>实际的向量化挑战</strong>：</p>
<ul>
<li>实现这种类型的向量化可能需要手动干预或使用特定的编译器指令，例如通过使用内置函数重新安排数据或显式地使用SIMD指令集编程。</li>
<li>同时，需要考虑数据的预取和重组，以确保内存访问的连续性和对齐，这些都可能增加实现的复杂度。</li>
</ul>
</li>
</ul>
<p>总结来说，尽管向量化这类循环在理论上可能提高性能，但实际上实现向量化可能需要克服数据依赖和对齐等技术障碍。在这种情况下，编译器可能决定不进行向量化，因为它可能无法保证向量化后的性能收益足以抵消实现的复杂性。如果确实需要优化这种循环，可能需要更深入地探索编译器的向量化选项或手动优化代码。</p>
<h2 id="Write-up-5-检查汇编并验证是否正确向量化"><a href="#Write-up-5-检查汇编并验证是否正确向量化" class="headerlink" title="Write-up 5: 检查汇编并验证是否正确向量化"></a>Write-up 5: 检查汇编并验证是否正确向量化</h2><p>在示例4中，首先使用不带 <code>-ffast-math</code> 标志的编译指令编译 <code>test</code> 函数，这是一个简单的累加浮点数组的循环。初次编译结果显示，代码没有被向量化，并且使用了 <code>addsd</code> 指令，这是单个双精度浮点数的标量加法指令。</p>
<h4 id="未向量化的原因："><a href="#未向量化的原因：" class="headerlink" title="未向量化的原因："></a><strong>未向量化的原因：</strong></h4><p>浮点加法具有一些特殊性，特别是涉及到浮点数的关联性和可交换性时。由于浮点数计算的特殊规则（如IEEE浮点标准中的舍入模式和对特殊值的处理），编译器默认情况下不会假设浮点加法操作是关联的。这意味着编译器不会自动重组这些操作以利用SIMD指令，因为这可能改变计算结果。</p>
<h4 id="使用-ffast-math-的影响："><a href="#使用-ffast-math-的影响：" class="headerlink" title="使用 -ffast-math 的影响："></a><strong>使用 <code>-ffast-math</code> 的影响：</strong></h4><p>添加 <code>-ffast-math</code> 编译标志可以放宽对浮点数精确行为的限制，允许编译器假设加法是关联的并可以重排序操作。这样，编译器可以自由地使用SIMD指令来加速计算，因为它不需要严格遵守IEEE浮点标准的所有规则。</p>
<p>重新编译后，看到汇编代码中出现了如 <code>addpd</code> 或 <code>vaddpd</code> 等向量化指令，这些指令可以同时处理多个浮点数，提高了代码的执行效率。</p>
<h4 id="使用和不使用-ffast-math-的比较："><a href="#使用和不使用-ffast-math-的比较：" class="headerlink" title="使用和不使用 -ffast-math 的比较："></a><strong>使用和不使用 <code>-ffast-math</code> 的比较：</strong></h4><p>运行编译后的程序时，注意到使用和不使用 <code>-ffast-math</code> 标志的输出结果可能有细微差别。这些差别通常源于浮点计算的不同舍入行为和精确度要求的放宽。</p>
<ul>
<li><p>**使用 <code>-ffast-math</code>**：会产生更快的执行时间，因为编译器可以使用SIMD优化。结果与严格按照IEEE标准执行的结果略有不同，因为发生了计算顺序的改变或是舍入行为的变化。</p>
</li>
<li><p>**不使用 <code>-ffast-math</code>**：执行更慢，但结果会严格遵守IEEE浮点标凈，对于需要高度数值精确的应用来说，这是必须的。</p>
</li>
</ul>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h4><p>在决定是否使用 <code>-ffast-math</code> 时，需要权衡性能提升和数值精确度之间的关系。对于对性能要求极高但对精确度要求不是非常严格的应用，启用 <code>-ffast-math</code> 是有益的。然而，对于科学计算和精确金融计算等领域，最好还是保持默认的严格浮点行为，以保证结果的准确性。</p>
<h2 id="Write-up-6-向量化代码与非向量化代码的性能比较及使用-mavx2-的影响"><a href="#Write-up-6-向量化代码与非向量化代码的性能比较及使用-mavx2-的影响" class="headerlink" title="Write-up 6: 向量化代码与非向量化代码的性能比较及使用 -mavx2 的影响"></a>Write-up 6: 向量化代码与非向量化代码的性能比较及使用 <code>-mavx2</code> 的影响</h2><h4 id="性能提升的测量"><a href="#性能提升的测量" class="headerlink" title="性能提升的测量"></a><strong>性能提升的测量</strong></h4><p>要了解向量化带来的性能提升，可以通过对比向量化前后的执行时间来衡量。在实验中，通过在AWS的特定环境下运行 <code>loop</code> 程序，并使用不同的编译标志来激活或关闭向量化，可以得到关于向量化效果的直观认识。</p>
<ol>
<li><p><strong>编译并运行向量化与非向量化的代码</strong>：</p>
<ul>
<li>使用 <code>make clean; make</code> 编译并运行基础代码以获取未向量化的执行时间。</li>
<li>使用 <code>make clean; make VECTORIZE=1</code> 编译并运行向量化代码，使用 <code>-mavx</code> 标志。</li>
<li>使用 <code>make clean; make VECTORIZE=1 AVX2=1</code> 再次编译并运行，这次使用 <code>-mavx2</code> 标志以启用AVX2指令集，这提供了更大的向量寄存器。</li>
</ul>
</li>
<li><p><strong>测量并记录执行时间</strong>：</p>
<ul>
<li>在每种情况下，记录程序的执行时间。需要多次运行以获取更稳定的结果，并取中位数作为最终结果。</li>
</ul>
</li>
</ol>
<h4 id="性能提升分析"><a href="#性能提升分析" class="headerlink" title="性能提升分析"></a><strong>性能提升分析</strong></h4><ul>
<li><p>**基础向量化 (<code>-mavx</code>)**：</p>
<ul>
<li>向量化通常可以显著提高数据并行循环的执行速度。对于简单的数组操作，如数组加法，使用基础的AVX指令集向量化已经提供了显著的加速，2倍左右的性能提升。</li>
</ul>
</li>
<li><p>**进一步使用 <code>-mavx2</code>**：</p>
<ul>
<li>启用 <code>-mavx2</code> 后，因为AVX2支持更宽的向量操作（256位），所以会观察到进一步的性能提升。这表现为总体上更高的加速比，从2倍左右提高到3倍左右。</li>
</ul>
</li>
</ul>
<h4 id="推断AWS运行环境的向量寄存器宽度"><a href="#推断AWS运行环境的向量寄存器宽度" class="headerlink" title="推断AWS运行环境的向量寄存器宽度"></a><strong>推断AWS运行环境的向量寄存器宽度</strong></h4><ul>
<li><p><strong>默认向量寄存器宽度</strong>：</p>
<ul>
<li>如果未使用 <code>-mavx2</code> 标志时观察到了显著的加速，这暗示默认的向量寄存器是128位宽（标准AVX指令）。</li>
</ul>
</li>
<li><p><strong>AVX2向量寄存器宽度</strong>：</p>
<ul>
<li>使用 <code>-mavx2</code> 标志并观察到额外的性能提升，暗示AVX2向量寄存器宽度是256位。</li>
</ul>
</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>这些实验显示，向量化能显著提高数据并行任务的性能，尤其是在使用现代指令集如AVX2时。进一步分析这些数据，可以了解默认的向量寄存器和AVX2寄存器的宽度及其对性能的具体影响。此外，了解和选择合适的编译器标志对于充分利用现代硬件的向量处理能力至关重要。</p>
<h2 id="Write-up-7-比较向量化开启与未开启时的汇编代码"><a href="#Write-up-7-比较向量化开启与未开启时的汇编代码" class="headerlink" title="Write-up 7: 比较向量化开启与未开启时的汇编代码"></a>Write-up 7: 比较向量化开启与未开启时的汇编代码</h2><p>为了深入了解代码的向量化表现，可以直接查看编译器生成的汇编代码。通过分析这些代码，可以明确看到哪些指令被用于执行向量化操作，以及这些操作是如何被优化的。</p>
<h4 id="步骤和方法"><a href="#步骤和方法" class="headerlink" title="步骤和方法"></a><strong>步骤和方法</strong></h4><ol>
<li><p><strong>生成汇编代码</strong>：</p>
<ul>
<li>使用 <code>make ASSEMBLE=1 VECTORIZE=1</code> 命令生成启用向量化的汇编代码。</li>
<li>使用 <code>make ASSEMBLE=1 VECTORIZE=0</code> 生成未启用向量化的汇编代码。</li>
</ul>
</li>
<li><p><strong>检查汇编代码</strong>：</p>
<ul>
<li>打开生成的 <code>loop.s</code> 文件，查找与向量化操作相关的指令。</li>
</ul>
</li>
<li><p><strong>向量化指令对比</strong>：</p>
<ul>
<li>在启用向量化的代码中，寻找负责向量加法操作的指令。</li>
<li>再次编译代码，这次使用 <code>AVX2=1</code> 标志，查找与此设置相关的向量加法指令。</li>
</ul>
</li>
</ol>
<h4 id="汇编指令的识别"><a href="#汇编指令的识别" class="headerlink" title="汇编指令的识别"></a><strong>汇编指令的识别</strong></h4><ul>
<li><p><strong>不启用AVX2时的向量加法指令</strong>（基于SSE2指令集）：</p>
<ul>
<li>通常使用 <code>addpd</code> 或 <code>addps</code> 指令进行双精度或单精度的向量加法。</li>
<li>示例指令：<code>addpd %xmm1, %xmm0</code></li>
<li>这指令将 <code>%xmm1</code> 寄存器中的数据加到 <code>%xmm0</code> 寄存器中的数据。</li>
</ul>
</li>
<li><p><strong>启用AVX2时的向量加法指令</strong>：</p>
<ul>
<li>在AVX2指令集中，可以使用 <code>vaddpd</code> 或 <code>vaddps</code> 指令进行更宽向量寄存器的加法操作。</li>
<li>示例指令：<code>vaddpd %ymm1, %ymm0, %ymm0</code></li>
<li>这指令将 <code>%ymm1</code> 中的数据与 <code>%ymm0</code> 中的数据相加，结果存回 <code>%ymm0</code>。</li>
</ul>
</li>
</ul>
<h4 id="性能和优化"><a href="#性能和优化" class="headerlink" title="性能和优化"></a><strong>性能和优化</strong></h4><ul>
<li><p><strong>分析向量化的效果</strong>：</p>
<ul>
<li>观察启用和未启用向量化时汇编代码的差异，特别是循环结构和操作的表示。</li>
<li>检查是否有额外的优化，如循环展开或特定的数据预取指令，这些在启用向量化时出现。</li>
</ul>
</li>
<li><p><strong>改善汇编代码的可读性</strong>：</p>
<ul>
<li>考虑在Makefile中移除 <code>-g</code> 和 <code>-gdwarf-3</code> 标志，以减少调试符号，使汇编代码更加简洁。</li>
<li>使用 <code>-fno-unroll-loops</code> 标志有助于更清晰地观察循环的向量化情况，因为这可以防止编译器自动展开循环。</li>
</ul>
</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>通过比较不同编译标志下的汇编输出，可以具体了解编译器如何处理向量化指令，以及这些指令对程序性能的潜在影响。理解这些基础可以帮助开发者优化代码，并充分利用现代处理器的向量处理能力。</p>
<h2 id="Write-up-8-使用-OP-宏实验不同的运算符"><a href="#Write-up-8-使用-OP-宏实验不同的运算符" class="headerlink" title="Write-up 8: 使用 OP 宏实验不同的运算符"></a>Write-up 8: 使用 <strong>OP</strong> 宏实验不同的运算符</h2><p>在本实验中，通过更改数据并行循环中的运算符来测试不同类型的向量运算。在这个实验中，运算符由一个宏 <code>__OP__</code> 定义，能够轻松地更换使用的运算符，并观察其对向量化的影响。</p>
<h4 id="操作符的修改和初始化问题"><a href="#操作符的修改和初始化问题" class="headerlink" title="操作符的修改和初始化问题"></a><strong>操作符的修改和初始化问题</strong></h4><ol>
<li><strong>初始化问题</strong>：<ul>
<li>由于数组 B 被初始化为全零，使用 <code>/</code> 或 <code>%</code> 运算符时会导致除零错误。为解决这个问题，可以在初始化数组 B 时填充非零值，例如使用 <code>1</code> 来避免除零错误。</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">    b[i] = <span class="number">1</span>; <span class="comment">// 设置为非零值以避免除零错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>改变运算符</strong>：<ul>
<li>修改数据并行循环中使用的运算符，例如尝试使用加 (<code>+</code>), 减 (<code>-</code>), 乘 (<code>*</code>), 除 (<code>/</code>), 和位移 (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>) 等运算。</li>
</ul>
</li>
</ol>
<h4 id="向量化的观察"><a href="#向量化的观察" class="headerlink" title="向量化的观察"></a><strong>向量化的观察</strong></h4><ul>
<li><strong>不同运算符的向量化表现</strong>：<ul>
<li>大多数基本算术运算（加、减、乘、除）都应该能够在启用 <code>VECTORIZE=1 AVX2=1</code> 时被成功向量化，因为现代向量处理单元支持这些操作的硬件实现。</li>
<li>对于位移运算符如 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code>，向量化可能更复杂，因为它们通常需要不同的硬件支持。</li>
</ul>
</li>
</ul>
<h4 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a><strong>汇编代码分析</strong></h4><ul>
<li><p><strong>VECTORIZE&#x3D;1 的位移运算</strong>：</p>
<ul>
<li>在只启用 <code>VECTORIZE=1</code> 时，编译器可能使用标准的向量位移指令（如 <code>pslld</code> 或 <code>psrlq</code> 等）处理整数数组的位移。</li>
<li>示例指令：<code>pslld xmm0, 1</code>（将 <code>xmm0</code> 寄存器中的值左移1位）。</li>
</ul>
</li>
<li><p><strong>VECTORIZE&#x3D;1 AVX2&#x3D;1 的位移运算</strong>：</p>
<ul>
<li>启用 <code>AVX2=1</code> 后，编译器可使用更宽的向量寄存器（如 <code>ymm</code>），并可能使用相应的AVX2位移指令（如 <code>vpslld ymm0, ymm1, imm8</code>）。</li>
<li>示例指令：<code>vpslld ymm0, ymm1, 1</code>（将 <code>ymm1</code> 寄存器中的值左移1位，并存入 <code>ymm0</code>）。</li>
</ul>
</li>
</ul>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>实验表明，大多数基本算术运算符可以成功向量化，而位移运算符的向量化可能取决于具体的编译器实现和目标硬件的支持。了解和选择合适的编译器标志和硬件指令集对充分利用向量处理能力至关重要。此外，适当的数组初始化也是避免运行时错误的关键。</p>
<h2 id="Write-up-9-比较不同数据类型对向量化性能的影响"><a href="#Write-up-9-比较不同数据类型对向量化性能的影响" class="headerlink" title="Write-up 9: 比较不同数据类型对向量化性能的影响"></a>Write-up 9: 比较不同数据类型对向量化性能的影响</h2><p>在本实验中，会探索改变数据类型对内存需求和向量包装能力的影响，特别是在使用加法运算符时，对比使用 <code>uint64_t</code>, <code>uint32_t</code>, <code>uint16_t</code>, 和 <code>uint8_t</code> 数据类型的向量化代码与非向量化代码之间的性能差异。</p>
<h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>数据类型更改</strong>：改变数组A、B、C的数据类型，分别从 <code>uint64_t</code> 到 <code>uint8_t</code>。</li>
<li><strong>运算符设置</strong>：设置运算符 <code>OP</code> 为加法 <code>+</code>。</li>
<li><strong>编译和运行</strong>：分别为每种数据类型编译和运行代码，一次不启用向量化，一次启用AVX2向量化。</li>
<li><strong>性能测量</strong>：记录每种情况下的执行时间，并计算向量化代码相对于非向量化代码的加速比。</li>
</ul>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ol>
<li><p>**<code>uint64_t</code>**：</p>
<ul>
<li>非向量化代码表现较差，因为每次操作的数据量较大。</li>
<li>向量化代码（尤其是AVX2）显示出一定的加速，但由于寄存器宽度限制，每个寄存器只能包含较少的元素。</li>
</ul>
</li>
<li><p>**<code>uint32_t</code>**：</p>
<ul>
<li>这是较常见的选择，向量化可以较好地加速，因为一个256位的AVX2寄存器可以包含8个 <code>uint32_t</code> 元素。</li>
</ul>
</li>
<li><p>**<code>uint16_t</code>**：</p>
<ul>
<li>内存需求更小，每个向量寄存器可以包含更多元素（例如，16个元素），这导致更高的加速比。</li>
</ul>
</li>
<li><p>**<code>uint8_t</code>**：</p>
<ul>
<li>每个向量寄存器可以包含更多的元素（如32个），这提供最高的加速比，因为更多的操作可以并行执行。</li>
</ul>
</li>
</ol>
<h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a><strong>性能提升</strong></h4><ul>
<li><p><strong>向量化代码相比于非向量化代码</strong>：</p>
<ul>
<li>对于所有数据类型，向量化通常都会带来性能提升。特别是当数据类型较小（如 <code>uint16_t</code> 和 <code>uint8_t</code>）时，加速比更为显著，因为可以在每个向量操作中处理更多元素。</li>
</ul>
</li>
<li><p><strong>AVX2向量化代码相比于非向量化代码</strong>：</p>
<ul>
<li>使用AVX2时，加速比通常会进一步提高，因为AVX2支持更宽的向量操作，可以一次处理更多的数据。</li>
</ul>
</li>
</ul>
<h4 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>数据类型对于向量化的性能影响显著。选择较小的数据类型可以减少内存需求并增加向量寄存器中可以包装的元素数量，从而提高性能。在设计和优化向量化应用程序时，应仔细考虑数据类型的选择以最大化性能。</p>
<h2 id="Write-up-10-测试使用-uint64-t-和-uint8-t-类型的向量乘法性能"><a href="#Write-up-10-测试使用-uint64-t-和-uint8-t-类型的向量乘法性能" class="headerlink" title="Write-up 10: 测试使用 uint64_t 和 uint8_t 类型的向量乘法性能"></a>Write-up 10: 测试使用 <code>uint64_t</code> 和 <code>uint8_t</code> 类型的向量乘法性能</h2><p>在此实验中探索使用不同数据类型（特别是 <code>uint64_t</code> 和 <code>uint8_t</code>）对于向量化代码在执行乘法操作时的性能影响。乘法操作相对于加法需要更多的时钟周期，这会影响向量化带来的性能提升。</p>
<h4 id="实验设置-1"><a href="#实验设置-1" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>数据类型</strong>：<code>uint64_t</code> 和 <code>uint8_t</code>。</li>
<li><strong>操作符</strong>：乘法 (<code>*</code>)。</li>
<li><strong>编译和测试</strong>：<ul>
<li>对于 <code>uint64_t</code> 和 <code>uint8_t</code>，分别编译并运行使用乘法的向量化和非向量化代码。</li>
<li>使用 <code>VECTORIZE=1</code> 和 <code>VECTORIZE=1 AVX2=1</code> 标志进行编译。</li>
</ul>
</li>
</ul>
<h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ol>
<li><p><strong><code>uint64_t</code> 数据类型</strong>：</p>
<ul>
<li><strong>非向量化代码</strong>：执行较慢，因为每次操作处理的数据量较大，且乘法操作相对耗时。</li>
<li><strong>向量化代码</strong>（AVX2）：虽然向量化可以提供一定程度的加速，但由于 <code>uint64_t</code> 数据类型的元素宽度较大，每个向量寄存器能处理的元素数量较少，限制了向量化的效益。</li>
</ul>
</li>
<li><p><strong><code>uint8_t</code> 数据类型</strong>：</p>
<ul>
<li><strong>非向量化代码</strong>：相对较慢，但由于处理的数据单元较小，所需的时钟周期较少。</li>
<li><strong>向量化代码</strong>（AVX2）：由于 <code>uint8_t</code> 类型允许单个向量寄存器包含更多元素（例如AVX2的32个元素），向量化提供了显著的加速。这种情况下，向量化乘法可以极大提升性能，因为可以同时处理更多的数据。</li>
</ul>
</li>
</ol>
<h4 id="性能提升-1"><a href="#性能提升-1" class="headerlink" title="性能提升"></a><strong>性能提升</strong></h4><ul>
<li>对于 <code>uint64_t</code> 类型，向量化的性能提升相对有限，只有轻微的改善，1.5倍左右的加速。</li>
<li>对于 <code>uint8_t</code> 类型，由于可以在一个操作中处理更多元素，加速比会更高，达到了4倍左右。</li>
</ul>
<h4 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>向量化在执行数据并行操作时能显著提高性能，特别是当操作单元较小时（如 <code>uint8_t</code>）。选择更小的数据类型可以增加向量寄存器中的元素数量，从而提高每次向量操作的效率。对于乘法这样的高成本操作，向量化的好处尤其明显。然而，对于较大的数据类型（如 <code>uint64_t</code>），尽管向量化能带来性能改善，其提升幅度有限，特别是当每个向量寄存器能处理的元素数量较少时。</p>
<h2 id="Write-up-11-分析使用-uint64-t-类型的AVX2向量化乘法与加法代码的性能"><a href="#Write-up-11-分析使用-uint64-t-类型的AVX2向量化乘法与加法代码的性能" class="headerlink" title="Write-up 11: 分析使用 uint64_t 类型的AVX2向量化乘法与加法代码的性能"></a>Write-up 11: 分析使用 <code>uint64_t</code> 类型的AVX2向量化乘法与加法代码的性能</h2><p>在这个实验中，使用 <code>awsrun perf record</code> 工具来收集使用 <code>uint64_t</code> 类型的AVX2向量化乘法操作的性能数据，然后通过 <code>aws-perf-report</code> 工具来分析哪些操作占用了最多的执行时间。比较乘法操作与加法操作在向量化环境中的性能差异。</p>
<h4 id="步骤和方法-1"><a href="#步骤和方法-1" class="headerlink" title="步骤和方法"></a><strong>步骤和方法</strong></h4><ol>
<li><p><strong>收集性能数据</strong>：</p>
<ul>
<li>对于乘法 (<code>*</code>) 操作，设置 <code>__OP__</code> 为乘法并使用 <code>awsrun perf record</code> 来执行程序，收集性能数据。</li>
<li>对于加法 (<code>+</code>) 操作，将 <code>__OP__</code> 改回加法并重复性能数据收集过程。</li>
</ul>
</li>
<li><p><strong>分析性能报告</strong>：</p>
<ul>
<li>使用 <code>aws-perf-report</code> 来分析收集到的性能数据，特别注意向量乘法与向量加法指令的执行时间占比。</li>
</ul>
</li>
</ol>
<h4 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ul>
<li><p><strong>向量乘法 (<code>*</code>) 性能分析</strong>：</p>
<ul>
<li>向量化的乘法操作会消耗较多的CPU时间，因为向量乘法相对于加法需要更多的时钟周期。</li>
<li>检查性能报告，观察是否有大量时间被消耗在 <code>vpmulld</code>（向量乘法）或其他相关向量乘法指令上。</li>
</ul>
</li>
<li><p><strong>向量加法 (<code>+</code>) 性能分析</strong>：</p>
<ul>
<li>向量加法操作通常需要较少的时钟周期，因此相比于向量乘法，其在性能报告中占用的时间比例较低。</li>
<li>分析性能报告，确认向量加法指令如 <code>vpadd</code> 在总执行时间中的占比。</li>
</ul>
</li>
</ul>
<h4 id="实验结果和结论"><a href="#实验结果和结论" class="headerlink" title="实验结果和结论"></a><strong>实验结果和结论</strong></h4><ul>
<li><p><strong>向量乘法的时间占比</strong>：</p>
<ul>
<li>如果发现向量乘法操作并没有占用大部分时间，可能的原因包括内存访问延迟或数据依赖导致的CPU空闲等。</li>
<li>分析是否有其他系统层面的操作（如内存加载）消耗了大量时间，这可能影响了整体的性能表现。</li>
</ul>
</li>
<li><p><strong>向量加法的时间占比</strong>：</p>
<ul>
<li>比较向量加法与乘法的性能数据，通常应观察到加法操作在性能报告中占用的时间比例较低，因为加法操作更快。</li>
</ul>
</li>
<li><p><strong>性能优化的见解</strong>：</p>
<ul>
<li>这种比较有助于理解不同向量操作的性能影响，为优化提供方向，尤其是在处理涉及复杂数据操作的应用时。</li>
<li>如果乘法操作占用过多时间，考虑优化算法或调整数据结构和访问模式，以减少性能瓶颈。</li>
</ul>
</li>
</ul>
<p>这项分析能够揭示在使用高级向量扩展时，不同算术操作在性能上的实际差异，从而为进一步的性能优化提供依据。</p>
<h2 id="Write-up-12-对于运行时确定的循环边界的向量化性能分析"><a href="#Write-up-12-对于运行时确定的循环边界的向量化性能分析" class="headerlink" title="Write-up 12: 对于运行时确定的循环边界的向量化性能分析"></a>Write-up 12: 对于运行时确定的循环边界的向量化性能分析</h2><p>在之前的实验中，循环的界限 <code>N</code> 是预先定义为1024的固定值，这使得编译器能够在编译时进行优化。改为在运行时通过命令行参数设置 <code>N</code>，将增加编译器处理向量化的复杂性，因为它不能再做出关于循环迭代次数的静态假设。</p>
<h4 id="实验设置-2"><a href="#实验设置-2" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>修改代码</strong>：将循环界限 <code>N</code> 的定义改为运行时决定：<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> N = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>编译和运行</strong>：对不同的 <code>N</code> 值（例如256, 512, 1024, 2048等）分别进行非向量化、AVX2向量化和非AVX2向量化的编译和测试。</li>
</ul>
<h4 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ul>
<li><p><strong>向量化与非向量化的比较</strong>：</p>
<ul>
<li>对于较小的 <code>N</code> 值，向量化代码不会显著优于非向量化代码，因为启动和管理向量操作的开销占据了较大比例。</li>
<li>随着 <code>N</code> 值的增加，向量化代码的性能优势应该更加明显，因为长循环更能够利用向量处理的并行性。</li>
</ul>
</li>
<li><p><strong>AVX2与非AVX2向量化的比较</strong>：</p>
<ul>
<li>使用AVX2指令集的向量化代码应该在所有 <code>N</code> 值下都显示出比普通向量化更好的性能，尤其是在 <code>N</code> 较大时，因为AVX2支持更宽的向量操作，可以处理更多数据。</li>
</ul>
</li>
</ul>
<h4 id="性能变化与-N-1024-的比较"><a href="#性能变化与-N-1024-的比较" class="headerlink" title="性能变化与 N = 1024 的比较"></a><strong>性能变化与 <code>N = 1024</code> 的比较</strong></h4><ul>
<li>当 <code>N</code> 较小（如256或以下）时，相对于 <code>N = 1024</code>，向量化带来的性能提升不那么显著。这是因为向量化的启动和管理成本在小规模数据上的相对影响更大。</li>
<li>当 <code>N</code> 较大（如2048或以上）时，向量化代码的性能提升应该比 <code>N = 1024</code> 时更加明显，因为较长的循环能更好地利用处理器的向量化能力，减少了相对开销。</li>
</ul>
<h4 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>改变 <code>N</code> 的定义使其在运行时确定，表明了编译器在处理不确定循环边界时的行为。虽然向量化在大多数情况下都能提供性能提升，但其效果受到循环长度的影响。实验结果显示，当循环边界较大时，向量化（尤其是使用AVX2）带来的性能提升更为显著。这强调了在设计向量化代码时，考虑数据规模和选择合适的编译器优化标志的重要性。</p>
<h2 id="Write-up-13-探索步长不为1时的向量化情况"><a href="#Write-up-13-探索步长不为1时的向量化情况" class="headerlink" title="Write-up 13: 探索步长不为1时的向量化情况"></a>Write-up 13: 探索步长不为1时的向量化情况</h2><p>在此实验中，调整数组遍历的步长（stride），并观察编译器是否能够向量化这样的循环。步长不为1意味着每次迭代跳过一个或多个元素，这可能影响编译器的向量化决策。</p>
<h4 id="实验设置-3"><a href="#实验设置-3" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><strong>数据类型和操作</strong>：设置 <code>__TYPE__</code> 为 <code>uint32_t</code>，<code>__OP__</code> 设置为加法 (<code>+</code>)。</li>
<li><strong>修改循环结构</strong>：将内部循环修改为步长为2的循环：<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j += <span class="number">2</span>) &#123;</span><br><span class="line">    C[j] = A[j] + B[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a><strong>编译和运行</strong></h4><ul>
<li>使用相应的编译标志进行编译，检查编译器是否能够向量化这种带有特定步长的循环。</li>
</ul>
<h4 id="向量化的观察与分析"><a href="#向量化的观察与分析" class="headerlink" title="向量化的观察与分析"></a><strong>向量化的观察与分析</strong></h4><ul>
<li><p><strong>编译器的向量化决策</strong>：</p>
<ul>
<li>对于步长为2的循环，编译器不会选择向量化。这是因为非连续的内存访问模式降低了数据的局部性，从而影响了向量化的效率。</li>
<li>向量单位虽然可以支持不同的步长，但在步长增大时，需要额外的指令来处理间隔较大的元素加载，这导致性能不如步长为1时优秀。</li>
</ul>
</li>
<li><p><strong>为什么可能不向量化</strong>：</p>
<ul>
<li><strong>内存访问效率</strong>：步长为2可能导致内存访问不连续，使得处理器缓存利用率下降，进而影响性能。</li>
<li><strong>复杂度增加</strong>：处理不连续数据需要额外的逻辑和指令，如间隔加载和额外的数据对齐处理，增加了编译器的实现复杂度。</li>
<li><strong>硬件优化限制</strong>：尽管现代硬件支持多种步长，但对于较大的步长，硬件加速可能不如连续访问显著。</li>
</ul>
</li>
</ul>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a><strong>实验结果</strong></h4><ul>
<li>在实际测试中，发现即使硬件和编译器支持向量化步长不为1的循环，性能提升也不如连续访问的情况显著。这一结果应通过检查生成的汇编代码中是否包含向量指令以及这些指令的性能指标来确认。</li>
</ul>
<h4 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>调整循环的步长可以是一个重要的性能优化方向，尤其是在处理步长非1的数据访问模式时。然而，开发者需要仔细考虑步长变化对向量化的可能影响，并通过实验验证预期的优化效果。如果向量化未带来预期的性能提升，可能需要探索其他优化策略或调整算法结构以适应硬件的特性。</p>
<h2 id="Write-up-14-使用-pragma-clang-loop-指令优化向量化"><a href="#Write-up-14-使用-pragma-clang-loop-指令优化向量化" class="headerlink" title="Write-up 14: 使用 #pragma clang loop 指令优化向量化"></a>Write-up 14: 使用 <code>#pragma clang loop</code> 指令优化向量化</h2><p>为了强制编译器向量化一个步长不为1的循环，用 <code>#pragma clang loop</code> 指令，这是 Clang 提供的一种语言扩展，用于控制循环的优化。这允许开发者对编译器的循环优化行为进行更细致的控制，尤其是在向量化方面。</p>
<h4 id="实验设置-4"><a href="#实验设置-4" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><p><strong>修改代码</strong>：在步长为2的循环前添加 <code>#pragma clang loop vectorize(enable)</code> 来尝试强制向量化该循环。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang loop vectorize(enable)</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j += <span class="number">2</span>) &#123;</span><br><span class="line">    C[j] = A[j] + B[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译与测试</strong>：</p>
<ul>
<li>分别编译并运行未使用AVX2和使用AVX2的向量化代码，记录并比较执行时间。</li>
<li>尝试修改 <code>vectorize_width</code> 参数，比如设置为2，来看看对性能的影响。</li>
</ul>
</li>
</ul>
<h4 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h4><ul>
<li><p><strong>基本向量化测试</strong>：</p>
<ul>
<li>使用基本的 <code>#pragma clang loop vectorize(enable)</code> 指令会看到一定的性能提升，因为编译器被提示尽可能向量化该循环。</li>
</ul>
</li>
<li><p>**修改 <code>vectorize_width</code>**：</p>
<ul>
<li>将 <code>vectorize_width</code> 设置为2会进一步影响性能，因为这指示编译器在向量化时使用更小的向量宽度。这对于步长为2的循环更为合适。</li>
</ul>
</li>
<li><p><strong>使用AVX2</strong>：</p>
<ul>
<li>启用AVX2向量化应该会看到更显著的性能提升，因为AVX2支持更宽的向量操作，可以更有效地处理数据。</li>
</ul>
</li>
</ul>
<h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a><strong>实验结果</strong></h4><ul>
<li>在不同的 <code>vectorize_width</code> 和是否使用AVX2的条件下，性能提升会有所不同。通常，使用AVX2的向量化代码相比于非向量化代码会有更明显的加速。</li>
<li>如果适当调整 <code>vectorize_width</code>，比如设置为与数据访问模式更匹配的值，会进一步优化性能。</li>
</ul>
<h4 id="最佳配置"><a href="#最佳配置" class="headerlink" title="最佳配置"></a><strong>最佳配置</strong></h4><ul>
<li>最佳配置会根据具体的循环内容和数据访问模式而变化。在一些情况下，适当地使用 <code>#pragma clang loop</code> 指令并调整相关参数可以显著提高向量化代码的性能。</li>
</ul>
<h4 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>通过使用 <code>#pragma clang loop</code> 指令，能够更精细地控制编译器的向量化行为，特别是在处理具有复杂访问模式的循环时。在合适的配置下，向量化代码相比于非向量化代码确实能够提供显著的性能提升。这种控制手段为性能优化提供了更多的可能性，尤其是在需要手动调整编译器行为以适应特定算法的情况下。</p>
<h2 id="Write-up-15-分析数组求和向量化的汇编实现"><a href="#Write-up-15-分析数组求和向量化的汇编实现" class="headerlink" title="Write-up 15: 分析数组求和向量化的汇编实现"></a>Write-up 15: 分析数组求和向量化的汇编实现</h2><p>在本实验中，通过汇编代码来理解编译器是如何向量化数组求和（reduction）操作的。向量化的求和操作对于理解数据归约在现代处理器上的效率至关重要。</p>
<h4 id="实验设置-5"><a href="#实验设置-5" class="headerlink" title="实验设置"></a><strong>实验设置</strong></h4><ul>
<li><p><strong>修改代码</strong>：实现一个简单的数组求和循环，确保该循环是向量化的重点。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    total += A[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译并生成汇编代码</strong>：</p>
<ul>
<li>使用 <code>make ASSEMBLE=1</code> 编译代码，以生成详细的汇编代码文件，从而能够详细查看向量化实现。</li>
</ul>
</li>
</ul>
<h4 id="汇编代码分析-1"><a href="#汇编代码分析-1" class="headerlink" title="汇编代码分析"></a><strong>汇编代码分析</strong></h4><ul>
<li><p><strong>向量化操作的实现</strong>：</p>
<ul>
<li>在生成的汇编代码中，编译器通常会使用如 <code>vpaddd</code>（向量化整数加法）等指令来实现数组的求和。</li>
<li>编译器会将数组元素加载到多个向量寄存器中，然后在这些寄存器上执行并行加法操作。</li>
</ul>
</li>
<li><p><strong>具体的汇编指令</strong>：</p>
<ul>
<li>例如，编译器使用 <code>movdqa</code> 指令加载数据到 SIMD 寄存器（如 <code>xmm0</code>），然后使用 <code>paddd xmm0, xmm1</code> 将两个寄存器中的数据相加，实现部分和的累加。</li>
<li>对于更高位宽的指令集（如AVX2），会看到使用 <code>vpaddd ymm0, ymm0, ymm1</code> 这样的指令，这可以同时处理更多数据。</li>
</ul>
</li>
<li><p><strong>循环尾部处理</strong>：</p>
<ul>
<li>在处理不完全填充向量寄存器的数据时，编译器还会生成处理循环尾部（即数组大小不是向量宽度整数倍部分）的代码。</li>
<li>这通常涉及到在循环结束时对剩余元素进行标量处理，以确保所有元素都被正确求和。</li>
</ul>
</li>
</ul>
<h4 id="性能优化的观察"><a href="#性能优化的观察" class="headerlink" title="性能优化的观察"></a><strong>性能优化的观察</strong></h4><ul>
<li><p><strong>归约操作的并行化</strong>：</p>
<ul>
<li>通过将多次独立的加法操作合并到单个向量指令中，归约操作的向量化显著提高了处理速度。</li>
<li>向量化归约减少了执行的指令数量，并提高了数据通过率。</li>
</ul>
</li>
<li><p><strong>编译器优化的限制</strong>：</p>
<ul>
<li>虽然向量化可以显著加快归约操作的速度，但编译器在实现这一过程时需要插入额外的逻辑来处理边界情况，这些逻辑会稍微影响性能。</li>
</ul>
</li>
</ul>
<h4 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>汇编代码分析揭示了编译器如何有效地实现向量化数组求和操作。通过并行处理多个数组元素，向量化显著提高了性能。然而，为了完全理解和优化这类操作，开发者需要注意编译器如何处理向量化操作的细节，包括数据加载、并行执行和循环尾部处理。这些知识对于编写高效的向量化代码至关重要。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>软件性能工程</category>
        <category>MIT作业</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>软件性能工程</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验一-数字图像处理相关软件学习</title>
    <url>/2024/03/20/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><p>Python是干啥的？</p>
<p>BMP图像的结构是什么样的？</p>
<p>用VC怎么写图像处理的程序？</p>
<h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li><p>写个简单的Python程序，完成以下操作：</p>
<p>a)	打开一幅图片（如自己的照片）</p>
<p>b)	将图片大小修改成640*480</p>
<p>c)	将修改大小后的图像转成黑白图像</p>
<p>d)	将图像存成gif格式</p>
</li>
<li><p>不知道大家还记不记得奥运开幕式中那一幅幅小的笑脸照片组成大大的笑脸环节，其实日常生活中也有很多这样类似的创意，用很多幅小的相关图片组成一副大的主题图片，如下面右图就是用很多表情笑脸图合成左图的效果。考虑一下如果自己写程序的话，怎么来实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps1.jpg"
                      alt="img"
                ></p>
</li>
</ol>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><ol>
<li>写个简单的Python程序，完成指定操作。</li>
</ol>
<p>(1) 首先安装Python的图像处理库Pillow</p>
<p>(2) 导入库中的Image对象</p>
<p>(3) 使用Image对象的open函数打开图像</p>
<p>(4) 通过resize方法将图像大小设置为640x480</p>
<p>(5) 通过convert方法将图像灰度化</p>
<p>(6) 通过save方法将处理后的图像保存下来</p>
<ol start="2">
<li>马赛克图像合成。</li>
</ol>
<p>准备实验环境和素材。</p>
<p>(1) 安装Python的图像处理库Pillow和数学运算库NumPy。</p>
<p>(2) 准备一个大的目标图像和一组小图片素材。</p>
<p>处理小图片集。</p>
<p>(1) 定义函数以计算小图片的平均颜色。</p>
<p>(2) 遍历图标文件夹，调整每个小图片的大小。</p>
<p>实现马赛克图像合成。</p>
<p>(1) 定义函数以创建马赛克图像。</p>
<p>(2) 调整目标图像的大小以适应马赛克格子。</p>
<p>(3) 分割目标图像并为每个格子选择颜色匹配的小图片。</p>
<p>(4) 将小图片粘贴到对应的马赛克格子中。</p>
<p>保存并测试结果。</p>
<p>(1) 将生成的马赛克图像保存到指定路径。</p>
<p>(2) 检查输出文件夹以确认图像是否正确生成。</p>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><ol>
<li>写个简单的Python程序，完成指定操作。</li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">original_image = Image.<span class="built_in">open</span>(input_path)</span><br><span class="line">    original_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps2.png"
                      alt="img"
                > </p>
<center>图 1原始图像</center>




<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">    resized_image = original_image.resize((<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line">    resized_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps3.png"
                      alt="img"
                > </p>
<center>图 2改变大小之后的图像</center>




<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">    bw_image = resized_image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    bw_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps4.png"
                      alt="img"
                > </p>
<center>图 3灰度化之后的图像</center>




<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">bw_image.save(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>/exp1_1_4.gif&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps5.png"
                      alt="img"
                > </p>
<center>图 4将黑白图像存成gif格式</center>



 

<ol start="2">
<li>马赛克图像合成</li>
</ol>
<p>准备实验环境和素材:</p>
<p>确保安装了Python图像处理库Pillow和数学运算库<code>NumPy</code>。</p>
<p>在代码中设置目标图像<code>（target_image_path）</code>和小图片集合<code>（icon_folder）</code>的路径。</p>
<p>处理小图片集:</p>
<p>使用<code>get_average_color(image)</code>函数计算每个小图片的平均颜色。这个函数接收一个图像对象作为参数，计算其在RGB颜色空间中的平均颜色，并返回表示这种颜色的元组。</p>
<p><code>resize_icons(icon_folder, icon_size)</code>函数遍历小图片所在的文件夹，并将每张图片调整到指定的大小。这是为了使得小图片与马赛克图像的每个格子大小相匹配。</p>
<p>实现马赛克图像合成:</p>
<p><code>create_photo_mosaic(target_image_path, icons, grid_size)</code>函数用于创建马赛克图像。</p>
<p>首先，该函数调整目标图像的大小，使其与马赛克网格的大小匹配。</p>
<p>接着，它将目标图像分割成与网格大小相匹配的小区域。</p>
<p>对于每个区域，函数找到颜色最接近该区域平均颜色的小图片，并将其放置在相应的位置上。</p>
<p>保存并测试结果:</p>
<p>一旦马赛克图像创建完毕，使用<code>mosaic_image.save(output_path)</code>将其保存到指定路径。</p>
<p>保存后的马赛克图像可以在指定的输出中查看。</p>
<p>效果浏览：</p>
<center>grid_size = (5, 5):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps6.jpg"
                      alt="img"
                > </p>
<center>grid_size = (4, 4):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps7.jpg"
                      alt="img"
                > </p>
<center>grid_size = (3, 3):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps8.jpg"
                      alt="img"
                > </p>
<center>grid_size = (3, 2):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps9.jpg"
                      alt="img"
                > </p>
<center>grid_size = (2, 3):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps10.jpg"
                      alt="img"
                > </p>
<center>grid_size = (1, 1):</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0/wps11.jpg"
                      alt="img"
                > </p>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>通过实验第一部分，我学会了如何使用Python及其第三方库Pillow进行基本的图像处理操作。这个实验让我体会到了Python在图像处理方面的强大和灵活性。通过简单的代码，我能够打开图像，改变其大小，将其转换为黑白图像，甚至将其保存为不同的格式，如GIF。这些操作在数字图像处理中非常常见，而Python使这些操作变得易于实现和理解。</p>
<p>实验中，我首先引入了Python的图像处理库Pillow，然后使用它提供的Image对象来进行各种图像操作。例如，我利用<code>open</code>函数打开了一幅图像，然后通过<code>resize</code>方法将图像的尺寸更改为640x480像素。接着，我使用了<code>convert</code>方法将图像转换为灰度（黑白）图像，最后通过<code>save</code>方法将处理后的图像保存下来。这个过程不仅加深了我对图像处理基础概念的理解，也提高了我使用编程语言来解决实际问题的能力。</p>
<p>在实验第二部分中，我进行了更为复杂的图像处理操作，即马赛克图像合成。这个过程包括创建一个由许多小图像组合成的大图像。我学会了如何处理和调整多个图像，以便将它们组合成一个单一的、具有视觉效果的图像。依靠准备的目标图像和小图片素材，编写了函数来计算小图片的平均颜色并调整其大小。之后，我通过比较颜色相似性来选择最合适的小图片，并将它们粘贴到目标图像的相应位置上。这个实验不仅锻炼了我的编程技能，还增强了我在创意图像处理方面的能力。</p>
<p>总的来说，这个实验不仅提高了我的Python编程能力，还让我对数字图像处理有了更深刻的理解。通过这些实验，我学会了如何使用编程工具来创造和操纵图像，这将对我的未来学习和职业发展大有裨益。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验三-频率域图像增强</title>
    <url>/2024/04/29/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%B8%89-%E9%A2%91%E7%8E%87%E5%9F%9F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><ol>
<li><p><strong>图像频域变换与滤波处理</strong>：</p>
<ul>
<li>对一系列图像（1.bmp，2.bmp，2.jpg，3.bmp，4.bmp）进行傅立叶变换和离散余弦变换（DCT）以分析其频域特征。</li>
<li>使用空间域图像增强方法来增强变换后得到的频谱图。</li>
<li>应用低通和高通滤波器对图像进行频率域滤波，并通过设置不同的阈值来观察滤波效果。</li>
</ul>
</li>
<li><p><strong>频率域图像比较分析</strong>：</p>
<ul>
<li>比较指定图像对（5.bmp和10.bmp，6.bmp和9.bmp，10.bmp、11.bmp和12.bmp）的频率域特征，分析不同图像在频率域的差异性，并探讨其背后的原因。</li>
</ul>
</li>
<li><p><strong>频谱图逆变换的优化学习实验</strong>：</p>
<ul>
<li>使用PyTorch实现离散傅里叶逆变换，并将频谱图的初始值设为高斯噪声的模型参数。</li>
<li>通过将逆变换结果与原图之间的均方误差作为损失函数，对模型参数进行优化，验证是否能够通过优化学习到精确的频谱图。</li>
</ul>
</li>
</ol>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li>用Python写一段程序，针对提供的图片IMG_2546.jpg，实现：</li>
</ol>
<p>①查看直方图 </p>
<p>②取反，再查看直方图 </p>
<p>③使用直方图均衡，再查看直方图 </p>
<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p>实验图片路径为： imgs&#x2F;IMG_2546.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_1_i的格式，输出四个结果，比如①的结果保存为：outputs&#x2F;exp2_1_1.jpg</p>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p><strong>步骤一：查看原图直方图</strong></p>
<ul>
<li>首先，加载图片并使用OpenCV库进行读取。</li>
<li>使用Matplotlib绘制图像的直方图，这是通过计算每个颜色通道的像素强度分布来完成的。</li>
<li>保存包含原图和直方图的组合图像为 <code>outputs/exp2_1_1.jpg</code>。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ①查看原图直方图</span></span><br><span class="line">save_image_and_histogram(img, <span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Original Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：取反图像并查看直方图</strong></p>
<ul>
<li>对原始图像进行取反操作，这意味着将每个像素的颜色值变为其补色。</li>
<li>再次绘制取反后图像的直方图，并保存。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ②取反并查看直方图</span></span><br><span class="line">img_neg = cv2.bitwise_not(img)</span><br><span class="line">save_image_and_histogram(img_neg, <span class="string">&#x27;Negative Image&#x27;</span>, <span class="string">&#x27;Negative Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：直方图均衡化并查看直方图</strong></p>
<ul>
<li>将图像从BGR色彩空间转换为YUV色彩空间。</li>
<li>对Y通道（亮度）进行直方图均衡化，这能改善图像的对比度。</li>
<li>再次绘制直方图均衡化后图像的直方图，并保存。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ③直方图均衡化并查看直方图</span></span><br><span class="line">img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span><br><span class="line">img_yuv[:,:,<span class="number">0</span>] = cv2.equalizeHist(img_yuv[:,:,<span class="number">0</span>])</span><br><span class="line">img_histeq = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)</span><br><span class="line">save_image_and_histogram(img_histeq, <span class="string">&#x27;Histogram Equalization&#x27;</span>, <span class="string">&#x27;Eq Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：精确提取文本区域</strong></p>
<ul>
<li>考虑到文本可能因拍摄角度而不完全水平，我应用了一个旋转变换，使文本尽可能地水平以便裁剪。</li>
<li>设置旋转中心为图像中心，并指定旋转角度（在这里是-10度）。这个角度可能需要根据具体图片进行微调。</li>
<li>应用旋转后，根据旋转后的图像内容，手动确定“爱丁堡花园”文本的精确位置并进行裁剪。</li>
<li>最后，将旋转和裁剪后的区域保存为 <code>outputs/exp2_1_4.jpg</code>，这是仅包含目标文本区域的图片。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ④仅保留“爱丁堡花园”部分</span></span><br><span class="line"><span class="comment"># 获取图像尺寸用于计算旋转中心</span></span><br><span class="line">rows, cols, _ = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置旋转矩阵，中心点为图像中心，旋转角度为-10度，缩放因子为1</span></span><br><span class="line">M = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), -<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转图像</span></span><br><span class="line">rotated_img = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在旋转后的图像中确定“爱丁堡花园”文字的大致位置</span></span><br><span class="line">img_crop = rotated_img[<span class="number">550</span>:<span class="number">630</span>, <span class="number">600</span>:<span class="number">910</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存剪裁后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>exp2_1_4.jpg&#x27;</span>, img_crop)</span><br></pre></td></tr></table></figure></div>



<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p>①查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show01.png"
                      alt="实际输出"
                ></p>
<p>②取反，再查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show02.png"
                      alt="实际输出"
                ></p>
<p>③使用直方图均衡，再查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show03.png"
                      alt="实际输出"
                ></p>
<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show04.png"
                      alt="实际输出"
                ></p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>人脸1.jpg、2.jpg、3.jpg、4.jpg进行滤波等操作实现类似美图秀秀磨皮功能，并对比磨皮前后直方图变化。</p>
<p>实验图片路径为： imgs&#x2F;1.jpg imgs&#x2F;2.jpg imgs&#x2F;3.jpg imgs&#x2F;4.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_2_i的格式，输出四个结果，比如结果保存为：outputs&#x2F;exp2_2_1.jpg</p>
<h3 id="实验方案：-1"><a href="#实验方案：-1" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p>通过应用双边滤波器对给定的人脸图像进行磨皮处理，然后对比处理前后图像的直方图变化。双边滤波器是一种非线性的滤波方法，它可以在平滑图像噪声的同时保留边缘信息，因此特别适合于图像美化处理。在Python中，可以使用OpenCV库中的<code>bilateralFilter</code>函数来实现这一操作。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用双边滤波器进行磨皮</span></span><br><span class="line">smoothed = cv2.bilateralFilter(image, d=<span class="number">9</span>, sigmaColor=<span class="number">75</span>, sigmaSpace=<span class="number">75</span>)</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>d</code>表示滤波器的直径，<code>sigmaColor</code>表示颜色空间的标准差，<code>sigmaSpace</code>表示坐标空间的标准差。这些参数决定了滤波器平滑图像的程度。</p>
<p>直方图的对比通过计算原图像和磨皮后图像的颜色直方图，并用不同颜色的线表示出来。这一过程可以直观地观察磨皮效果对图像色彩分布的影响。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算直方图并绘制</span></span><br><span class="line">hist_original = cv2.calcHist([original], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_smoothed = cv2.calcHist([smoothed], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(hist_original, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.plot(hist_smoothed, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;Smoothed&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show10.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show11.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show12.png"
                      alt="实际输出"
                ></p>
<p><strong>图1的分析</strong></p>
<p>原始图像和经过双边滤波处理后的图像在直方图上差别不大。这表明图像的磨皮效果较为自然，没有过度平滑，同时保持了原图的色彩特征。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show20.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show21.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show22.png"
                      alt="实际输出"
                ></p>
<p><strong>图2的分析</strong></p>
<p>可以看到在某些颜色通道中，经过滤波处理后的直方图在峰值附近略微平滑，但整体色彩分布的变化不是特别显著。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show30.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show31.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show32.png"
                      alt="实际输出"
                ></p>
<p><strong>图3的分析</strong></p>
<p>滤波后图像的直方图在低亮度区域有了平滑，说明磨皮处理降低了图像中的暗部噪声。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show40.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show41.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show42.png"
                      alt="实际输出"
                ></p>
<p><strong>图4的分析</strong></p>
<p>图像的直方图曲线在整体上变得更加平滑，尤其是在亮度较高区域的变化更为明显。这可能意味着图像亮部的细节被稍微抑制，从而减少了噪声并增强了整体的视觉效果。</p>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h3 id="实验要求：-2"><a href="#实验要求：-2" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p> 将Sobel算子编码到pytorch卷积核中，并用编码的卷积核对图像100_3228.jpg执行卷积操作，输出结果（水平梯度图像、垂直梯度图像和梯度幅值图像），理解卷积操作与空间域滤波的关系。</p>
<p>实验图片路径为： imgs&#x2F;100_3228.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_3_i的格式，输出结果 比如结果保存为：outputs&#x2F;exp2_3_1.jpg</p>
<h3 id="实验方案：-2"><a href="#实验方案：-2" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p><strong>步骤一：读取和预处理图像</strong></p>
<ul>
<li>读取图像<code>100_3228.jpg</code>。</li>
<li>将图像转换为灰度格式以准备进行Sobel边缘检测。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img = transform(image)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：定义Sobel卷积核</strong></p>
<ul>
<li>定义Sobel卷积核<code>sobel_x</code>和<code>sobel_y</code>以检测水平和垂直边缘。</li>
<li>这些卷积核分别能够捕捉图像在水平和垂直方向上的梯度信息。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sobel_x = torch.Tensor([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">sobel_y = torch.Tensor([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：配置卷积层并执行卷积</strong></p>
<ul>
<li>配置卷积层以使用Sobel算子。</li>
<li>不使用偏置，因为在这种滤波操作中不需要。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">conv_x = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_y = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_x.weight.data = sobel_x</span><br><span class="line">conv_y.weight.data = sobel_y</span><br></pre></td></tr></table></figure></div>

<ul>
<li>应用Sobel算子于图像以得到水平和垂直梯度。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_x = conv_x(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br><span class="line">img_y = conv_y(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：计算梯度幅值</strong></p>
<ul>
<li>结合水平和垂直梯度以计算梯度幅值，这能够显示图像中边缘的整体强度。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_magnitude = torch.sqrt(img_x**<span class="number">2</span> + img_y**<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤五：执行阈值化处理</strong></p>
<ul>
<li>通过设置阈值，去除噪声并突出边缘。</li>
<li>阈值化后的结果只保留较强的边缘。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">threshold = img_magnitude.mean() * <span class="number">0.5</span></span><br></pre></td></tr></table></figure></div>

<p><strong>步骤六：可视化与保存结果</strong></p>
<ul>
<li>保存水平和垂直梯度图像，以及梯度幅值图像。</li>
<li>使用<code>matplotlib</code>对图像进行可视化。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">visualize_and_save(img_x_thresholded, <span class="string">&#x27;Horizontal Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_1.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_y_thresholded, <span class="string">&#x27;Vertical Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_2.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_magnitude, <span class="string">&#x27;Gradient Magnitude&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="实验结果：-2"><a href="#实验结果：-2" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show50.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show51.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show52.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show53.png"
                      alt="实际输出"
                ></p>
<ol>
<li><strong>水平梯度图像</strong>: 这张图像展示了原始图像中沿水平方向边缘的强度。在水平梯度图中，垂直边缘（如山和建筑物尖顶的轮廓）被突出显示。由于Sobel算子在水平方向上捕捉垂直边缘，所以图像中明显的垂直线条和特征在这里以较亮的像素显示出来，而水平边缘则不明显或显得较暗。</li>
<li><strong>垂直梯度图像</strong>: 与水平梯度图相对，这张图显示了沿垂直方向的边缘强度。在垂直梯度图中，水平边缘（如屋顶的边缘，建筑物所在地平缓处等等）更为明显。Sobel算子在垂直方向上识别水平边缘，因此图像中水平线条和特征在这张图上以亮像素呈现。</li>
<li><strong>梯度幅度图像</strong>: 此图像结合了水平和垂直梯度的信息，提供了边缘总体强度的视图。在梯度幅度图中，所有边缘，无论其方向如何，都以亮度的形式展现，其中亮度越强表示梯度幅度越大。这张图是通过计算水平梯度和垂直梯度在每个像素点的矢量和的幅度得到的。它提供了关于图像边缘强度最完整的视图，显示了所有明显边缘的位置。</li>
</ol>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>在本次实验中，我利用Python探索了图像处理中的空间域增强技术。实验的目标是通过对特定图像进行处理，以理解和应用直方图分析、图像取反、直方图均衡化以及卷积操作在图像增强和边缘检测中的作用。以下是本实验的关键发现和总结：</p>
<p><strong>直方图分析和图像取反</strong></p>
<ul>
<li>我观察了原始图像的直方图，并通过图像取反来了解亮度分布的变化。取反操作将图像中的亮区域变暗，暗区域变亮，直方图也相应地发生反转。</li>
</ul>
<p><strong>直方图均衡化</strong></p>
<ul>
<li>通过将图像转换到YUV色彩空间并对Y通道应用直方图均衡化，我显著提高了图像的对比度。直方图均衡化后的结果使得亮度分布更加均匀，从而增强了图像中的细节。</li>
</ul>
<p><strong>图像旋转和裁剪</strong></p>
<ul>
<li>通过旋转和裁剪操作，我成功地提取了图像中“爱丁堡花园”部分。这个过程涉及到对图像的几何变换，展示了图像处理中的区域选择技术。</li>
</ul>
<p><strong>滤波和磨皮效果</strong></p>
<ul>
<li>我对人脸图像应用了双边滤波器，实现了类似美图秀秀的磨皮效果。磨皮处理后，图像的直方图在低亮度区域变得更加平滑，显示了噪声的减少和肤色的均匀性提升。</li>
</ul>
<p><strong>Sobel边缘检测</strong></p>
<ul>
<li>将Sobel算子编码进PyTorch卷积核中并对图像进行处理，我得到了水平和垂直梯度图像以及梯度幅值图。这一过程说明了卷积操作如何作为空间域滤波器来检测图像中的边缘，是图像处理中边缘检测技术的一个经典例子。</li>
</ul>
<p>通过以上实验步骤，我加深了对图像增强技术的理解，特别是在如何利用不同的空间域滤波技术来改善视觉效果方面。实验结果表明，这些技术不仅可以增强图像的视觉质量，还可以为后续的图像分析工作提供更好的基础。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理与分析——实验二-空间域的图像增强</title>
    <url>/2024/04/10/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h3 id="实验目标："><a href="#实验目标：" class="headerlink" title="实验目标："></a><strong>实验目标：</strong></h3><p>用Python写一段程序，针对提供的图片IMG_2546.jpg，实现： </p>
<p>1. </p>
<ul>
<li><p>①查看直方图 </p>
</li>
<li><p>②取反，再查看直方图 </p>
</li>
<li><p>③使用直方图均衡，再查看直方图 </p>
</li>
<li><p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
</li>
</ul>
<ol start="2">
<li><p>人脸1.jpg、2.jpg、3.jpg、4.jpg进行滤波等操作实现类似美图秀秀磨皮功能，并对比磨皮前后直方图变化。</p>
</li>
<li><p>将Sobel算子编码到pytorch卷积核中，并用编码的卷积核对图像100_3228.jpg执行卷积操作，输出结果，理解卷积操作与空间域滤波的关系。</p>
</li>
</ol>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><ol>
<li>用Python写一段程序，针对提供的图片IMG_2546.jpg，实现：</li>
</ol>
<p>①查看直方图 </p>
<p>②取反，再查看直方图 </p>
<p>③使用直方图均衡，再查看直方图 </p>
<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p>实验图片路径为： imgs&#x2F;IMG_2546.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_1_i的格式，输出四个结果，比如①的结果保存为：outputs&#x2F;exp2_1_1.jpg</p>
<h3 id="实验方案："><a href="#实验方案：" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p><strong>步骤一：查看原图直方图</strong></p>
<ul>
<li>首先，加载图片并使用OpenCV库进行读取。</li>
<li>使用Matplotlib绘制图像的直方图，这是通过计算每个颜色通道的像素强度分布来完成的。</li>
<li>保存包含原图和直方图的组合图像为 <code>outputs/exp2_1_1.jpg</code>。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ①查看原图直方图</span></span><br><span class="line">save_image_and_histogram(img, <span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Original Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：取反图像并查看直方图</strong></p>
<ul>
<li>对原始图像进行取反操作，这意味着将每个像素的颜色值变为其补色。</li>
<li>再次绘制取反后图像的直方图，并保存。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ②取反并查看直方图</span></span><br><span class="line">img_neg = cv2.bitwise_not(img)</span><br><span class="line">save_image_and_histogram(img_neg, <span class="string">&#x27;Negative Image&#x27;</span>, <span class="string">&#x27;Negative Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：直方图均衡化并查看直方图</strong></p>
<ul>
<li>将图像从BGR色彩空间转换为YUV色彩空间。</li>
<li>对Y通道（亮度）进行直方图均衡化，这能改善图像的对比度。</li>
<li>再次绘制直方图均衡化后图像的直方图，并保存。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ③直方图均衡化并查看直方图</span></span><br><span class="line">img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span><br><span class="line">img_yuv[:,:,<span class="number">0</span>] = cv2.equalizeHist(img_yuv[:,:,<span class="number">0</span>])</span><br><span class="line">img_histeq = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)</span><br><span class="line">save_image_and_histogram(img_histeq, <span class="string">&#x27;Histogram Equalization&#x27;</span>, <span class="string">&#x27;Eq Histogram&#x27;</span>, <span class="string">&#x27;exp2_1_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：精确提取文本区域</strong></p>
<ul>
<li>考虑到文本可能因拍摄角度而不完全水平，我应用了一个旋转变换，使文本尽可能地水平以便裁剪。</li>
<li>设置旋转中心为图像中心，并指定旋转角度（在这里是-10度）。这个角度可能需要根据具体图片进行微调。</li>
<li>应用旋转后，根据旋转后的图像内容，手动确定“爱丁堡花园”文本的精确位置并进行裁剪。</li>
<li>最后，将旋转和裁剪后的区域保存为 <code>outputs/exp2_1_4.jpg</code>，这是仅包含目标文本区域的图片。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ④仅保留“爱丁堡花园”部分</span></span><br><span class="line"><span class="comment"># 获取图像尺寸用于计算旋转中心</span></span><br><span class="line">rows, cols, _ = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置旋转矩阵，中心点为图像中心，旋转角度为-10度，缩放因子为1</span></span><br><span class="line">M = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), -<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转图像</span></span><br><span class="line">rotated_img = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在旋转后的图像中确定“爱丁堡花园”文字的大致位置</span></span><br><span class="line">img_crop = rotated_img[<span class="number">550</span>:<span class="number">630</span>, <span class="number">600</span>:<span class="number">910</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存剪裁后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">f&#x27;<span class="subst">&#123;output_dir&#125;</span>exp2_1_4.jpg&#x27;</span>, img_crop)</span><br></pre></td></tr></table></figure></div>



<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p>①查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show01.png"
                      alt="实际输出"
                ></p>
<p>②取反，再查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show02.png"
                      alt="实际输出"
                ></p>
<p>③使用直方图均衡，再查看直方图 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show03.png"
                      alt="实际输出"
                ></p>
<p>④通过旋转、切割，仅保留“爱丁堡花园”部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show04.png"
                      alt="实际输出"
                ></p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p>人脸1.jpg、2.jpg、3.jpg、4.jpg进行滤波等操作实现类似美图秀秀磨皮功能，并对比磨皮前后直方图变化。</p>
<p>实验图片路径为： imgs&#x2F;1.jpg imgs&#x2F;2.jpg imgs&#x2F;3.jpg imgs&#x2F;4.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_2_i的格式，输出四个结果，比如结果保存为：outputs&#x2F;exp2_2_1.jpg</p>
<h3 id="实验方案：-1"><a href="#实验方案：-1" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p>通过应用双边滤波器对给定的人脸图像进行磨皮处理，然后对比处理前后图像的直方图变化。双边滤波器是一种非线性的滤波方法，它可以在平滑图像噪声的同时保留边缘信息，因此特别适合于图像美化处理。在Python中，可以使用OpenCV库中的<code>bilateralFilter</code>函数来实现这一操作。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用双边滤波器进行磨皮</span></span><br><span class="line">smoothed = cv2.bilateralFilter(image, d=<span class="number">9</span>, sigmaColor=<span class="number">75</span>, sigmaSpace=<span class="number">75</span>)</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>d</code>表示滤波器的直径，<code>sigmaColor</code>表示颜色空间的标准差，<code>sigmaSpace</code>表示坐标空间的标准差。这些参数决定了滤波器平滑图像的程度。</p>
<p>直方图的对比通过计算原图像和磨皮后图像的颜色直方图，并用不同颜色的线表示出来。这一过程可以直观地观察磨皮效果对图像色彩分布的影响。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算直方图并绘制</span></span><br><span class="line">hist_original = cv2.calcHist([original], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_smoothed = cv2.calcHist([smoothed], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(hist_original, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.plot(hist_smoothed, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;Smoothed&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show10.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show11.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show12.png"
                      alt="实际输出"
                ></p>
<p><strong>图1的分析</strong></p>
<p>原始图像和经过双边滤波处理后的图像在直方图上差别不大。这表明图像的磨皮效果较为自然，没有过度平滑，同时保持了原图的色彩特征。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show20.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show21.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show22.png"
                      alt="实际输出"
                ></p>
<p><strong>图2的分析</strong></p>
<p>可以看到在某些颜色通道中，经过滤波处理后的直方图在峰值附近略微平滑，但整体色彩分布的变化不是特别显著。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show30.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show31.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show32.png"
                      alt="实际输出"
                ></p>
<p><strong>图3的分析</strong></p>
<p>滤波后图像的直方图在低亮度区域有了平滑，说明磨皮处理降低了图像中的暗部噪声。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show40.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show41.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show42.png"
                      alt="实际输出"
                ></p>
<p><strong>图4的分析</strong></p>
<p>图像的直方图曲线在整体上变得更加平滑，尤其是在亮度较高区域的变化更为明显。这可能意味着图像亮部的细节被稍微抑制，从而减少了噪声并增强了整体的视觉效果。</p>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h3 id="实验要求：-2"><a href="#实验要求：-2" class="headerlink" title="实验要求："></a><strong>实验要求：</strong></h3><p> 将Sobel算子编码到pytorch卷积核中，并用编码的卷积核对图像100_3228.jpg执行卷积操作，输出结果（水平梯度图像、垂直梯度图像和梯度幅值图像），理解卷积操作与空间域滤波的关系。</p>
<p>实验图片路径为： imgs&#x2F;100_3228.jpg</p>
<p>输出路径为：outputs&#x2F;</p>
<p>请按照exp2_3_i的格式，输出结果 比如结果保存为：outputs&#x2F;exp2_3_1.jpg</p>
<h3 id="实验方案：-2"><a href="#实验方案：-2" class="headerlink" title="实验方案："></a><strong>实验方案：</strong></h3><p><strong>步骤一：读取和预处理图像</strong></p>
<ul>
<li>读取图像<code>100_3228.jpg</code>。</li>
<li>将图像转换为灰度格式以准备进行Sobel边缘检测。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img = transform(image)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤二：定义Sobel卷积核</strong></p>
<ul>
<li>定义Sobel卷积核<code>sobel_x</code>和<code>sobel_y</code>以检测水平和垂直边缘。</li>
<li>这些卷积核分别能够捕捉图像在水平和垂直方向上的梯度信息。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">sobel_x = torch.Tensor([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">sobel_y = torch.Tensor([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]]).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤三：配置卷积层并执行卷积</strong></p>
<ul>
<li>配置卷积层以使用Sobel算子。</li>
<li>不使用偏置，因为在这种滤波操作中不需要。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">conv_x = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_y = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">conv_x.weight.data = sobel_x</span><br><span class="line">conv_y.weight.data = sobel_y</span><br></pre></td></tr></table></figure></div>

<ul>
<li>应用Sobel算子于图像以得到水平和垂直梯度。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_x = conv_x(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br><span class="line">img_y = conv_y(Variable(img.unsqueeze(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤四：计算梯度幅值</strong></p>
<ul>
<li>结合水平和垂直梯度以计算梯度幅值，这能够显示图像中边缘的整体强度。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">img_magnitude = torch.sqrt(img_x**<span class="number">2</span> + img_y**<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>步骤五：执行阈值化处理</strong></p>
<ul>
<li>通过设置阈值，去除噪声并突出边缘。</li>
<li>阈值化后的结果只保留较强的边缘。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">threshold = img_magnitude.mean() * <span class="number">0.5</span></span><br></pre></td></tr></table></figure></div>

<p><strong>步骤六：可视化与保存结果</strong></p>
<ul>
<li>保存水平和垂直梯度图像，以及梯度幅值图像。</li>
<li>使用<code>matplotlib</code>对图像进行可视化。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">visualize_and_save(img_x_thresholded, <span class="string">&#x27;Horizontal Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_1.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_y_thresholded, <span class="string">&#x27;Vertical Gradient&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_2.jpg&#x27;</span>)</span><br><span class="line">visualize_and_save(img_magnitude, <span class="string">&#x27;Gradient Magnitude&#x27;</span>, <span class="string">&#x27;outputs/exp2_3_3.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="实验结果：-2"><a href="#实验结果：-2" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show50.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show51.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show52.png"
                      alt="实际输出"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/attachment_show53.png"
                      alt="实际输出"
                ></p>
<ol>
<li><strong>水平梯度图像</strong>: 这张图像展示了原始图像中沿水平方向边缘的强度。在水平梯度图中，垂直边缘（如山和建筑物尖顶的轮廓）被突出显示。由于Sobel算子在水平方向上捕捉垂直边缘，所以图像中明显的垂直线条和特征在这里以较亮的像素显示出来，而水平边缘则不明显或显得较暗。</li>
<li><strong>垂直梯度图像</strong>: 与水平梯度图相对，这张图显示了沿垂直方向的边缘强度。在垂直梯度图中，水平边缘（如屋顶的边缘，建筑物所在地平缓处等等）更为明显。Sobel算子在垂直方向上识别水平边缘，因此图像中水平线条和特征在这张图上以亮像素呈现。</li>
<li><strong>梯度幅度图像</strong>: 此图像结合了水平和垂直梯度的信息，提供了边缘总体强度的视图。在梯度幅度图中，所有边缘，无论其方向如何，都以亮度的形式展现，其中亮度越强表示梯度幅度越大。这张图是通过计算水平梯度和垂直梯度在每个像素点的矢量和的幅度得到的。它提供了关于图像边缘强度最完整的视图，显示了所有明显边缘的位置。</li>
</ol>
<h3 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a><strong>实验总结：</strong></h3><p>在本次实验中，我利用Python探索了图像处理中的空间域增强技术。实验的目标是通过对特定图像进行处理，以理解和应用直方图分析、图像取反、直方图均衡化以及卷积操作在图像增强和边缘检测中的作用。以下是本实验的关键发现和总结：</p>
<p><strong>直方图分析和图像取反</strong></p>
<ul>
<li>我观察了原始图像的直方图，并通过图像取反来了解亮度分布的变化。取反操作将图像中的亮区域变暗，暗区域变亮，直方图也相应地发生反转。</li>
</ul>
<p><strong>直方图均衡化</strong></p>
<ul>
<li>通过将图像转换到YUV色彩空间并对Y通道应用直方图均衡化，我显著提高了图像的对比度。直方图均衡化后的结果使得亮度分布更加均匀，从而增强了图像中的细节。</li>
</ul>
<p><strong>图像旋转和裁剪</strong></p>
<ul>
<li>通过旋转和裁剪操作，我成功地提取了图像中“爱丁堡花园”部分。这个过程涉及到对图像的几何变换，展示了图像处理中的区域选择技术。</li>
</ul>
<p><strong>滤波和磨皮效果</strong></p>
<ul>
<li>我对人脸图像应用了双边滤波器，实现了类似美图秀秀的磨皮效果。磨皮处理后，图像的直方图在低亮度区域变得更加平滑，显示了噪声的减少和肤色的均匀性提升。</li>
</ul>
<p><strong>Sobel边缘检测</strong></p>
<ul>
<li>将Sobel算子编码进PyTorch卷积核中并对图像进行处理，我得到了水平和垂直梯度图像以及梯度幅值图。这一过程说明了卷积操作如何作为空间域滤波器来检测图像中的边缘，是图像处理中边缘检测技术的一个经典例子。</li>
</ul>
<p>通过以上实验步骤，我加深了对图像增强技术的理解，特别是在如何利用不同的空间域滤波技术来改善视觉效果方面。实验结果表明，这些技术不仅可以增强图像的视觉质量，还可以为后续的图像分析工作提供更好的基础。</p>
]]></content>
      <categories>
        <category>本科项目</category>
        <category>图像处理与分析</category>
      </categories>
      <tags>
        <tag>课程项目</tag>
        <tag>作业报告</tag>
        <tag>图像处理与分析</tag>
      </tags>
  </entry>
</search>
